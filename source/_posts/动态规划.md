---
title: 动态规划
categories: 力扣
date: 2024-03-28 16:28:45
tags: 力扣

---

# 动态规划

# 一、解题思路

###### 1、确定dp数组以及其下标的含义

```

```

###### 2、递推公式

```

```

###### 3、dp数组该如何初始化

```

```

###### 4、遍历的顺序

```

```

###### 5、打印dp数组

```

```

<!--more-->

# 二、例题

## 1、 斐波那契数

### （1）、力扣 509 斐波那契数

```
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

示例 1：

输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
示例 2：

输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 3：

输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
 
```

题解：

###### 1、确定dp数组以及其下标的含义

```
dp[i] 是第i个斐波那契数
dp[2]即可
计算完后
dp[0] =dp[1];
dp[1] = sum;
```

###### 2、递推公式

```
dp[i] = dp[i-1] + dp[i-2]
```

###### 3、dp数组该如何初始化

```
看题目从01开始

dp[0] = 0;
dp[1] = 1;
```

###### 4、遍历的顺序

```
从下标2开始，一直到n结束
	[2,n]
```

###### 5、打印dp数组

```
如果n==0 返回 0
其他的返回sum(dp1)即可
```

###### 代码实现

```
int fib(int n) {
        if(n == 0) return 0;
        int dp[2];
        int sum=0;
        dp[0] =0; dp[1] =1;
        for(int i=2;i<=n;i++){
            sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
```

### （2）、 力扣 70 爬楼梯

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

题解：

###### 1、确定dp数组以及其下标的含义

```
dp[i] 下标i处有dp[i]种可能性
```

###### 2、递推公式

```
dp[n] = dp[n-1] + dp[n-2]
```

###### 3、dp数组该如何初始化

```
dp[1] =1
dp[2] =2
```

###### 4、遍历的顺序

```
[3,n]
```

###### 代码实现

```
int climbStairs(int n) {
        vector<int>dp(n+1);
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3;i<=n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
```

### （3）、力扣 746 使用最小花费爬楼梯

```
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

题解：

###### 1、确定dp数组以及其下标的含义

```
dp[i] 到达下标i的位置所需要的花费
```

###### 2、递推公式

```
因为要求最小花费，所以要在前两种里选择花费最小的方案
dp[i] += min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
```

###### 3、dp数组该如何初始化

```
初始楼梯也得计算，如果dp[0] =cost[0]会重复计算初始楼梯，所以初始化0；
```

###### 4、遍历的顺序

```
循环从i=2开始，计算从0，1开始
```

###### 代码实现

```
int minCostClimbingStairs(vector<int>& cost) {
        int n =cost.size();
        vector<int>dp(n+1);
        dp[0] = 0;
        dp[1] = 0;
        for(int i=2;i<=n;i++){
            dp[i] += min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]) ;
        }
        return dp[n];
    }
```

## 2、杨辉三角

### （1）力扣 62 、不同路径

```
一个机器人位于一个  m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？


示例 1：
输入：m = 3, n = 7
输出：28
```

题解：

###### 1、确定dp数组以及其下标的含义

```
dp[i][j] 到(i,j)处共有dp[i][j]种方法
```

###### 2、递推公式

```
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

###### 3、dp数组该如何初始化

```
因为只能向右和向下，所以第一行和第一列只有一种可能
```

###### 4、遍历的顺序

```
i:[1,m],j:[1,n]
```

###### 代码实现

```
int uniquePaths(int m, int n) {
        vector<vector<int>>dp(m,vector<int>(n));
        for(int i=0;i<m;i++) dp[i][0] = 1;
        for(int j=0;j<n;j++) dp[0][j] = 1;
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++)
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
        
        return dp[m-1][n-1];
    }
```

### （2）、力扣 63 不同路径 Ⅱ

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

示例 1：

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

题解：

###### 1、确定dp数组以及其下标的含义

```
dp[i][j] (i,j)处有dp[i][j]种走法
```

###### 2、递推公式

```
dp[i][j] = dp[i-1][j] + dp[i][j-1],且只有obstacleGrid[i][j]!=1时才做;
```

###### 3、dp数组该如何初始化

```
初始化全为0，代表没有路径可以走到这
```

###### 4、遍历的顺序

```
i:[1,m]
j:[1,n]
```

###### 代码实现

```
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>>dp(m,vector<int>(n,0));
        //如果入口和出口都被堵死
        if(obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;
        //直到行列上有障碍物
        for(int i=0;i<m && obstacleGrid[i][0] == 0;i++){
            dp[i][0] = 1;
        }
        for(int i=0;i<n && obstacleGrid[0][i] == 0;i++){
            dp[0][i] = 1;
        }

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]!=1)
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
```

## 3、力扣 343 整数拆分

```
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

 

示例 1:

输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

题解：

###### 1、确定dp数组以及其下标的含义

```
dp[i] 拆分数字i 得到最大乘积为dp[i]
```

###### 2、递推公式

```
i：数字，j：分出加数1 j ，另一个加数为 i-j

(i-j)*j 是当前层的两个加数乘积，dp[i-j]是加数2的最大乘积和当前加数j的乘积
当前加数的最大可能乘积就是 
max((i - j) * j, dp[i - j] * j)

dp[i] 的最大值就是所有加数中，乘积最大的一个 
dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))
```

###### 3、dp数组该如何初始化

```
1和0没有办法拆分，所以从dp[2]开始
```

###### 4、遍历的顺序

```
i:[3,n]
j:[1,i/2](防止重复)
```

###### 代码实现

```
int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); 
            }
        }
        return dp[n];
    }
```

## 4、卡特兰数

### （1）、力扣 96 不同的二叉搜索树

```
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。


示例 1：
输入：n = 3
输出：5
```

题解：

###### 1、确定dp数组以及其下标的含义

```
dp[i] 结点数为[1,i]的二叉树有dp[i]种可能
```

###### 2、递推公式

```
dp[i] += dp[j - 1] * dp[i - j]; 卡特兰数
j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
```

###### 3、dp数组该如何初始化

```
空二叉树也有结点，所以dp[0] = 1
```

###### 4、遍历的顺序

```
遍历i里面每一个数作为头结点的状态，用j来遍历
i:[1,n]
j:[1,j]
```

###### 代码实现

```
int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
```

## 5、背包问题

### 什么是01背包问题？

```
有n个价值为value，重量为weight的，不同的物品

有一个容量为k的背包

问如何拿取物品（不重复），能让背包内的总价值最高
```

###### 	例

```
		重量		价值
物品0		1		 15
物品1		3		 20
物品2		4     	 30

背包容量为 4
```

思路：

##### 	二维dp数组

```
dp[i][j]

[0,i]的物品
容量为j的背包，能装的最大价值为dp[i][j]
```

不放物品的情况

```
dp[i-1][j]
```

放物品的情况

```
dp[i-1][j-weight[i]] + value[i]
```

###### dp的递推公式为

```
大于背包容量了: 	j < weight[i]	dp[i][j] = dp[i-1][j];

比背包容量小: 	dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i])
```

###### 初始化

```
一般是 
dp [i][0] = 0;
dp[0][j] = value[0] 
具体情况具体讨论
```

###### 遍历顺序

```
一层遍历物品
[1,weight.size())	//第一行已经被特殊处理过了
一层遍历背包
[weight[i],k]
二维dp顺序可以换
```

###### 代码实现

```
int knapsack_2d(int capacity, vector<int>& weights, vector<int>& values) {
    int n = weights.size();
    vector<vector<int>> dp(n, vector<int>(capacity + 1, 0));
    
    for (int j = weights[0]; j <= capacity; j++) {//初始化
        dp[0][j] = values[0];
    }
    
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j <= capacity; ++j) {
            if (j < weights[i]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - weights[i]] + values[i]);
            }
        }
    }
  
```

##### 	一维dp数组（滚动数组）

```
dp[j]
容量为j的背包，能装的最大价值为dp[j]
```

不放物品的情况

```
dp[j]
```

放物品的情况

```
dp[j-weight[i]]+value[i]
```

###### 递推公式

```
dp[j] = max(dp[j],dp[j-weight[i]]+value[i])
```

###### 初始化

```
dp[0] = 0 (背包容量为0，所能容纳的价值也必然时0)

其余也全部置0 (便于后续比较)
```

###### 遍历顺序

```
第一层 ：物品	
i:[0,weight.size())
第二层 ：倒序 遍历背包（保证每个物品只被添加一次,当前状态的计算所依赖的是上一行的状态而不是当前行的状态）
[k,weight[i]]
	递推公式
```

###### 代码实现

```
int knapsack_1d(int capacity, vector<int>& weights, vector<int>& values) {
    vector<int> dp(capacity + 1, 0);
    int n = weights.size();
    for (int i = 0; i < n; ++i) {	//遍历物品
        for (int j = capacity; j >= weights[i]; --j) {	//倒叙遍历背包
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
        }
    }
    return dp[capacity];
}
```

### 例题

#### 1、力扣416 分割等和子集

```
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
示例 2：

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

题解：

```
求 给定背包容量，能不能装满这个背包。
```

两个子集元素和相等 ->两个子集和等于总和的一半

 转换成背包问题，

求在nums.size()个 价值和重量都为nums[i]的物品，

选取物品正好装满容量为sum(nums)/2的背包

###### 价值：

```
nums[i]
```

###### 重量：

```
nums[i]
```

###### 容量：

```
sum/2
```

一维dp：

```
bool canPartition(vector<int>& nums) {
        int sum =0;
        for(int i: nums)    sum+=i;
        if(sum%2 !=0) return false;
        else sum /= 2;
        
        int n=nums.size();
        vector<int>dp(sum+1,0);

        for(int i=0;i<n;i++)
            for(int j = sum;j>=nums[i];j--){
                dp[j] = max(dp[j],dp[j-nums[i]] + nums[i]);
                if(dp[j] == sum) return true;
            }
            
        return false;
    }
```

#### 2、力扣 1049 最后一块石头的重量 Ⅱ

```
有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

 

示例 1：

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

题解：

```
求 给定背包容量，尽可能装，最多能装多少
```

可以把题目看成分割两堆石头，让他们的重量尽可能相似

这样题目就和上面一题差不多了

###### 价值：

```
stones[i]
```

###### 重量：

```
stones[i]
```

###### 容量：

```
sum/2
```



```
int lastStoneWeightII(vector<int>& stones) {
        int sum=0;
        for(int i:stones) sum+=i;
        int ans = sum/2;
        int n = stones.size();
        vector<int>dp(ans+1,0);
        for(int i=0;i<n;i++){
            for(int j = ans;j>=stones[i];j--){
                dp[j] = max(dp[j],dp[j-stones[i]] + stones[i]);
            }
        }
        return sum - dp[ans]*2;
    }
```



#### 3、力扣 494 目标和

```
给你一个非负整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

 

示例 1：

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

题解：

```
求 给定背包容量，尽可能装，最多能装多少
```

将数组切割成两个部分

正数：left

负数：right

left+right = sum 

left - right = target

12合并

left = (sum+target)/2

那我们要求的就是有没有一个集合能满足 (sum+target)/2

###### 递推公式

本题则是装满有几种方法。其实这就是一个组合问题了

所有求组合类问题的公式，都是类似这种

```
dp[j] += dp[j - nums[i]]
```

在这个问题中，我们不需要使用 dp[j] = max(dp[j], dp[j - nums[i]] + 1); 这样的公式，因为我们不是在计算最大值，而是在计算所有可能的组合数。

```
int findTargetSumWays(vector<int>& nums, int target) {
        int sum=0;
        for(int i:nums) sum+=i;
        if (abs(target) > sum) return 0;

        if((sum+target)%2 ==0 ) 
            sum = (sum+target)/2;
        else 
            return 0;

        int n = nums.size();
        vector<int>dp(sum+1,0);
        dp[0] = 1; // 用0个元素可以得到0的组合数为1
    
        for(int i = 0; i < n; i++){
            for(int j = sum; j >= nums[i]; j--){
                dp[j] += dp[j - nums[i]];
            }  
        }
        
    return dp[sum];
    }
```

#### 4、力扣 474 一和零

```
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

 

示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

题解：

```
求 给定背包容量，装满背包最多有多少个物品。
```

本体是一个二维背包问题

我们同时要放重量为x的0 和重量为 y 的1

让他们满足0容量为i，1容量为j的背包

有多少个0就有多少重量，1同理

###### 价值：

```
1 ,1
```

###### 重量：

```
0.nums ,1.nums
```

###### 容量：

```
m,n
```



```
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
        
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

### 什么是完全背包？

**每个物品可以使用无数次**

###### 遍历顺序的更改

```
将背包的逆序遍历变成正序遍历

[weight[i],k];
```

**纯**完全背包的两层for循环**可以**颠倒顺序

### 例题

#### 1、力扣 518 零钱兑换Ⅱ

```
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 

示例 1：

输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

题解：

​	**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

​    **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

此题为排列

```
dp[j]
在 金额等于 j的时候，有dp[j]种可能
```

###### 递推公式

```
dp[j] += dp[j-coins[i]];
```

###### 代码实现

```
int change(int amount, vector<int>& coins) {
        vector<int>dp(amount+1,0);
        dp[0] =1;
        for(int i=0;i<coins.size();i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j] += dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
```

#### 2、力扣 377 组合总和 Ⅳ

```
给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

示例 1：

输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

题解

此题为组合

要先遍历背包，再遍历物品

```
int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= target; i++) { // 遍历背包
            for (int j = 0; j < nums.size(); j++) { // 遍历物品
                //i - nums[j] >= 0: 这部分确保了 i - nums[j] 不会越界
                //dp[i] < INT_MAX - dp[i - nums[j]]: 这部分确保了在将 dp[i - nums[j]] 加到 dp[i] 上时，不会发生溢出
                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
```

#### 3、力扣 322 零钱兑换

```
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

 

示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0
```

题解：

```
//dp[j]：凑足总额为j所需钱币的最少个数为dp[j]
//dp[j] = min(dp[j - coins[i]] + 1, dp[j])
//dp[j]必须初始化为一个最大的数
```



```
int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for(int i=0;i<coins.size();i++){
            for(int j = coins[i];j<=amount;j++){
                if(dp[j-coins[i]] < INT_MAX)//防止溢出
                    dp[j] = min(dp[j-coins[i]]+1,dp[j]);
            }
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
```

#### 4、力扣 279 完全平方数

```
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 

示例 1：

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：

输入：n = 13
输出：2
解释：13 = 4 + 9
 
```

题解

```
//dp[j] = 数字j可以由dp[j]个完全平方数组成
//dp[j] = min(dp[j - coins[i]] + 1, dp[j])
//nums[i] 用来标记是不是完全平方数,i是元素
```

```
int numSquares(int n) {
        int nums[10001]={0};//完全平方数表
        nums[1] = 1;
        for(int i=2;i<=100;i++){
            for(int j=i*i;j<10001;j*=j){
                nums[j] = 1;
            }
        }
        
        vector<int>dp(n+1,INT_MAX);
        dp[0]=0;
        for(int i=1;i<10001;i++){
            if(nums[i] == 0) continue;
            for(int j = i;j<=n;j++){
                if(dp[j-i] < INT_MAX)
                    dp[j] = min(dp[j],dp[j-i] + 1);
            }
        }
        
        return dp[n] == INT_MAX ? -1 : dp[n];
    }
```

#### 5、力扣 139 单词拆分

```
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
 
```

题解：

```
//定义状态：dp[i] 表示字符串 s 的前 i 个字符能否由字典中的单词拼接而成。
//初始化状态：dp[0] = true，表示空字符串可以由字典中的单词拼接而成。
//状态转移：对于每个 dp[i]，遍历字典中的单词，假设当前单词长度为 len，
//判断以 i-len 位置结束的子串是否可以由字典中的单词拼接而成，
//并且以当前单词结尾的子串是否与当前单词相同，如果是，则 dp[i] = true。
//最终返回 dp[s.length()]。
```

```
bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        int n = s.length();
        vector<bool> dp(n + 1, false);
        dp[0] = true; // 空字符串可以由字典中的单词拼接而成
    
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (dp[j] && wordSet.count(s.substr(j, i - j))) {
                    dp[i] = true;
                    break;
                }
            }
        }
    
        return dp[n];
        }
```

## 6、打家劫舍

### 1、力扣 198 打家劫舍

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

题解：

```
//定义状态：我们可以定义一个数组 dp，其中 dp[i] 表示前 i 间房屋能够偷窃到的最高金额。
//初始化状态：
//对于前两间房屋，dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])，
//表示偷第一间房屋或第二间房屋的最大金额。
//状态转移：对于第 i 间房屋，有两种选择：偷或不偷。
//如果偷第 i 间房屋，则最大金额为 dp[i-2] + nums[i]，因为相邻的房屋不能同时偷窃；
//如果不偷第 i 间房屋，则最大金额为 dp[i-1]。
//因此，状态转移方程为 dp[i] = max(dp[i-2] + nums[i], dp[i-1])。
//最终结果：最终结果即为 dp[n-1]，其中 n 为房屋的数量。
```

```
int rob(vector<int>& nums) {
        int n =nums.size();
        if(n < 2) return nums[0];
        vector<int>dp(n,0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        
        for(int i = 2;i<n;i++){
            dp[i] = max(dp[i-2]+nums[i],dp[i-1]);
        }
        return dp[n-1];
    }
```

### 2、力扣 213 打家劫舍 Ⅱ

```
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：

输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：

输入：nums = [1,2,3]
输出：3
```

```
//三种情况
//一：头尾都不偷
//二：头不偷，尾偷
//三：头偷，尾不偷
//由于情况1已经被23包括所以可以不考虑，比较两种结果哪个大就选那种
```

```
int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况三
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况二
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
```

### 3、力扣 337 打家劫舍 Ⅲ

```
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。

除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

示例 1:

输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

题解：递归三部曲＋动规五部曲

###### 确定递归函数的参数和返回值 和 dp数组的含义

```
这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。

vector<int> robTree(TreeNode* cur) {

其实这里的返回数组就是dp数组。
所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。

所以本题dp数组就是一个长度为2的数组！
```

###### 确定 终止条件 和 dp数组的初始化

```
在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回
```

###### 确定遍历顺序

```
首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。

通过递归左节点，得到左节点偷与不偷的金钱。

通过递归右节点，得到右节点偷与不偷的金钱。
```

###### 确定单层递归逻辑 和状态转移方程

```
如果是偷当前节点，那么左右孩子就不能偷，
val1 = cur->val + left[0] + right[0]; 
（如果对下标含义不理解就再回顾一下dp数组的含义）

如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：

val2 = max(left[0], left[1]) + max(right[0], right[1]);

最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}
```

###### 确定结果

```
最后头结点就是 取下标0 和 下标1的最大值就是偷得的最大金钱。
```

###### 代码实现

```
int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
```

## 7、股票问题

### 1、力扣 121 买卖股票的最佳时机（只买卖一次）

```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

题解：
```

###### 贪心

```
//左边起最小的数，到右边的最大差值
    int maxProfit(vector<int>& prices) {
      if (prices.empty()) return 0;
    
        int minPrice = prices[0];
        int maxProfit = 0;
    
        for (int i = 1; i < prices.size(); ++i) {
            minPrice = min(minPrice, prices[i]);
            maxProfit = max(maxProfit, prices[i] - minPrice);
        }
        return maxProfit;
    }
```

###### 动态规划

```
//dp[i][0] 第i天持有这支股票时的最大现金   
->dp[i][0] = max(dp[i-1][0],-prices[i])

//dp[i][1] 第i天不持有这支股票时的最大现金 
->dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])

//结果就是max(dp[len-1][0],dp[len-1][1])
//因为状态从上一次推到，从前往后
```

###### 代码实现

```
int maxProfit(vector<int>& prices) {
        int len =prices.size();
        vector<int>dp(2,0);
        
        dp[0] = -prices[0];
        dp[1] = 0;

        for(int i=1;i<len;i++){
            dp[0] = max(dp[0],-prices[i]);
            dp[1] = max(dp[1],dp[0]+prices[i]);
        }
        return dp[1];
    }
```

### 2、力扣 122 买卖股票的最佳时机Ⅱ（同时只能持有一支）

```
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

示例 1：

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
示例 3：
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

题解：

```
//dp[i][0]  第i天持有这支股票所拥有的钱     
->dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]); //上一天持有才能减
//dp[i][1]  第i天不持有这支股票所拥有的钱   
->dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i]); //上一天不持有才加
```

###### 代码实现

```
int maxProfit(vector<int>& prices) {
        int len = prices.size();
        
        vector<int>dp(2,0);
        dp[0] = -prices[0];
        dp[1] = 0;
        for(int i =1;i<len;i++){
            dp[0] = max(dp[0],dp[1] - prices[i]);
            dp[1] = max(dp[1],dp[0] + prices[i]);
        }
        return dp[1];
    }
```

### 3、力扣 123 买卖股票的最佳时机 Ⅲ（最多可以卖两次）

```
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3：

输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
示例 4：

输入：prices = [1]
输出：0
```

题解：

```
//dp[i][0] 第i天不操作
//dp[i][1] 第i天第一次持有
//dp[i][1] 第i天第一次不持有
    
//dp[i][1] 第i天第二次不持有
```

###### 代码实现

```
int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<int> dp(5, 0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
```

### 4、力扣 188 买卖股票的最佳时机 Ⅳ

```
给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1：

输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
示例 2：

输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

题解：

```
上题的2改成k
```

```
int maxProfit(int k, vector<int>& prices) {
        if(prices.empty()) return 0;
        int len =prices.size();
        vector<int>dp(k*2+1,0);
        for(int i=1;i<=k*2;i+=2)
            dp[i] = -prices[0];
        
        for(int i=1;i<len;i++)
            for(int j=1;j<=k*2;j++){
                if(j%2 == 1)
                    dp[j] = max(dp[j],dp[j-1] - prices[i]);
                else
                    dp[j] = max(dp[j],dp[j-1] + prices[i]);
            }
            
        return dp[2*k];
    }
```

### 5、 力扣 309 买卖股票的最佳时机（冷冻期）

```
给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
示例 2:

输入: prices = [1]
输出: 0
```

题解：

```
// dp[0] 表示持有股票时的最大收益
// dp[1] 表示保持卖出股票时的最大收益
// dp[2] 表示卖出股票时的最大收益
// dp[3] 表示冷冻期的最大收益

"保持卖出"的状态表示在卖出股票后需要经过一天的冷冻期，因此在这个状态下，您不能再次购买股票，只能保持卖出的状态。
```

###### 代码实现

```
int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        vector<int> dp(4, 0);
        dp[0] = -prices[0];
        for(int i = 1; i < prices.size(); i++){
            //保存前一天持有股票和冷冻期的最大收益
            int prevHold = dp[0];
            int prevSell = dp[2];
            
            // 更新持有股票时的最大收益，考虑两种情况：
            // 1. 前一天持有股票
            // 2. 前一天处于冷冻期
            dp[0] = max(dp[0], dp[3] - prices[i]);
            
            // 更新保持卖出股票时的最大收益
            dp[1] = prevHold + prices[i];
           
           // 更新卖出股票时的最大收益
            dp[2] = max(prevSell, dp[1]);
           
           //更新冷冻期的最大收益
            dp[3] = prevSell;
        }
        return max(dp[1], dp[2]);
    }
```

### 6、力扣 714 买卖股票的最佳时机（手续费）

```
给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

示例 1：

输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
示例 2：

输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```

题解：

```
和第二题比 多减一个fee
```



```
int maxProfit(vector<int>& prices, int fee) {
        if(prices.empty()) return 0;
        vector<int>dp(2);
        dp[0] = -prices[0];
        for(int i=1;i<prices.size();i++){
            dp[0] = max(dp[0],dp[1] -prices[i]);
            dp[1] = max(dp[1],dp[0] + prices[i] - fee);
        }
        return dp[1];
    }
```

## 8、子序列/数组问题

### 1、力扣 300 最长递增子序列

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的
子序列
。

 
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1
```

题解：

```
//dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度
//if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
//每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.
```

###### 代码实现

```
 int lengthOfLIS(vector<int>& nums) {
        int len = nums.size();
        if(len <=1 ) return len;
        vector<int>dp(len,1);
        int ans=0;
        
        for(int i=1;i<len;i++){
            for(int j=0;j<=i;j++)
                if(nums[i] > nums[j]) dp[i] = max(dp[i],dp[j]+1);
            if(dp[i] > ans) ans = dp[i];
        }
        return ans;
    }
```

### 2、力扣 674 最长连续递增序列

```
给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

示例 1：

输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
示例 2：

输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
```

题解：

双指针法

```
int findLengthOfLCIS(vector<int>& nums) {
        int ans=0;
        int start =0;
        int left = start;
        int right =1;
        while(right < nums.size()){
            if(nums[left] < nums[right]){
                left++;
                right++;
            }else{
                ans = max(ans,left-start+1);
                start = right;
                left = start;
                right = left+1;
            }
        }
        return max(ans,left-start+1);
    }
```

动态规划

题解：

```
//dp[i] 下标为i的最长子序列
//dp[i] = dp[i-1] +1;(if(nums[i] > nums[i-1]))
```

###### 代码实现

```
int findLengthOfLCIS(vector<int>& nums) {
        int len = nums.size();
        if(len <=1) return len;
        vector<int>dp(len,1);
        int ans =0;
        for(int i=1;i<len;i++){
            if(nums[i] > nums[i-1]) dp[i] = dp[i-1] +1;
            ans = max(ans,dp[i]);
            
        }        
        return ans;
    }
```

### 3、力扣 718 最长重复子数组

```
给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。

 

示例 1：

输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
示例 2：

输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
```

题解

```
//动态规划数组 dp[j] 的含义是以数组 A 的第 i 个元素结尾和数组 B 的第 j 个元素结尾的公共子数组的长度
//将 result 初始化为 0，用来记录最长公共子数组的长度
//如果当前数组 A 和数组 B 中的元素相等，说明我们找到了一个公共元素 
-> dp[j] = dp[j - 1] + 1
//如果当前数组 A 和数组 B 中的元素不相等,说明当前位置不是公共子数组的结尾，因此公共子数组的长度被打断，需要重新计数，将 dp[j] 置为 0
//外层循环遍历数组 A 中的每个元素，内层循环倒序遍历数组 B 中的每个元素。这样的遍历顺序确保了在更新 dp[j] 时，我们能够使用上一轮迭代中 dp[j-1] 的值，以便进行状态转移。
```

###### 代码实现

```
int findLength(vector<int>& A, vector<int>& B) {
        vector<int>dp(B.size()+1,0);
        int ans =0;
        for(int i=1;i<=A.size();i++){
            for(int j = B.size();j>0;j--){
                if(A[i-1] == B[j-1])
                    dp[j] = dp[j-1] + 1;
                else dp[j] =0;
            ans = max(ans,dp[j]);
            }
        }
        return ans;
    }
```

### 4、 力扣 1143 最长公共子序列

```
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

 

示例 1：

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
示例 2：

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
示例 3：

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

题解：

```
和上题最大的区别是，
子数组是要按顺序来的
子序列是可以跳过一些元素
用双数组简单一点
二维数组中的每个元素 dp[i][j] 可以直接通过 dp[i - 1][j - 1]、dp[i - 1][j] 和 dp[i][j - 1] 这三个相邻的状态来更新，因此不需要额外的中间变量。


//dp[i][j] 表示的是字符串 text1 的前 i 个字符和字符串 text2 的前 j 个字符的最长公共子序列的长度
//dp 的第一行和第一列都初始化为 0，这样可以避免单独处理边界情况。
//text1[i - 1] == text2[j - 1]，说明当前字符相等，可以将当前字符纳入最长公共子序列中，
因此 dp[i][j] 的值应该是 dp[i - 1][j - 1] 的值加上 1。
//text1[i - 1] != text2[j - 1]，说明当前字符不相等，取两者中较大的值作为 dp[i][j] 的值。
即 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])。
//内层循环控制 text2 的字符。遍历顺序是从前往后，从左往右遍历，保证了在更新 dp[i][j] 的时候，我们可以利用前面已经计算过的子问题的结果。

```

###### 代码实现

```
int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
```

### 5、力扣 1035 不相交的线

```
在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：

 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

 

示例 1：


输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
示例 2：

输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3
示例 3：

输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2
```

题解：

```
说了一大堆，仔细想想球的就是最长公共子序列
```

###### 代码实现

```
int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>>dp(nums1.size()+1,vector<int>(nums2.size()+1,0));
        for(int i=1;i<=nums1.size();i++){
            for(int j =1;j<=nums2.size();j++){
                if(nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] +1;
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[nums1.size()][nums2.size()];
    }
```

### 6、力扣 53 最大子数组和

```
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组
是数组中的一个连续部分。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [5,4,-1,7,8]
输出：23
```

题解：

```
//dp[i] i位的最大子数组和
//两种状态 
1：拿当前 的 nums[i] + dp[i-1]
2：不拿 nums[i]
取两个中最大的
 ans记录就行
```

###### 代码实现

```
int maxSubArray(vector<int>& nums) {
        vector<int>dp(nums.size(),0);
        if(nums.size() <= 1) return nums[0];
        dp[0] = nums[0];
        int ans =dp[0];
        for(int i=1;i<nums.size();i++){
            dp[i] += max(nums[i],nums[i]+dp[i-1]);
            ans = max(dp[i],ans);
        }
        return ans;
    }
```

### 7、力扣 115 不同的子序列

```
给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。

 

示例 1：

输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabbbit
rabbbit
rabbbit
示例 2：

输入：s = "babgbag", t = "bag"
输出：5
解释：
如下所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
babgbag
babgbag
babgbag
babgbag
babgbag
```

题解

```
dp[i][j] 表示在字符串 s 的前 i 个字符中，字符串 t 的前 j 个字符出现的次数。

当 t 是空字符串时，任何非空字符串 s 都只有一个子序列与之匹配，即 dp[i][0] = 1
当 s 是空字符串时，任何非空字符串 t 都没有子序列与之匹配，即 dp[0][j] = 0。

状态转移：根据 s[i] 和 t[j] 是否相等，可以分为两种情况：

如果 s[i] 和 t[j] 相等，
则 s 的前 i 个字符中，t 的前 j 个字符出现的次数等于 s 的前 i-1 个字符中，t 的前 j-1 个字符出现的次数加上 s 的前 i-1 个字符中 t 的前 j 个字符出现的次数
即 dp[i][j] = dp[i-1][j-1] + dp[i-1][j]。

如果 s[i] 和 t[j] 不相等，
则 s 的前 i 个字符中，t 的前 j 个字符出现的次数等于 s 的前 i-1 个字符中 t 的前 j 个字符出现的次数
即 dp[i][j] = dp[i-1][j]。

最终结果即为 dp[s.size()][t.size()]，表示在字符串 s 的子序列中，字符串 t 出现的个数。
```

###### 代码实现

```
int numDistinct(string s, string t) {
        vector<vector<uint64_t>>dp(s.size()+1,vector<uint64_t>(t.size()+1,0));

        for(int i=0;i<=s.size();i++)
            dp[i][0] = 1;

        for(int i=1;i<=s.size();i++){
            for(int j =1;j<=t.size();j++){
                if(s[i-1] == t[j-1])
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[s.size()][t.size()];
    }
```

### 8、力扣 583 两个字符串的删除操作

```
给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。

每步 可以删除任意一个字符串中的一个字符。

 

示例 1：

输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
示例  2:

输入：word1 = "leetcode", word2 = "etco"
输出：4
```

题解

```
求公共最长子序列，然后两个长度加起来减去两个公共最长子序列就是了
```

###### 代码实现

```
int minDistance(string word1, string word2) {
        int len1 = word1.size();
        int len2 = word2.size();
        vector<vector<int>>dp(len1+1,vector<int>(len2+1,0));
        for(int i =1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1] +1;
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
        int max_len = dp[len1][len2];
        return len1-max_len + len2 - max_len;
    }
```

### 9、力扣 72 编辑距离

```
给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
 

示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

题解：

```
dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作数。

插入操作：在 word1 的第 i 个字符后面插入一个与 word2 的第 j 个字符相同的字符，使得 word1 的前 i 个字符变成 word2 的前 j 个字符，操作数加 1。
-》dp[i][j-1]

删除操作：删除 word1 的第 i 个字符，使得 word1 的前 i 个字符变成 word2 的前 j 个字符，操作数加 1
-》dp[i-1][j]

替换操作：将 word1 的第 i 个字符替换为 word2 的第 j 个字符，使得 word1 的前 i 个字符变成 word2 的前 j 个字符，操作数加 1（替换是删除＋操作）
-》dp[i-1][j-1]


当 i=0 时，表示从空字符串转换为 word2，因此 dp[0][j] = j，即插入 j 个字符。
当 j=0 时，表示从 word1 转换为空字符串，因此 dp[i][0] = i，即删除 i 个字符。

我们使用两层循环，外层循环遍历 word1 的每个字符，内层循环遍历 word2 的每个字符。
通过从前往后遍历，保证在计算 dp[i][j] 时，可以利用前面已经计算过的 dp 值。
```

###### 代码实现

```
int minDistance(string word1, string word2) {
    int m = word1.size(), n = word2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // 初始化
    for (int i = 0; i <= m; ++i) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= n; ++j) {
        dp[0][j] = j;
    }

    // 动态规划
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
            }
        }
    }

    return dp[m][n];
}
```

### 10、力扣 647 回文子串

```
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 

示例 1：

输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：

输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

题解：

```
dp[i][j] 表示从索引 i 到索引 j 的子串是否是回文子串。若 dp[i][j] 为 true，则说明子串 s[i:j] 是一个回文子串
如果子串的左右两个字符相等，且去掉左右两个字符后的子串仍为回文子串，则当前子串也是回文子串。


特别地，当子串长度为 1 或 2 时，只需判断左右两个字符是否相等即可

s[i] == s[j] 且 dp[i+1][j-1] == true （或者长度等于2）时，
 dp[i][j] = true
表示子串 s[i:j] 是一个回文子串。

当子串长度为 1 时，任何单个字符都是回文子串，因此 dp[i][i] = true。
当子串长度为 2 时，只有当两个字符相等时才是回文子串，即 dp[i][i+1] = (s[i] == s[i+1])。

我们从子串长度为 1 开始，逐渐增加子串长度，直到整个字符串长度。
内层循环从字符串的起始位置开始，直到第 n - len 个位置，这样可以保证子串的长度为 len 时，其起始位置不会超出字符串的边界

通过这样的遍历顺序，我们可以确保在计算 dp[i][j] 时，左侧和上方的子问题 dp[i+1][j-1] 已经得到解决。
```

###### 代码实现

```
int countSubstrings(string s) {
    int n = s.size();
    vector<vector<bool>> dp(n, vector<bool>(n, false)); // 定义动态规划数组，dp[i][j] 表示 s[i:j] 是否是回文子串
    int count = 0; // 记录回文子串数量

    // 初始化
    for (int i = 0; i < n; ++i) {
        dp[i][i] = true; // 单个字符是回文子串
        ++count;
    }

    // 动态规划
    for (int len = 2; len <= n; ++len) { // 遍历子串长度
        for (int i = 0; i <= n - len; ++i) { // 遍历子串起始位置
            int j = i + len - 1; // 子串结束位置
            if (s[i] == s[j] && (len == 2 || dp[i+1][j-1])) { // 判断子串是否是回文子串
                dp[i][j] = true;
                ++count;
            }
        }
    }

    return count; // 返回回文子串数量
}
```

### 11、力扣  516 最长回文子序列

```
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

 

示例 1：

输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
示例 2：

输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```

题解

```
反转一下求最长公共子序列
```

###### 代码实现

```
int longestPalindromeSubseq(string s) {
        string s2 = s;
        reverse(s2.begin(),s2.end());
        int len = s.size();
        vector<vector<int>>dp(len+1,vector<int>(len+1,0));
        for(int i=1;i<=len;i++){
            for(int j=1;j<=len;j++){
                if(s[i-1] == s2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[len][len];
    }
```

