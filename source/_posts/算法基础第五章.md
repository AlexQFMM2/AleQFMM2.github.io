---
title: 动态规划（ACwing）
categories: ACWing
date: 2024-5-3 14:28:45
tags: 算法基础
---

# 动态规划

<!--more-->

# 一、背包问题

|      | 01背包                            | 完全背包         | 多重背包                                 | 多重背包优化       | 分组背包               |
| ---- | --------------------------------- | ---------------- | ---------------------------------------- | ------------------ | ---------------------- |
| 场景 | 每件物品只能拿一次                | 每件物品无限拿   | 每件物品有指定次数                       | 每件物品有指定次数 | 物品被分组了           |
| 顺序 | 正序物品，倒序背包容量到weight[i] | 背包正序倒序都行 | 背包正序倒序都行，还要多遍历一个物品数量 |                    | 多遍历一个物品重量分组 |
|      |                                   |                  |                                          |                    |                        |

###### 核心代码



###### 01背包

```
vector<int>weight(n+1,0);//物品i的重量为weight[i]
vector<int>value(n+1,0);//物品i的价值为values[i]
```



```
vector<int> dp(v+1, 0); // dp[j]表示容量为j的背包所能装的最大价值

    for(int i=1;i<=n;i++){ // 遍历物品
        for(int j=v;j>=weight[i];j--){ // 正序背包容量
            dp[j] = max(dp[j], dp[j-weight[i]] + value[i]);
        }
    }
```

###### 完全背包

```
vector<int>weight(n+1,0);//物品i的重量为weight[i]
vector<int>value(n+1,0);//物品i的价值为values[i]
```



```
vector<int>dp(v+1,0);
    for(int i=1;i<=n;++i){
        for(int j=weight[i];j<=v;j++){//正序遍历背包
            dp[j] = max(dp[j],dp[j-weight[i]]+value[i]);
        }
    }
    cout << dp[v] << endl;
```



###### 多重背包

```
vector<int>weight(n+1,0);//物品i的重量为weight[i]
vector<int>values(n+1,0);//物品i的价值为values[i]
vector<int>nums(n+1,0);//物品i的数量为nums[i]
```



```
 vector<int>dp(v+1,0);//体积为j的背包价值最高为dp[j]

    for(int i=1;i<=n;i++){
        for(int j=v;j>=weight[i];j--){
            for(int k=0;k<=nums[i] && k*weight[i]<=j;k++){//拿k个
                dp[j] = max(dp[j], dp[j-k*weight[i]] + k*values[i]);
            }
        }
    }
```



###### 多重背包二进制优化

```
vector<int>dp(v+1,0);//体积为i的背包价值最高为dp[i]

    for(int i=1;i<=n;i++){
        if(nums[i]*weight[i] >= v){ // 如果物品i数量*物品i重量大于等于v，直接当做完全背包处理
            for(int j=weight[i];j<=v;j++){
                dp[j] = max(dp[j], dp[j-weight[i]] + values[i]);
            }
        }else{ // 否则使用二进制优化方法
            int k = 1;
            while(k < nums[i]){
                for(int j=v;j>=k*weight[i];j--){
                    dp[j] = max(dp[j], dp[j-k*weight[i]] + k*values[i]);
                }
                nums[i] -= k;
                k *= 2;
            }
            for(int j=v;j>=nums[i]*weight[i];j--){
                dp[j] = max(dp[j], dp[j-nums[i]*weight[i]] + nums[i]*values[i]);
            }
        }
    }
```



###### 分组背包

```
vector<int> weight[N];
vector<int> values[N];
```



```
for(int i = 1; i <= n; i++){
        int num;
        cin >> num;
        for(int j = 1; j <= num; j++){
            int x, y;
            cin >> x >> y;
            weight[i].push_back(x);
            values[i].push_back(y);
        }
    }

    vector<int> dp(v+1, 0);

    for(int i = 1; i <= n; i++){//物品
        for(int j = v; j >= 0; j--){//倒序背包容量
            for(int k = 0; k < weight[i].size(); k++){//正序遍历每一组的数量
                if(j >= weight[i][k]){
                    dp[j] = max(dp[j], dp[j - weight[i][k]] + values[i][k]);
                }
            }
        }
    }
```

# 二、子序列问题

## 1、最长上升子序列

```
#include<iostream>
#include<vector>
using namespace std;

int search(vector<int>& tails,int l,int r,int target){//查找第一个大于等于target的值
	while(l<r){
		int mid = l+r >> 1;
		if(tails[mid] < target) l=mid+1;
		else r=mid;
	}
	return r;
}

int main(){
    int n;
    cin >> n;
    vector<int> nums(n);
    for(int i = 0; i < n; i++)
        cin >> nums[i];

    vector<int> tails(n);//记录最长单调递增子序列
    tails[0] = nums[0];
	int td = 0;
	
    for(int i = 1; i < n; i++){
        if(nums[i] > tails[td]){
            tails[++td] = nums[i];
        } else {//二分查找并替换第一个大于等于nums[i]的值
            int idx = search(tails,0,td,nums[i]);
            tails[idx] = nums[i];
        }
    }

    cout << td+1 << endl;
    return 0;
}

```



## 2、最长公共子序列

```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int len1, len2;
    string s1, s2;
    cin >> len1 >> len2 >> s1 >> s2;

    // s1 的前 i 个字符和字符串 s2 的前 j 个字符的最长公共子序列长度为dp[i][j]
    vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));

    // 填充动态规划数组
    for (int i = 1; i <= len1; ++i) {
        for (int j = 1; j <= len2; ++j) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    cout << dp[len1][len2] << endl;

    return 0;
}
```



## 3、编辑距离

```
#include<iostream>
#include<vector>
using namespace std;
const int N = 11;

int dp[N][N];//不放全局会超时

bool change(const string& s1,const string& s2,int times){//统计s1->s2所需要的次数
    int len1 = s1.size(),len2 = s2.size();

    for(int i=0;i<=len1;i++) dp[i][0] = i;//s1(1~i)变成空字符串要进行i次删除操作
    for(int j=0;j<=len2;j++) dp[0][j] = j;//s2(1~j)变成空字符串要进行j次删除操作

    for(int i=1;i<=len1;i++){
        for(int j=1;j<=len2;j++){
            if(s1[i-1] == s2[j-1])
                dp[i][j] = dp[i-1][j-1];
            else//依次是插入，删除，替换
                dp[i][j] = min(dp[i][j-1]+1,min(dp[i-1][j]+1,dp[i-1][j-1]+1));
        }
    }

    if(dp[len1][len2] <= times)
        return true;
    else 
        return false;
}

int main(){
    int n,m;
    cin >> n >> m;
    vector<string>str(n);
    for(int i=0;i<n;i++)
        cin >> str[i];

    for(int i=0;i<m;i++){
        string s1;
        int t,cnt=0;
        cin >> s1 >> t;
        for(const string& s:str){
            if(change(s,s1,t)) ++cnt;//看能不能在t次能完成字符串转换
        }
        cout << cnt << endl;
    }
    return 0;
}
```

## 4、子序列的个数

```
s1中有多少子序列等于s2
```

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2024;
const int M = 5;

ll dp[N*N][M]; // s1(1~i)中拥有dp[i][j]个s2(1~j)
ll count(const string& s1,const string& s2){//计算s1中有子序列s2多个 
	int n=s1.size();
    int m=s2.size();
    dp[0][0]=1;//空字符串 A 包含空字符串 B 的子序列个数为 1
    
    for(int i=1;i<=n;i++){
        dp[i][0]=1;//A 的前 i 个字符中包含空字符串 B 的子序列个数为 1
        for(int j=1;j<=m;j++){  
            if(s1[i-1]==s2[j-1]){ 
                dp[i][j]=dp[i-1][j]+dp[i-1][j-1];//拿当前字符的情况是dp[i-1][j-1]，不拿就是dp[i-1][j]，只有相等才能拿; 
            }else{
            	dp[i][j]=dp[i-1][j];
			}
        }
    }
    return dp[n][m];
}
```



# 三、区间dp

```
设有 N堆石子排成一排，其编号为 1,2,3,…,N
每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和
找出一种合理的方法，使总的代价最小，输出最小代价。
```



```
#include<iostream>
#include<vector>
using namespace std;

const int N = 301;
int dp[N][N]; // dp[i][j] 表示将区间 [i, j] 的石子合并成一堆所需要的最小代价

int main(){
    int n;
    cin >> n;
    vector<int> nums(n);
    vector<int> sum(n + 1, 0); // 前缀和
    for(int i = 0; i < n; i++) {
        cin >> nums[i];
        sum[i + 1] = sum[i] + nums[i]; // 计算前缀和
    } 
    
    for(int len = 2; len <= n; len++) {// 枚举区间长度
        
        for(int i = 1; i + len - 1 <= n; i++) {// 枚举区间起点
            int j = i + len - 1; // 区间终点
            dp[i][j] = 1e9; // 初始化为一个很大的值

            for(int k = i; k < j; k++) {// 枚举分割点
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]);// 更新最小代价
            }
        }
    }

    cout << dp[1][n] << endl; // 输出合并所有石子的最小代价
    return 0;
}

```

# 四、计数DP

```
一个正整数 n
 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk
，其中 n1≥n2≥…≥nk,k≥1
。

我们将这样的一种表示称为正整数 n
 的一种划分。

现在给定一个正整数 n
，请你求出 n
 共有多少种不同的划分方法。

输入格式
共一行，包含一个整数 n
。

输出格式
共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 109+7
 取模。

数据范围
1≤n≤1000
输入样例:
5
输出样例：
7
```

```
#include <iostream>
using namespace std;

const int N = 1001;
const int mod = 1e9+7;
int dp[N]; //表示正整数 i 可以表示成若干个正整数之和的划分方法数

int main() {
    int n;
    cin >> n;
    dp[0] = 1;
    
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            dp[j] = (dp[j]+dp[j-i])%mod;
        }
    }
    cout << dp[n] << endl; 
    return 0;
}
```

