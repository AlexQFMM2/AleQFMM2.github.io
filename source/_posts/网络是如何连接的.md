---
title: 网络是如何连接的
categories: 阅读
date: 2024-03-07 16:28:45
tags: 网络
---

# 网络是如何连接的（TCP/IP编程）

## 一、网络连接的大致概括

###### 1、dns解析

DNS 查询通过递归查询和迭代查询的方式来逐级获取 IP 地址。当你输入一个域名时，首先查询的是本地的 DNS 缓存，若未命中则通过本地 DNS 服务器向根 DNS 服务器发送查询请求。根 DNS 服务器会指向顶级域名服务器（如 .com、.org），然后逐步找到权威 DNS 服务器，最终返回对应的 IP 地址。

###### 2、socket（套接字）创建

使用socket库中的socket组件创立一个套接字，创建成功后会返回一个描述符

###### 3、服务器连接

使用socket库中的connect组件进行连接（客户端连接服务器）

###### 4、数据的发送与接受

通过socket库中的write或者send组件进行发送

通过socket库中的read或者recv组件进行接受

###### 5、断开连接

通过socket库中的close组件进行断开连接

<!--more-->

###### 追加：在ubuntu下的dns解析器的调用

```
alexqfmm@ubuntu:~/Codes/dns解析$ cat main.cpp 
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

int main(int argc, char **argv)
{

  if (argc != 2) // 如果输入的参数没有域名则提示
  {
    printf("Please input a hostname\n");
    return 0;
  }

  int get_back = -1;        // 定义getaddrinfo函数返回值
  struct addrinfo hints;    // 定义一个结构体
  struct addrinfo *res;     // 定义函数返回的结构体链表的指针
  struct addrinfo *read;    // 定义一个遍历链表的指针
  struct sockaddr_in *addr; // 定义一个存储返回域名IP信息的结构体指针

  memset(&hints, 0, sizeof(hints)); // 将存放信息的结构体清零
  hints.ai_flags = AI_PASSIVE;      // 写入期望返回的结构体的相关信息
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_family = AF_INET;
  hints.ai_protocol = 0;

  get_back = getaddrinfo(argv[1], NULL, &hints, &res); // 调用函数

  if (get_back != 0) // 如果函数调用失败
  {
    printf("Analyze faliure:%s\n", strerror(errno));
    return -1;
  }

  printf("Analyze successfully\n"); // 调用函数成功

  for (read = res; read != NULL; read = read->ai_next) // 遍历链表每一个节点，查询关于存储返回的IP的信息
  {
    addr = (struct sockaddr_in *)read->ai_addr;            // 将返回的IP信息存储在addr指向的结构体中
    printf("IP address: %s\n", inet_ntoa(addr->sin_addr)); // inet_ntoa函数将字符串类型IP地址转化为点分十进制
  }

  freeaddrinfo(res); // 释放getaddrinfo函数调用动态获取的空间

  return 0;
}

```

检测正确性

```
alexqfmm@ubuntu:~/Codes/dns解析$ ./main.out www.baidu.com
Analyze successfully
IP address: 223.109.82.41
IP address: 223.109.82.6

alexqfmm@ubuntu:~/Codes/dns解析$ nslookup www.baidu.com
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
www.baidu.com	canonical name = www.a.shifen.com.
Name:	www.a.shifen.com
Address: 223.109.82.41
Name:	www.a.shifen.com
Address: 223.109.82.6
Name:	www.a.shifen.com
Address: 2409:8c20:6:1d55:0:ff:b09c:7d77
Name:	www.a.shifen.com
Address: 2409:8c20:6:1135:0:ff:b027:210c
```

# TPC/IP编程

## 1、hello（TCP）

### linux版本

server端（具体客户机和服务器双端的搭建方式查看网络连接的前篇博客）

```
#include <iostream>
#include <string>
#include <cstring>

#include <unistd.h>     // 提供close()函数，进程控制等Unix系统调用

#include <arpa/inet.h>  // 提供IP地址转换函数，如htonl(), htons()等
#include <sys/socket.h> // 提供socket创建、绑定、监听、接受等套接字相关操作
#include <netinet/in.h> // 包含 sockaddr_in 结构体定义，该头文件被#include<sys/socket.h>包括
#include <cerrno>       //perror
```

```
using namespace std;
```

```
//服务器套节字和客户端套节字，int型
int s_sock, c_sock;

//sockaddr_in:存储网络地址结构如下
/*
struct sockaddr_in {
    sa_family_t    sin_family; // 地址族（通常是 AF_INET）
    uint16_t       sin_port;   // 端口号，以网络字节序（大端）存储
    struct in_addr sin_addr;   // IP 地址             
};

// 结构体中的内嵌结构体
struct in_addr {
    uint32_t s_addr;           // IP 地址，以网络字节序（大端）存储
};
*/
struct sockaddr_in s_addr, c_addr;

//socklen_t 是一个无符号整数类型，用于表示套接字地址结构体的长度
//typedef unsigned int socklen_t; 有些平台是 uint32_t
socklen_t c_addr_size;

//要发送的信息
string MSG = "Hello TCP/IP\n";
```

```
//创建服务器套节字
int create_server_socket() {
    //int socket(int domain, int type,int protocol);
    //地址族、套节字类型、协议
    /*
        domain:
            AF_INET: IPv4 地址族，表示该套接字用于 IPv4 网络协议。
            AF_INET6: IPv6 地址族，表示该套接字用于 IPv6 网络协议。
            AF_UNIX（或 AF_LOCAL）: 本地通信地址族，表示用于本地进程间通信（IPC）。
        type:
            SOCK_STREAM: 流式套接字，提供面向连接的、可靠的数据传输，通常用于 TCP。
            SOCK_DGRAM: 数据报套接字，提供无连接的数据传输，通常用于 UDP。
            SOCK_RAW: 原始套接字，提供对底层协议的访问，常用于网络层和链路层的操作。
        protocol:
            对于 SOCK_STREAM（TCP），protocol 通常设置为 0，使用默认的 TCP 协议。
            对于 SOCK_DGRAM（UDP），protocol 通常设置为 0，使用默认的 UDP 协议。
    */
    int sock = socket(PF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        perror("Socket creation failed");
        throw runtime_error("Socket creation failed");
    }
    cout << "Server socket created successfully." << endl;
    return sock;
}
```

```
//绑定服务器套节字到制定端口
void bind_server_socket(int sock, const string& port) {
    //初始化服务器地址
    memset(&s_addr, 0, sizeof(s_addr));
    //服务器地址族为IPV4
    s_addr.sin_family = AF_INET; 
    //允许通过的接口 为 INADDR_ANY(宏:0.0.0.0 -> 代表任何可用的网络接口)
    //htonl(Host TO Network Long) 将32位的主机字节序（小端） 转换成 网络字节序(大端); 一般用于IP
    s_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    //htons(Host TO Network Short) 将16位的主机字节序（小端） 转换成 网络字节序(大端); 一般用于端口
    s_addr.sin_port = htons(stoi(port));

    //int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    //套节字描述符，sockaddr指针，结构体的长度
    /*
        struct sockaddr {               //是一个通用的地址结构体，提供了统一的接口。
            unsigned short sa_family;   // 地址族
            char sa_data[14];           // 地址数据(16进制),存放协议簇(两位)、ip地址(4位)、端口号(2位)和填充信息(剩余)
        };

    */
    if (bind(sock, (struct sockaddr*)&s_addr, sizeof(s_addr)) == -1) {
        perror("Bind failed");
        close(sock);
        throw runtime_error("Bind failed");
    }

    cout << "Server socket is bound to IP: " 
         << inet_ntoa(s_addr.sin_addr) //将结构体里的地址转换为点分十进制，不安全
         << " and port: " 
         << ntohs(s_addr.sin_port) 
         << endl;
}
```

```
//开始监听
void start_listening(int sock) {
    //int listen(int sockfd, int backlog);
    //套节字类型，请求队列的大小(超过大小会连接不上)
    if (listen(sock, 5) == -1) {
        perror("Listen failed");
        close(sock);
        throw runtime_error("Listen failed");
    }
    cout << "Listening for connections..." << endl;
}
```

```
//接受连接请求
void accept_user_connection(int sock) {
    c_addr_size = sizeof(c_addr);
    //int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    //服务器的套接字描述符,客户机结构体的指针，客户机结构体的长度
    c_sock = accept(sock, (struct sockaddr*)&c_addr, &c_addr_size);

    if (c_sock == -1) {
        perror("Accept failed");
        close(sock);
        throw runtime_error("Accept failed");
    }

    cout << "Connected user IP: "
         << inet_ntoa(c_addr.sin_addr)
         << " and port: "
         << ntohs(c_addr.sin_port) << endl;
}
```

```
//发送消息
void send_message() {
    //ssize_t write(int fd, const void *buf, size_t count);
    //客户机套节字描述符，待写入数据的缓冲区指针，数据的大小
    if (write(c_sock, MSG.c_str(), MSG.size()) == -1) {
        perror("Send failed");
        close(c_sock);
        close(s_sock);
        throw runtime_error("Send failed");
    }
    cout << "Message sent successfully." << endl;
}
```

```
//关闭套节字
void close_sockets() {
    close(c_sock);
    close(s_sock);
}
```

```
int main(int argc, char *argv[]) {
    try {
        if (argc != 2) {
            cerr << "Usage: " << argv[0] << " <port>" << endl;
            return -1;
        }

        s_sock = create_server_socket();
        bind_server_socket(s_sock, argv[1]);
        start_listening(s_sock);
        accept_user_connection(s_sock);
        send_message();
        close_sockets();

    } catch (const runtime_error& e) {
        cerr << "Error: " << e.what() << endl;
        return -1;
    }

    return 0;
}


```

客户端

```
#include <iostream>
#include <string>
#include <cstring>
#include <vector>

#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <cerrno>
```

```
using namespace std;
```

```
//客户机套节字
int client_sock;
//服务器地址
struct sockaddr_in server_addr;
//接受消息的数组
vector<char> message;
//串长度
int str_len;
```

```
//创建客户端套字节，与服务端相同 
int create_client_socket() {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        perror("Socket creation failed");
        throw runtime_error("Socket creation failed");
    }
    cout << "Client socket created successfully." << endl;
    return sock;
}
```

```
//连接服务段
void connect_to_server(const string& ip, const string& port) {
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;

    //int inet_pton(int af, const char *src, void *dst);
    //地址族、ip地址字符串指针（点分十进制）、转换后的内存地址指针（存到哪里）
    //1: 表示转换成功。0: 表示提供的地址字符串格式不正确（无效的地址）。-1: 表示函数调用失败
    if (inet_pton(AF_INET, ip.c_str(), &server_addr.sin_addr) <= 0) {
        perror("Invalid address");
        throw runtime_error("Invalid address");
    }

    server_addr.sin_port = htons(stoi(port));

    if (connect(client_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("Connect failed");
        throw runtime_error("Connect failed");
    }
    cout << "Connected successfully." << endl;
}
```

```
//接受消息
void receive_message() {
    message.resize(1024);

    //ssize_t read(int fd, void *buf, size_t count);
    //message.size() - 1 指定了要读取的最大字节数
    str_len = read(client_sock, message.data(), message.size() - 1);

    if (str_len == -1) {
        perror("Read failed");
        throw runtime_error("Read failed");
    }

    message[str_len] = '\0';
}
```

```
//关闭客户端套字节
void close_socket() {
    close(client_sock);
}
```

```
int main(int argc, char* argv[]) {
    try {
        if (argc != 3) {
            cerr << "Usage: " << argv[0] << " <IP> <PORT>" << endl;
            return -1;
        }

        client_sock = create_client_socket();
        connect_to_server(argv[1], argv[2]);

        receive_message();
        cout << "Message from server: " << message.data() << endl;
        close_socket();

    } catch (const runtime_error &e) {
        cerr << "Error: " << e.what() << endl;
        return -1;
    }

    return 0;
}


```

### win版本

```
win 编译需要链接ws2_32 库，所以命令是
g++ -std=c++17 -o myprogram myprogram.cpp -lws2_32
```

```
服务端：
#include<iostream>
#include<winsock2.h>
#include<cstring>
#include<string>

using namespace std;

WSADATA wsaData;

//s:server c:client
SOCKET sSock, cSock;

SOCKADDR_IN sAddr, cAddr;

int cAddr_size;

string message = "Hello TCP/IP\n";

void create_server_socket() {
	sSock = socket(PF_INET, SOCK_STREAM, 0);
	if (sSock == INVALID_SOCKET) {
		cerr << "Server Socket Create failed" << endl;
		exit(1);
	}else {
		cout << "Server Socket is Create" << endl;
	}
}

void bind_ip_and_port(const string port) {
	memset(&sAddr, 0, sizeof(sAddr));

	sAddr.sin_family = PF_INET;
	sAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	sAddr.sin_port = htons(stoi(port));

	if (bind(sSock, (SOCKADDR*)&sAddr, sizeof(sAddr)) == SOCKET_ERROR) {
		cerr << "bind is failed" << endl;
		exit(1);
	}else{
		cout << "bind is success , allow IP :"
			<< inet_ntoa(sAddr.sin_addr)
			<< "and port :"
			<< ntohs(sAddr.sin_port) << endl;
	}

}

void listen_connect() {
	if (listen(sSock, 5) == SOCKET_ERROR) {
		cerr << "listen error" << endl;
		exit(1);
	}else {
		cout << "listening connect ...." << endl;
	}
}

void accept_client_connect() {
	cAddr_size = sizeof(cAddr);
	cSock = accept(sSock, (SOCKADDR*)&cAddr, &cAddr_size);

	if (cSock == INVALID_SOCKET) {
		cerr << "accept error" << endl;
	}else {
		cout << "accept is success , client IP :"
			<< inet_ntoa(cAddr.sin_addr)
			<< "and port :"
			<< ntohs(cAddr.sin_port) << endl;
	}
}

void send_MSG() {
	send(cSock, message.c_str(), message.size(), 0);
}

void close_socket() {
	closesocket(cSock);
	closesocket(sSock);
}

int main(int argc , char* argv[]) {
	
	if (argc != 2) {
		cerr << "Usage :" << argv[0] << "<port>" << endl;
		return -1;
	}
	//比起linux多了一个启动和关闭WSA的步骤
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
		cerr << "WSAStartup() error" << endl;
	}else {
		cout << "WinSock Start!" << endl;
	}

	create_server_socket();

	bind_ip_and_port(argv[1]);

	listen_connect();

	accept_client_connect();

	send_MSG();

	close_socket();

	WSACleanup();
	return 0;
}
```

```
接受的和linux一样，就改个别语句即可
```

## 2、回声（UDP）

server端

```
#include <iostream>
#include <string>
#include <cstring>

#include <arpa/inet.h>
#include <sys/socket.h>

#include <unistd.h>

using namespace std;

int sSock; //UDP不需要cSock

struct sockaddr_in sAddr,cAddr;

void create_server_sock(){
    sSock = socket(PF_INET,SOCK_DGRAM,0);
    if(sSock == -1){
        cerr << "server socket create failed" << endl;
        exit(1);
    }
    cout << "server socket is created" << endl;
}

void bind_socket(const string& port){
    memset(&sAddr , 0 , sizeof (sAddr));
    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sAddr.sin_port = htons(stoi(port.c_str()));
	if(bind(sSock,(struct sockaddr*)&sAddr,sizeof(sAddr)) == -1){
        cerr << "bind error" << endl;
    }
    cout << "bind success" << endl;

}

void server_start(){
    string msg(1024,'\0'),msg_send;
    socklen_t cAddr_sz;
    int str_len = 0;

    while(1){
        cAddr_sz = sizeof(cAddr);
        msg.clear();
        msg.resize(1024);
                recvfrom(sSock,
                &msg[0],//可写数组
                1024,
                0,
                (struct sockaddr*)&cAddr, 
                &cAddr_sz);

		cout << "message from client: " << msg << endl;
        cout << "Insert message (q to quite) :" << endl;
        getline(cin,msg_send);
        if(msg_send == "q") break;
        sendto(sSock,
               msg_send.c_str(),
               msg_send.size(),
               0,
               (struct sockaddr*)&cAddr, 
               cAddr_sz);
    } 
}

void close_socket(){
    close(sSock);
}

int main(int argc , char* argv[]){
    if(argc != 2){
        cerr << "Usage: " << argv[0] << " <port> " << endl;
        return -1;
    }
    create_server_sock();
    bind_socket(argv[1]);
    
    server_start();
    close_socket();

    return 0;
}

```

client端

```
#include <iostream>
#include <string>
#include <cstring>

#include <arpa/inet.h>
#include <sys/socket.h>

#include <unistd.h>

using namespace std;

int cScok;
struct sockaddr_in sAddr , cAddr;

void create_client_sock(){
    cScok = socket(PF_INET , SOCK_DGRAM , 0);
    if(cScok == -1){
        cerr << "cScok error " << endl;
        exit(1);
    }
    cout << "client socket is create" << endl;
}

void init_server(const string& ip , const string & port){
    memset(&sAddr , 0 , sizeof (sAddr));
    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = inet_addr(ip.c_str());
    sAddr.sin_port = htons(stoi(port));
}

void connect_server(){
    string msg,msg_recv(1024,'\0');
    socklen_t sAddr_sz = sizeof(sAddr);
    int str_len;


    while(1){
        cout << "Insert message (q to quit): ";
        getline(cin,msg);
        if(msg == "q" || msg == "Q") break;

        sendto(cScok , msg.c_str() , msg.size() , 0 , (struct sockaddr*)&sAddr,sAddr_sz);
        
        msg_recv.clear();
        msg_recv.resize(1024);

        str_len = recvfrom(cScok , &msg_recv[0] , msg_recv.size() , 0 , (struct sockaddr*)&sAddr,&sAddr_sz);
        
        cout << "message from server :" << msg_recv << endl;
    }
}

void close_socket(){
    close(cScok);
}

int main(int argc , char *argv[]){
    
    if(argc != 3){
        cerr << "Usage : " << argv[0] << "<ip> <port>" << endl;
        return -1;
    }

    create_client_sock();
    init_server(argv[1],argv[2]);

    connect_server();
    close_socket();

    return 0;
}
```

数据边界

```
TCP：无数据边界，一次write对应多次调用read（recv）来接受同一个数据包
UDP：有数据边界，一次send对应一次recv，一次接受一个数据包，一般缓冲区大小为64KB，比TPC大很多
不过如果数据包过大，udp也会进行分割数据包
```

已连接UDP套接字

```
可以使用connect让UDP套接字变成已连接套接字
这样不仅可以用sendto和recvfrom，还可以使用write和read
```

## 3、DNS解析

正向解析（域名 -> ip）

```
#include <iostream>
#include <cstring>
#include <string>

#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>

using namespace std;

struct hostent *host;

int main(int argc , char* argv[]){
    
    if(argc != 2){
        cerr << "Usage :" << argv[0] << "<ip addr>" << endl;
        return -1;
    }

    host = gethostbyname(argv[1]);

    if(!host) {
        cerr << "get host error" << endl;
        return -1;
    }

    cout << "Official name :" << host->h_name << endl;

    cout << "Address type : " << (host->h_addrtype == AF_INET ? "IPV4" : "IPV6") << endl;

    char **aliases = host->h_aliases;

    for(int i = 0 ; aliases[i] ; i ++){
        cout << "Aliases : " << aliases[i] << endl;
    }

    char **ipaddr = host->h_addr_list;

    for(int i = 0 ; ipaddr[i] ; i ++){
        cout << "IP Address : " << inet_ntoa(*(struct in_addr*)ipaddr[i]) << endl;
    }
    

    return 0;
}

```

反向解析（ip -> 域名）

```
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <netdb.h>
#include <arpa/inet.h>

using namespace std;

int main(int argc, char* argv[]) {
    if (argc != 2) {
        cerr << "Usage: " << argv[0] << " <ip address>" << endl;
        return 1;
    }

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = 0;
    inet_pton(AF_INET, argv[1], &addr.sin_addr);

    struct addrinfo hints, *res, *p;
    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_INET; // IPv4
    hints.ai_socktype = SOCK_STREAM;

    int status;
    if ((status = getaddrinfo(argv[1], NULL, &hints, &res)) != 0) {
        cerr << "getaddrinfo error: " << gai_strerror(status) << endl;
        return 1;
    }

    for (p = res; p != NULL; p = p->ai_next) {
        char host[NI_MAXHOST];
        int ret = getnameinfo(p->ai_addr, p->ai_addrlen, host, sizeof host, NULL, 0, NI_NAMEREQD);
        if (ret != 0) {
            cerr << "getnameinfo error: " << gai_strerror(ret) << endl;
        } else {
            cout << "Official name: " << host << endl;
        }
    }

    char ipstr[INET_ADDRSTRLEN];
    for (p = res; p != NULL; p = p->ai_next) {
        void *addr;
        struct sockaddr_in *ipv4 = (struct sockaddr_in *)p->ai_addr;
        addr = &(ipv4->sin_addr);

        inet_ntop(p->ai_family, addr, ipstr, sizeof ipstr);
        cout << "IP Address: " << ipstr << endl;
    }

    freeaddrinfo(res);

    return 0;
}

```

## 4、并发服务器(多线程 + I /O 分割)

### 多线程

fork

```
#include<unistd.h>

using namespace std;

int val1 = 10;

int main(int argc , char* argv[]){
    pid_t pid;

    int val2 = 20;

    val1++,val2 += 5;

    cout << "全局变量val1 : " << val1 << endl;
    cout << "局部变量val2 : " << val2 << endl;

    pid = fork();

    if(pid == 0){ // 如果是子进程
        cout << "全局变量val1 : " << val1 << endl;                                                                                                                                     
        cout << "局部变量val2 : " << val2 << endl;
        val1 += 2;
        val2 += 2;
        cout << "val1 += 2 , val2 += 2" << endl;
    }else{//否则是父进程
        cout << "全局变量val1 : " << val1 << endl;                                                                                                                                     
        cout << "局部变量val2 : " << val2 << endl;
        val1 -= 2;
        val2 -= 2;
        cout << "val1 -= 2 , val2 -= 2" << endl;
    }
    
    if(pid == 0){
        cout << "This is Child Proc: " << val1 << "," << val2 << endl;
    }else{
        cout << "This is Father Proc" << val1 << "," << val2 << endl;
    }


    return 0;
}

```

在这个程序中不难看出

```
在调用fork（）函数之后，子进程获得了和父进程一模一样的内存空间，并且互相独立，修改变量不会影响对方
```

#### zombie进程

```
root@ubuntu:/home/alexqfmm/Codes/multithreading# cat zombie.cpp                            │alexqfmm@ubuntu:~/Codes$ ps au|grep 5036
#include<iostream>                                                                         │alexqfmm    5036  0.0  0.0      0   
#include<unistd.h>                                                                         │alexqfmm    5038  0.0  0.0  12000   
                                                                                           │alexqfmm@ubuntu:~/Codes$ 
using namespace std;                                                                       │
                                                                                           │
int main(){                                                                                │
    pid_t pid = fork();                                                                    │
                                                                                           │
    if(pid == 0){                                                                          │
        puts("Hi , I'm Zombie Process!");                                                  │
    }else{                                                                                 │
        cout << "Child Process ID : " << pid << endl;                                      │
        sleep(30);                                                                         │
    }                                                                                      │
                                                                                           │
    if(pid == 0){                                                                          │
        puts("Child Process is Close");                                                    │
    }else{                                                                                 │
        puts("Father Process is close");                                                   │
    }                                                                                      │
                                                                                           │
    return 0;                                                                              │
}                                                                                          │
```

#### 使用waitpid防止僵尸进程

```
#include <iostream>
#include <unistd.h>
#include <sys/wait.h>

using namespace std;

int main(){

    int st;
    pid_t pid = fork();

    if(pid == 0){
        sleep(15);
        return 24;
    }else{
        //WNOHANG 是一个选项，可以作为 waitpid() 的第三个参数传递。它的作用是让 waitpid() 非阻塞地检查子进程的状态
        //Wait No Hang
        while(!waitpid(-1,&st,WNOHANG)){
            sleep(3);
            puts("sleep 3sec");
        }

        //WIFEXITED(status) 是一个宏，用于判断子进程是否正常退出
        //Wait If Exited
        if(WIFEXITED(st)){
            //WEXITSTATUS(status) 用于获取子进程的退出状态，即返回的退出码
            //Wait Exit Status
            cout << "Child send : " << WEXITSTATUS(st) << endl;
        }
    }

    return 0;
}
```

#### 信号

```
include <iostream>
#include <unistd.h>
#include <signal.h>

using namespace std;

typedef struct sigaction SIG;

void timeout(int sig){
    if(sig == SIGALRM) puts("Time Out！");
    alarm(2);
}

void bind_sig( SIG *sig, void (*fun)(int), int type){
    sig->sa_handler = fun;		//将timeout绑定到act上

    sigemptyset(&sig->sa_mask);	// 清空信号屏蔽字
    
    sig->sa_flags = 0;			// 设置信号处理标志
    
    sigaction(type , sig , 0);	// 使用sigaction设置SIGALRM信号的处理函数
}
int main(){

    
    struct sigaction act;
    
    bind_sig(&act , timeout , SIGALRM);

    alarm(2);

    for(int i = 0 ; i < 3 ; i ++){
        puts("wait..");
        sleep(30);
    }

    return 0;
}

```

​                                                                

| 信号    | 描述                | 说明                                                         |
| ------- | ------------------- | ------------------------------------------------------------ |
| SIGALRM | 定时器到期信号      | 由 alarm() 或 setitimer() 设置的定时器到期时发送。通常用于定时任务。 |
| SIGINT  | 中断信号            | 通常由 CTRL + C 触发。默认情况下，SIGINT 会终止进程。        |
| SIGTERM | 终止信号            | 请求进程终止。可以被捕获、阻塞或忽略。通常用于优雅地终止进程。 |
| SIGKILL | 强制终止信号        | 强制终止进程，不能被捕获、阻塞或忽略。用于立即停止进程。     |
| SIGSTOP | 暂停信号            | 暂停进程的执行，不能被捕获、阻塞或忽略。通常用于调试工具（如 gdb）中。 |
| SIGCONT | 继续信号            | 恢复被 SIGSTOP 暂停的进程。                                  |
| SIGQUIT | 退出信号            | 类似于 SIGINT，但同时会产生核心转储（core dump），用于调试。 |
| SIGSEGV | 段错误信号          | 进程试图访问无效的内存地址时发送。通常是程序的错误。         |
| SIGPIPE | 管道破裂信号        | 进程试图向已经关闭的管道写数据时发送。                       |
| SIGCHLD | 子进程状态变化信号  | 子进程终止或停止时，父进程会收到这个信号。常用于处理僵尸进程。 |
| SIGUSR1 | 用户自定义信号（1） | 可供用户自定义用途。                                         |
| SIGUSR2 | 用户自定义信号（2） | 可供用户自定义用途                                           |

####  综合

```
#include <iostream>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

using namespace std;

struct sigaction act;//信号

void listen_childproc(int sig){//信号处理
    int st;
    pid_t id = waitpid(-1,&st,WNOHANG);
    if(WIFEXITED(st)){
        cout << "Remove proc id : " << id << endl;
        cout << "Child send :" << WEXITSTATUS(st) << endl;
    }
}

void bind_signal(){//绑定信号
    
    act.sa_handler = listen_childproc;

    sigemptyset(&act.sa_mask);
    
    act.sa_flags = 0;
    
    sigaction(SIGCHLD, &act , 0);
}

int main(){

    bind_signal();
    
    pid_t pid = fork();

    if(pid == 0){

        puts("Hello , I‘m Zombie");
        sleep(15);
        exit(24);

    }else{

        cout << "Child Proc id : " << pid << endl;
        pid = fork();//创建新的子进程
        
        if(pid == 0){
        
            puts("HI,I'm Zombie2");
            sleep(10);
            exit(12);

        }else{
            cout << "Child Proc id : " << pid << endl;
            for(int i = 0 ; i < 5 ; i ++){
                puts("wait...");
                sleep(5);
            }
        }   
    }

    return 0;
}


```

### 何为I/O分割：

```
客户端 I/O 分割：

子进程负责发送数据。
父进程负责接收数据。
服务器端 I/O 分割：

每个客户端连接创建一个子进程，子进程负责处理该客户端的所有读写操作。
父进程继续接收新的客户端连接。
优点
提高并发处理能力：通过分离读写操作或每个客户端连接的处理，系统可以更有效地管理多个并发连接。
简化代码逻辑：将发送和接收操作分开，使代码更清晰，易于维护。
注意事项
进程间通信：在客户端和服务器端之间，需要确保数据的一致性和同步。
资源管理：正确关闭不再使用的文件描述符和套接字，避免资源泄漏。
错误处理：要处理可能出现的各种错误情况，如 fork 失败、读写错误等。
I/O 分割是一种有效的并发处理策略，适用于高负载的应用场景，无论是客户端还是服务器端都可以从中受益。
```

#### 管道

```
#include <iostream>
#include <unistd.h>

using namespace std;

int main(){
	//fds1[0] 是 fds1 的读端，fds1[1] 是 fds1 的写端
    int fds1[2] , fds2[2];
    pipe(fds1);
    pipe(fds2);

    string msg1 = "Who are you?";		// 从子进程发送给父进程的消息
    string msg2 = "I'm your Father";	// 从父进程发送给子进程的消息
    string tmp(1024,'\0');				// 用于存储从管道读取的数据
    pid_t pid = fork();

    if(pid == 0){
        write(fds1[1],msg1.c_str(),msg1.size());
        read(fds2[0],&tmp[0],1024);
        cout << "Child Proc output: " << tmp << endl;
    }else{
        read(fds1[0],&tmp[0],1024);                                                                                                                                                 
        cout << "Parent Proc output: " << tmp << endl; 
        write(fds2[1],msg2.c_str(),msg2.size());
        sleep(3);	// 确保子进程有时间读取数据
    }

    return 0;
}
```

用管道在服务端添加日志

```
在进入连接前：
if(pid == 0){//记录传输日志
        ofstream file("log.txt",ios::app);
        int str_len;
        char msg[1024];
        
        if(file.is_open()){

            while((str_len = read(fds[0], msg ,sizeof(msg))) > 0){
                cout << " log is add " << msg << endl; 
                file.write(msg , str_len);
                file << endl;
            }

        }

        file.close();
        return 0;
    }
```



```
连接后进行传输
void work(){
    close(sSock);//关闭子进程中的服务器监听，此时父进程的服务器监听依旧在执行，对于子进程而言，这个已经没有用了
    int str_len;
    while((str_len = read(cSock , buffer , BUFFERSIZE)) != 0){
        write(cSock , buffer , str_len);
        write(fds[1], buffer , str_len);//添加管道传输
    }
    close(cSock);
    puts("client disconnect");
}

```



### 实现

server端

```
#include <iostream>
#include <cstring>
#include <fstream>
#include <string>

#include <unistd.h>
#include <sys/stat.h> // 用于创建目录

#include <sys/wait.h>
#include <sys/socket.h>
#include <signal.h>

#include <arpa/inet.h>

#define BUFFERSIZE 1024

using namespace std;

typedef struct sigaction SIG;

int sSock, cSock;
struct sockaddr_in sAddr, cAddr;
socklen_t adr_sz;
char buffer[BUFFERSIZE];
int fds[2];

void listen_child(int sig)
{
    pid_t id;
    int st;
    id = waitpid(-1, &st, WNOHANG);
    cout << "removed child , Porc : " << id << endl;
}

void bind_sig(SIG *sig, void (*fun)(int), int type)
{
    sig->sa_handler = fun;
    sigemptyset(&sig->sa_mask);
    sig->sa_flags = 0;
    sigaction(type, sig, 0);
}

void create_server_socket()
{
    sSock = socket(PF_INET, SOCK_STREAM, 0);
    if (sSock == -1)
    {
        cerr << "server socket create failed" << endl;
        exit(1);
    }
    cout << "server socket is create" << endl;
}

void bind_port(const string &port)
{

    memset(&sAddr, 0, sizeof(sAddr));

    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sAddr.sin_port = htons(stoi(port));

    if (bind(sSock, (struct sockaddr *)&sAddr, sizeof(sAddr)) == -1)
    {
        cerr << "bind error" << endl;
        exit(1);
    }
    cout << " success bind " << endl;
}

void start_listen()
{
    if (listen(sSock, 5) == -1)
    {
        cerr << "listen error" << endl;
        exit(1);
    }
    cout << "listening......" << endl;
}

bool connect_client()
{
    adr_sz = sizeof(cAddr);

    cSock = accept(sSock, (struct sockaddr *)&cAddr, &adr_sz);

    return cSock != -1;
}

void write_log(const char *msg)
{
    mkdir("log", 0755);

    string filename = "log/server_log.txt";
    ofstream file(filename, ios::app);

    if (!file.is_open())
    {
        cerr << "Failed to open log file" << endl;
        exit(1);
    }

    time_t now = time(0);
    char *dt = ctime(&now);
    dt[strlen(dt) - 1] = '\0';
    file << "[ " << dt << " ] : " << msg << endl;

    file.close();
}

void log_handler()
{
    int str_len;
    char msg[1024];

    while (true)
    {
        str_len = read(fds[0], msg, sizeof(msg));
        if (str_len > 0)
        {
            msg[str_len] = '\0'; // 确保字符串结束
            write_log(msg);
        }
        else if (str_len == 0)
        {
            break; // 管道关闭
        }
        else
        {
            cerr << "Error reading from pipe" << endl;
            break;
        }
    }
}

void work()
{
    close(sSock);//子进程不需要父进程部分
    int str_len;
    char buffer[BUFFERSIZE];

    while ((str_len = read(cSock, buffer, BUFFERSIZE)) > 0)
    {
        write(cSock, buffer, str_len);  // 回传给客户端
        write(fds[1], buffer, str_len); // 写入日志管道
    }

    close(cSock);//传输完毕，可以关闭子进程了
    puts("client disconnect");
}

void server_start()
{
    // 创建管道
    if (pipe(fds) == -1)
    {
        cerr << "Failed to create pipe" << endl;
        exit(1);
    }

    pid_t log_pid = fork(); // 创建日志进程
    if (log_pid == 0)
    {
        close(fds[1]); // 不需要写端，关闭写端
        log_handler(); // 启动日志处理(服务器日志)
        exit(0);
    }
    else if (log_pid < 0)
    {
        cerr << "Failed to fork log process" << endl;
        exit(1);
    }

    while (1)
    {
        if (connect_client())
        {
            puts("A new Client is connect");
            pid_t work_pid = fork(); // 处理并发

            if (work_pid == -1)
            {
                cerr << "Failed to fork work process" << endl;
                continue;
            }
            else if (work_pid == 0) // 子进程处理客户端工作
            {
                work();
                exit(0);
            }
            else
            {
                close(cSock); // 父进程专门监听
            }
        }
        else
        {
            cerr << "Failed to connect client" << endl;
            continue;
        }
    }
}

int main(int argc, char *argv[])
{

    if (argc != 2)
    {
        cerr << "Usage: " << argv[0] << " <port> " << endl;
        exit(1);
    }

    SIG child_is_live;
    bind_sig(&child_is_live, listen_child, SIGCHLD);

    create_server_socket();

    bind_port(argv[1]);

    start_listen();

    server_start();

    close(sSock);

    return 0;
}

```

客户端

```
#include <iostream>
#include <cstring>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/socket.h>

using namespace std;

struct sockaddr_in sAddr , cAddr;
int cSock;
socklen_t adr_sz;

void create_client_socket(){
    cSock = socket(PF_INET , SOCK_STREAM , 0);
    if(cSock == -1){
        cerr << "client socket create failed" << endl;
        exit(1);
    }
    cout << "client socket is create" << endl;
}

void init_sAddr(const string& ip , const string& port){
    memset(&sAddr , 0 , sizeof (sAddr));

    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = inet_addr(ip.c_str());
    sAddr.sin_port = htons(stoi(port));
}

void connect_server(){
    if(connect(cSock , (struct sockaddr *)&sAddr , sizeof(sAddr)) == -1){
        cerr << "connect error" <<endl;
        exit(1);
    }
    cout << "connect success" << endl;
}

void write_msg(){
    int str_len = 0;                                                                                                                                           
    string msg;
    while(1){
        cout << "Insert Message(q to quite) : ";
        cout.flush();
        char buffer[1024];
        getline(cin,msg);
        if(msg == "q"){
            shutdown(cSock , SHUT_WR);
            return;
        } 
        write(cSock , msg.c_str() , msg.size());
    }
}

void read_msg(){
    int str_len = 0;
    char buffer[1024];

    while(1){
        str_len = read(cSock , buffer , sizeof(buffer) - 1);
        
        if(str_len == 0){
            cout << "Server is closed " << endl;
            return;
        }

        if(str_len < 0){
            cerr << "read error" << endl;
            exit(1);
        }
    
        buffer[str_len] = '\0';
        cout << "Message from Server :"  << buffer << endl; 
    }
}

int main(int argc ,char * argv[]){
    
    if(argc != 3){
        cerr << "Usage : " << argv[0] << "<IP Address> <Port>" << endl;
        exit(1);
    }

    create_client_socket();
    init_sAddr(argv[1],argv[2]);
    connect_server();
    
    pid_t pid = fork();

    //I/O分割提高效率
    if(pid == 0){//子进程写
        write_msg();
    }else{//父进程读
        read_msg();
    }


    close(cSock);
    return 0;
}
```

## 5、并发服务器（多线程+ I /O复用）

### 何为IO复用？

```
服务器必须确认有无举手客户端，同样，进程需要确认举手的套接字，并通过举手的套接字接受数据
```

### Select监视事件（event）

```
#include <iostream>
#include <unistd.h>
#include <sys/time.h>
#include <sys/select.h>

using namespace std;

int main() {
    fd_set reads, tmps; // 定义文件描述符集合
    int res, str_len; // res用于存储select的返回值，str_len用于读取的数据长度

    char buf[1024]; // 缓存区，存储读取的数据
    struct timeval timeout; // 定义超时时间

    FD_ZERO(&reads); // 初始化文件描述符集合
    FD_SET(0, &reads); // 将标准输入（文件描述符0）添加到集合中

    while (1) {
        tmps = reads; // 每次循环重置tmps为reads
        timeout.tv_sec = 5; // 设置超时时间为5秒
        timeout.tv_usec = 0; // 微秒部分为0

        // 调用select函数，监视文件描述符
        res = select(1, &tmps, 0, 0, &timeout);

        if (res == -1) {
            puts("select error"); // 处理select调用的错误
            break;
        } else if (res == 0) {
            puts("Time Out !"); // 超时处理
        } else {
            if (FD_ISSET(0, &tmps)) { // 检查标准输入是否可读
                str_len = read(0, buf, 1024); 
                buf[str_len] = '\0'; 
                puts("message from console :");
                cout << buf << endl; 
            }
        }
    }

    return 0;
}
```

```
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

```
nfds: 最大的文件描述符值加1。在该值之下的所有文件描述符都将被监视。
readfds: 指向一个文件描述符集合的指针，表示要监视的可读文件描述符。
writefds: 指向一个文件描述符集合的指针，表示要监视的可写文件描述符。
exceptfds: 指向一个文件描述符集合的指针，表示要监视的异常条件的文件描述符。
timeout: 指向 timeval 结构的指针，表示最大等待时间。如果为 NULL，select 将一直等待，直到有事件发生。
```

使用步骤

```
初始化文件描述符集合: 
	使用 FD_ZERO 初始化集合，使用 FD_SET 将文件描述符添加到集合中。
调用 select: 
	将文件描述符集合和超时参数传递给 select。

检查返回值:
	返回 -1: 表示出现错误。
	返回 0: 表示超时。
	返回大于0: 表示有可读、可写或异常事件发生。
	使用 FD_ISSET 检查具体的文件描述符: 使用 FD_ISSET 来检查哪个文件描述符发生了事件。
```

### 实现

```
#include <iostream>
#include <cstring>
#include <string>

#include <unistd.h>
#include <arpa/inet.h>

#include <sys/socket.h>
#include <sys/time.h>
#include <sys/select.h>

using namespace std;

int sSock,cSock;
struct sockaddr_in sAddr , cAddr;
socklen_t addr_sz;

struct timeval timeout;
fd_set reads, reads_bck;
int fd_max , fd_num;

void create_server_socket(){
    sSock = socket(PF_INET , SOCK_STREAM , 0);
    if(sSock == -1){
        cerr << "server socket create is faild" << endl;
        exit(1);
    }
    cout << "server socket is create" << endl;
}

void bind_port(const string& port){
    
    memset(&sAddr , 0 , sizeof(sAddr));

    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sAddr.sin_port = htons(stoi(port));

    if(bind(sSock , (const sockaddr*)&sAddr , sizeof(sAddr)) == -1){
        cerr << "bind error" << endl;
        exit(1);
    }
    cout << "success bind port" << endl;
}

void start_listen(){
    if(listen(sSock , 5) == -1){
        cerr << "listen error" << endl;
        exit(1);
    }
    cout << "start listen......." << endl;
}

void connect_client(){
    addr_sz = sizeof(cAddr);
    cSock = accept(sSock , (struct sockaddr*)&cAddr , &addr_sz);

    FD_SET(cSock , &reads); //将套接字 cSock 添加到一个文件描述符集合 reads 中
    fd_max = max(fd_max,cSock);//fd_max 必须时刻是最大的

    cout << "connect client : " << cSock << endl; 
}

void work(int client_sock){
    char buffer[1024];
    int len = read(client_sock ,buffer , sizeof(buffer) - 1);
    
    if(len == 0){
        FD_CLR(client_sock,&reads);//客户端断开连接，移除集合中的它的套节字
        close(client_sock);
        cout << "closed Client : " << client_sock << endl;
    }else{
        buffer[len] = '\0';
        write(client_sock , buffer , len);
    }
}

void server_start(){

    FD_ZERO(&reads);//初始化文件描述集合 reads，全部置为0
    FD_SET(sSock , &reads);//将套接字 sSock 添加到一个文件描述符集合 reads 中

    fd_max = sSock;//fd_max代表所有小于他的都将被监视

    while(1){
        reads_bck = reads;
        timeout.tv_sec = 5;
        timeout.tv_usec = 5000;

        fd_num = select(fd_max + 1 , &reads_bck , 0 , 0 , &timeout);
        
        if(fd_num == -1) break;
        if(fd_num ==  0) continue;

        for(int i = 0 ; i < fd_max + 1 ; i ++){//边历所有被监视的套节字
            //这里检查文件描述符 i 是否在文件描述符集合 reads_bck 中，如果存在，意味着该文件描述符有活动（如可读事件）
            if(FD_ISSET(i , &reads_bck)){

                if(i == sSock){
                    connect_client();
                }else{
                    work(i);
                }

            }
        }

    }
}

int main(int argc,char * argv[]){
    
    if(argc != 2){
        cerr << "Usage : " << argv[0] << "<port>" << endl;
        exit(1);
    }

    create_server_socket();
    bind_port(argv[1]);
    start_listen();
    server_start();
    close(sSock);
    return 0;
}
```

## 多样IO函数

| 函数     | 主要用途                   | 优点                                 | 缺点                           | 适用场景                                 |
| -------- | -------------------------- | ------------------------------------ | ------------------------------ | ---------------------------------------- |
| `read`   | 读取文件或套接字中的数据   | 通用、简单、适用于文件或网络I/O      | 不专门为网络设计，缺少额外选项 | 通用I/O操作，文件和套接字都可以使用      |
| `write`  | 向文件或套接字写入数据     | 通用、简单、适用于文件或网络I/O      | 不专门为网络设计，缺少额外选项 | 通用I/O操作，文件和套接字都可以使用      |
| `send`   | 发送数据到套接字           | 网络优化、提供控制标志位             | 只能用于套接字                 | 网络编程，尤其需要精细控制发送行为时     |
| `recv`   | 从套接字接收数据           | 网络优化、提供控制标志位             | 只能用于套接字                 | 网络编程，尤其需要精细控制接收行为时     |
| `readv`  | 从套接字或文件分散读取数据 | 提高效率、减少系统调用、减少内存拷贝 | 使用多个缓冲区增加代码复杂度   | 需要读取分散数据，且希望优化性能的场景   |
| `writev` | 向套接字或文件聚集写入数据 | 提高效率、减少系统调用、减少内存拷贝 | 使用多个缓冲区增加代码复杂度   | 需要写入多个数据块，且希望优化性能的场景 |

## MSG_OOB与TCP紧急模式

### 1. **MSG_OOB (Out-of-Band Data)**

- **概念**：

  - `MSG_OOB` 是用于 `send()` 和 `recv()` 函数的一个标志，表示处理“带外数据”（Out-of-Band Data）。
  - 带外数据是指一些特殊的紧急数据，它可以让发送方在已经发送的常规数据流中插入一些紧急信息，接收方可以优先处理这些紧急信息。

- **使用**：

  - 当使用 

    ```
    send()
    ```

     时，可以通过传递 

    ```
    MSG_OOB
    ```

     标志来将紧急数据发送给对方：

    ```
    send(sockfd, buffer, length, MSG_OOB);
    ```

  - 当使用 

    ```
    recv()
    ```

     时，也可以使用 

    ```
    MSG_OOB
    ```

     标志来读取紧急数据：

    ```
    recv(sockfd, buffer, length, MSG_OOB);
    ```

- **特点**：

  - 紧急数据并不会破坏正常的 TCP 数据流，它可以和普通数据同时发送，但接收方可以选择优先处理紧急数据。
  - 紧急数据通常只有一个字节，适合传递一些需要快速响应的控制信息。

- **应用场景**：

  - `MSG_OOB` 常用于传递需要快速处理的**小型**控制数据，如**信号、中断命令**等。例如，在远程控制软件中，用户按下的某些“紧急”键可以通过 `MSG_OOB` 来传输，以便接收方能优先处理。

- **限制**：

  - `MSG_OOB` 只能传递非常短的数据（通常只有一个字节），如果传输的紧急数据量较大，不建议使用。

### 2. **TCP 紧急模式（TCP Urgent Mode）**

- **概念**：
  - TCP 紧急模式是 TCP 协议提供的一种机制，用来发送紧急数据。紧急模式依赖于 TCP 标头中的**紧急指针（Urgent Pointer）**。
  - 当 TCP 发送端标记某些数据为紧急数据时，它会设置 TCP 报头中的 URG 标志，并设置一个指针指向紧急数据在流中的位置。
  - 接收端可以通过读取 URG 标志和紧急指针的位置，优先处理紧急数据。
- **工作机制**：
  - 紧急数据是在数据流中插入的，属于内联数据（In-line Data），这意味着它与普通数据共享同一个数据流。
  - 紧急指针不会中断数据流，而只是指出流中的哪些字节是紧急的。接收方可以选择立即读取紧急数据或者继续处理普通数据。
  - 发送方和接收方之间的紧急数据处理是“协作式”的，发送方告诉接收方紧急数据的位置，但接收方可以选择何时处理它。
- **使用紧急指针（Urgent Pointer）**：
  - 紧急指针告诉接收方，数据流中的某个位置及之后的数据是紧急的。尽管如此，接收方可以选择继续处理非紧急数据，而不是立即响应紧急数据。
  - 通常，接收端的 TCP/IP 堆栈会优先处理紧急数据。
- **应用场景**：
  - 紧急模式主要用于需要在数据流中插入高优先级控制数据的场合，比如**终止会话、流量控制、特殊中断**等。

### 3. **MSG_OOB 与 TCP 紧急模式的关系**

- **MSG_OOB** 实际上是应用层对 TCP 紧急模式的**接口或实现**。TCP 紧急模式由 TCP 层协议提供，而 `MSG_OOB` 是使用该模式的一种方法。
- 在发送和接收紧急数据时，`MSG_OOB` 标志的作用就是标记和处理这些紧急数据，它是对 TCP 紧急数据的抽象和封装。

### 4. **优缺点**

- **优点**：
  - **优先级高**：紧急模式和 `MSG_OOB` 允许发送方传递需要接收方优先处理的高优先级数据，减少延迟。
  - **内联数据传输**：紧急数据不会打断常规数据流，可以在流式数据的基础上同时发送紧急信息。
- **缺点**：
  - **紧急数据有限**：由于紧急数据通常只有一个字节，并且**应用层只能通过 `MSG_OOB` 处理**，数据量有限，不适合传输大量紧急数据。
  - **兼容性问题**：并非所有系统和网络栈都完全支持或使用 TCP 紧急模式，因此在跨平台或复杂网络环境中，依赖紧急模式可能导致兼容性问题。

### 总结

- **MSG_OOB** 是应用层用于发送和接收紧急数据的标志，依赖于 TCP 紧急模式的实现。
- **TCP 紧急模式** 使用紧急指针标记紧急数据的位置，允许接收方优先处理这些数据。
- 它们适用于需要传递优先级较高的小型数据的场景，但由于紧急数据量限制和兼容性问题，**不建议用于传输大量或持续的数据**。

### 实现

server端

```
void work(int client_sock) {
    char buffer[1024];
    int len;

    // 尝试接收紧急数据
    len = recv(client_sock, buffer, sizeof(buffer) - 1, MSG_OOB);
    if (len > 0) {
        buffer[len] = '\0';
        cout << "Received OOB message: " << buffer << endl;
        FD_CLR(client_sock, &reads); // 客户端断开连接，移除集合中的它的套接字
        close(client_sock);
        cout << "Closed Client emergency: " << client_sock << endl;
        return; // 处理完紧急数据后返回
    }

    // 如果没有紧急数据，再接收常规数据
    len = read(client_sock, buffer, sizeof(buffer) - 1);
    if (len == 0) {
        FD_CLR(client_sock, &reads); // 客户端断开连接，移除集合中的它的套接字
        close(client_sock);
        cout << "Closed Client: " << client_sock << endl;
    } else {
        buffer[len] = '\0';
        cout << "Message from Server: " << buffer << endl;
    }
}
```

client端

```

void write_msg(){
    int str_len = 0;                                                                                                                                           
    string msg;
    while(1){
        cout << "Insert Message(q to quite),! for OOB message : ";
        cout.flush();
        char buffer[1024];
        getline(cin,msg);
        
        if(msg == "q"){
            shutdown(cSock , SHUT_WR);
            return;
        }else if(msg == "!"){
            const char* oob_msg = "!";

            if(send(cSock,oob_msg,strlen(oob_msg),MSG_OOB) == -1){
                cerr << "send OOB message failed" << endl;
            }else{
                cout << "send OOB message: " << oob_msg << endl;
            }
        }

        write(cSock , msg.c_str() , msg.size());
    }
}
```

## 多播与广播

多播与广播都是通过**UDP**协议传递数据包

都是一次性向多个主机发送数据，但多播可以跨越不同的网络，只要加入**多播组**就能接受数据

但广播**只能向同一网络**中的主机传输数据

### 多播实现

sender端

```
#include <iostream>
#include <string>
#include <cstring>
#include <fstream>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define TTL 64

using namespace std;

void error_handler(const string& msg) {
    cerr << msg << endl;
    exit(1);
}

int send_sock;
struct sockaddr_in mAddr; // 多播组IP地址
int time_live = TTL;

void create_send_socket() {
    send_sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (send_sock == -1) {
        error_handler("send socket create error");
    }
    cout << "send socket is created" << endl;
}

void init_mAddr(const string& ip, const string& port) {
    memset(&mAddr, 0, sizeof(mAddr));
    mAddr.sin_family = PF_INET;
    mAddr.sin_addr.s_addr = inet_addr(ip.c_str());
    mAddr.sin_port = htons(stoi(port));
}

void send_file(const string& filename) {
    ifstream file(filename, ios::binary);
    char buffer[1024];

    if (file.is_open()) {
        while (file.read(buffer, sizeof(buffer))) {
            sendto(send_sock, buffer, file.gcount(), 0, (struct sockaddr*)&mAddr, sizeof(mAddr));
        }

        // 处理文件剩余的部分
        if (file.gcount() > 0) {
            sendto(send_sock, buffer, file.gcount(), 0, (struct sockaddr*)&mAddr, sizeof(mAddr));
        }

        file.close();
    } else {
        error_handler("Failed to open file");
    }
    //发送结束标记
    const char* sig= "EOF";
    sendto(send_sock , sig , strlen(sig) , 0, (struct sockaddr*)&mAddr, sizeof(mAddr));

}


int main(int argc, char* argv[]) {
    if (argc != 3) {
        error_handler("Usage: " + string(argv[0]) + " <Group IP> <port>");
    }

    create_send_socket();
    init_mAddr(argv[1], argv[2]);

    if (setsockopt(send_sock, IPPROTO_IP, IP_MULTICAST_TTL, (void*)&time_live, sizeof(time_live)) < 0) {
        error_handler("setsockopt error");
    }

    send_file("test.txt");
    close(send_sock);
    return 0;
}
```

recv端

```
#include <iostream>
#include <string>
#include <cstring>
#include <fstream>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

using namespace std;

void error_handler(const string& msg) {
    cerr << msg << endl;
    exit(1);
}

int recv_sock;
struct sockaddr_in sAddr;
struct ip_mreq join_addr; // 加入组播网络

void join_group(const string& ip) {
    join_addr.imr_multiaddr.s_addr = inet_addr(ip.c_str()); // 组播地址
    join_addr.imr_interface.s_addr = htonl(INADDR_ANY); // 使用所有接口

    if (setsockopt(recv_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void*)&join_addr, sizeof(join_addr)) < 0) {
        error_handler("setsockopt error");
    }
}

void recv_file(const string& filename) {
    ofstream file(filename, ios::binary | ios::app);
    char buffer[1024];

    cout << "Receiving file..." << endl;
    int cnt = 0;
    while (true) {
        int str_len = recvfrom(recv_sock, buffer, sizeof(buffer) - 1, 0, nullptr, 0);
        if (str_len < 0) {
            cerr << "recvfrom error" << endl;
            break; // 接收错误，退出循环
        }

        cout << str_len << endl;
        if (str_len == 0) {
            break; // 没有数据接收，退出循环
        }

        if (strncmp(buffer, "EOF", 3) == 0 && str_len == 3) {
            cout << "End of file signal received." << endl;
            break; // 收到结束信号，退出循环                                
        }

        // 写入文件
        file.write(buffer, str_len);
        cout << "file add cnt :" << ++cnt << endl;
    }

    cout << "File received successfully!" << endl;
    file.close();
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        error_handler("Usage: " + string(argv[0]) + " <Group IP> <port>");
    }

    recv_sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (recv_sock < 0) {
        error_handler("socket creation error");
    }

    memset(&sAddr, 0, sizeof(sAddr));
    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = htonl(INADDR_ANY); // 绑定到所有可用接口
    sAddr.sin_port = htons(stoi(argv[2]));

    if (bind(recv_sock, (struct sockaddr *)&sAddr, sizeof(sAddr)) == -1) {
        error_handler("bind error");
    }

    join_group(argv[1]);
    recv_file("test.txt");
    close(recv_sock);
    return 0;
}
```

PS：多播地址 即 D类ip地址，范围是从 `224.0.0.0` 到 `239.255.255.255` ， 端口一般用9190（不是一定）

### 广播实现

send端

```
只需要把
int time_live = TTL 
改成
int so_brd = 1
```

recv端

```
没有入组了，且只需要端口号就行
```

PS ： 广播地址 即 网络号与子网掩码按位与 ， 主机号全置为1的 ip 地址， 端口一般用 9190（不是一定）

## epoll

epoll优化了select的缺陷

```
无需循环监视所有文件描述符

调用对应于select函数的epoll_wait函数无需每次都传递监视对象信息
```

但是select兼容性好，epoll仅在特定环境使用

### 实现

server端

```
#include <iostream>
#include <cstring>
#include <string>
#include <unistd.h>

#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/epoll.h>

#define MAX_EVENTS 10   //最大事件数，指一次性可以接受多少事件
using namespace std;

int sSock , cSock;
struct sockaddr_in sAddr , cAddr;
socklen_t cAddr_sz;

struct epoll_event  event ,ep_event[MAX_EVENTS]; ;
int epfd,event_cnt;

void error_handler(const string& msg){
    cerr << msg << ":" << strerror(errno)  << endl;
    exit(1);
}

void epoll_add(int type , int sock){
    event.events = type; //监听读事件 OUT 就是写
    event.data.fd = sock; //将服务器套接字 sSock 的文件描述符赋值给 event 结构体中的 data 成员
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &event) == -1) {
        error_handler("epoll_ctl() error");
    }
}

void server_prepare(const string& port){
    sSock = socket(PF_INET , SOCK_STREAM , 0);

    epfd = epoll_create1(0);
    if(epfd == -1) error_handler("epoll create() error");  
    epoll_add(EPOLLIN , sSock);

    memset(&sAddr , 0 , sizeof(sAddr));
    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sAddr.sin_port = htons(stoi(port));

    
    if(bind(sSock , (struct sockaddr *)&sAddr , sizeof(sAddr)) == -1) error_handler("bind() error");
    
    cout << "start listen..." << endl;
    if(listen(sSock , 5) == -1) error_handler("listen() error");
    
}

void connect_client(){
    cAddr_sz = sizeof(cAddr);
    cSock = accept(sSock , (struct sockaddr *)&cAddr , &cAddr_sz);
    epoll_add(EPOLLIN , cSock);
    cout << "client is connect : " << cSock << endl;
}

void work(int client_sock){

    char buffer[1024];
    int len = read(client_sock, buffer , sizeof(buffer));
    
    if(len == 0){//关闭链接
        epoll_ctl(epfd , EPOLL_CTL_DEL , client_sock , nullptr);
        close(client_sock);
        cout << "close client : " << client_sock << endl;
    }else{
        write(client_sock, buffer , len);
    }
}

void server_start(){

    while(1){
        event_cnt = epoll_wait(epfd , ep_event , MAX_EVENTS , -1);
        if(event_cnt == -1){
            puts("event_wait() error");
            break;
        }

        for(int i = 0 ; i < event_cnt ; i ++){
            if(ep_event[i].data.fd == sSock){//监听到连接请求了
                connect_client();
            }else{
                work(ep_event[i].data.fd);
            }
        }

    }
}

int main(int argc , char* argv[]){

    if(argc != 2)  error_handler("Usage" + string(argv[0]) + "<port>");
    cout << "server is prepare..." << endl;
    server_prepare(argv[1]);  

    cout << "server is start!" << endl;
    server_start();

    cout << "server is closed" << endl;
    close(sSock);
    close(epfd);
    return 0;
}
```

### 条件触发与边缘触发

条件触发中只要 **输入缓冲有数据** 就会一直通知该事件

边缘触发中 **输入缓冲收到数据仅通知一次**，即使还有数据，也不会再通知事件了

epoll默认和select都是 **条件触发**



在条件触发中，每次客户端发送数据包到服务端，服务端都会为其注册一次事件，并多次调用epoll_wait,只要数据未被完全读取，就会一直被触发

而边缘触发，只会在第一次发送数据包注册一次事件，调用一次epoll_wait，如果没有完全读取数据，会错过后续的触发，因此要结合非阻塞模式使用

### 边缘触发实现

```
#include <iostream>
#include <cstring>
#include <string>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/epoll.h>

#define MAX_EVENTS 10   //最大事件数
using namespace std;

int sSock, cSock;
struct sockaddr_in sAddr, cAddr;
socklen_t cAddr_sz;

struct epoll_event event, ep_event[MAX_EVENTS];
int epfd, event_cnt;

void error_handler(const string& msg) {
    cerr << msg << ": " << strerror(errno) << endl;
    exit(1);
}

void set_nonblocking(int sock) { //将套接字改为非阻塞模式
    int flag = fcntl(sock, F_GETFL, 0);
    if (flag == -1) error_handler("fcntl get error");
    if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) == -1) {
        error_handler("fcntl set non-blocking error");
    }
}

void epoll_add(int type, int sock) {
    event.events = type | EPOLLET; //监听读事件，使用边缘触发
    event.data.fd = sock; //将套接字的文件描述符赋值给 event 结构体中的 data 成员
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &event) == -1) {
        error_handler("epoll_ctl() error");
    }
}

void server_prepare(const string& port) {
    sSock = socket(PF_INET, SOCK_STREAM, 0);
    
    set_nonblocking(sSock);

    epfd = epoll_create1(0);
    if (epfd == -1) error_handler("epoll create() error");
    epoll_add(EPOLLIN, sSock);

    memset(&sAddr, 0, sizeof(sAddr));
    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sAddr.sin_port = htons(stoi(port));

    if (bind(sSock, (struct sockaddr*)&sAddr, sizeof(sAddr)) == -1) error_handler("bind() error");
    
    cout << "start listen..." << endl;
    if (listen(sSock, 5) == -1) error_handler("listen() error");
}

void connect_client() {
    cAddr_sz = sizeof(cAddr);
    cSock = accept(sSock, (struct sockaddr*)&cAddr, &cAddr_sz);
    if (cSock < 0) {
        error_handler("accept() error");
    }

    set_nonblocking(cSock);
    epoll_add(EPOLLIN, cSock);
    cout << "client is connected: " << cSock << endl;
}

void work(int client_sock) {
    char buffer[1024];
    while (true) {
        int len = read(client_sock, buffer, sizeof(buffer));
        
        if (len == 0) { //关闭链接
            epoll_ctl(epfd, EPOLL_CTL_DEL, client_sock, nullptr);
            close(client_sock);
            cout << "close client: " << client_sock << endl;
            break;
        } else if (len < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // 没有数据可读，退出循环
                break;
            } else {
                error_handler("read error");
            }
        } else {
            write(client_sock, buffer, len); // 注意可能需要处理未写完的情况
        }
    }
}

void server_start() {
    while (true) {
        event_cnt = epoll_wait(epfd, ep_event, MAX_EVENTS, -1);
        
        cout << "return epoll_wait" << endl; //验证边缘触发
        
        if (event_cnt == -1) {
            puts("event_wait() error");
            break;
        }

        for (int i = 0; i < event_cnt; i++) {
            if (ep_event[i].data.fd == sSock) { //监听到连接请求
                connect_client();
            } else {
                work(ep_event[i].data.fd);
            }
        }
    }
}

int main(int argc, char* argv[]) {
    if (argc != 2) error_handler("Usage: " + string(argv[0]) + " <port>");
    cout << "server is preparing..." << endl;
    server_prepare(argv[1]);

    cout << "server is started!" << endl;
    server_start();

    cout << "server is closed" << endl;
    close(sSock);
    close(epfd);
    return 0;
}
```

边缘触发的优势

```
可以分离接收数据和处理数据的时间点

从实际模型的角度出发，边缘触发更有可能带来更高的性能，但不能简单的认为只要使用边缘触发就一定能提高速度
```

## 线程

### 线程和进程的差异：

1. **进程**是操作系统资源分配的基本单位。每个进程都拥有**独立的地址空间**，包括**数据区**、**堆区**和**栈区**。因此，创建一个进程的开销较大，因为需要为其分配和管理独立的资源。
2. **线程**是 CPU 调度的基本单位，是进程的组成部分。每个线程拥有**独立的栈空间**，但与同一进程中的其他线程共享**数据区**和**堆区**。由于线程共享同一进程的资源，因此创建线程的开销比创建进程要小。
3. 在**上下文切换**时：
   - **进程**的上下文切换需要切换**整个地址空间**，包括数据区、堆区和栈区，因而代价较高。
   - **线程**的上下文切换只需要切换**栈**（因为每个线程有自己的栈），而数据区和堆区是共享的，因此开销较小，切换速度较快。
4. 线程可以通过共享的**数据区**和**堆区**直接进行数据交换，而不需要像进程间通信那样通过复杂的机制（如管道、消息队列、共享内存等）。

------

### 进程和线程的定义：

1. **进程**是操作系统中资源分配的独立单位，一个进程可以拥有多个线程。
2. **线程**是进程中的执行流单位，一个进程内的多个线程共享同一地址空间和系统资源（如文件句柄、网络连接等）。

------

### 操作系统与进程、线程的关系：

- **操作系统**管理多个进程。每个进程是相互独立的，可以并发执行。
- 每个**进程**可以包含多个线程，它们共享进程的资源，协同完成任务。

### 创建线程

```
#include <iostream>
#include <string>
#include <thread>
#include <chrono>

using namespace std;

void thread_main(int cnt, string& message) {
    message = "Hello, I'm thread\n";  

    for (int i = 0; i < cnt; i++) {
        this_thread::sleep_for(chrono::seconds(1));  // 使用C++11的休眠方式
        cout << "running thread" << endl;
    }
}

int main() {
    int thread_param = 5;
    string message;  // 使用std::string来保存返回值

    // 创建线程并传递参数和返回值引用
    thread t(thread_main, thread_param, ref(message));

    // 等待线程执行完毕
    t.join();

    // 输出线程返回的消息
    cout << "Thread return message: " << message << endl;

    return 0;
}

```

### 互斥量

```
为了方式多线程对于同一变量进行访问出现问题，我们必须做线程同步

互斥量（mutual exclusion）就是其中之一种线程同步方式
```

#### 应用：利用多线程计算1-10的和

```
#include <iostream>
#include <thread>
#include <mutex>

using namespace std;

int sum = 0;           // 全局变量，用于存储总和
mutex mtx;             // 用于保护 sum 的互斥锁

void calculate_sum(int start, int end) {
    int local_sum = 0;  // 局部变量来计算每个线程的部分和
    for (int i = start; i <= end; ++i) {
        local_sum += i;
    }

    // 保护对 sum 的修改，确保线程安全
    //lock_guard 是 RAII（Resource Acquisition Is Initialization）模式的一种实现，它确保在当前作用域结束时自动释放锁。
    lock_guard<mutex> lock(mtx);
    sum += local_sum;
}

int main() {
    // 创建两个线程分别计算 1-5 和 6-10 的和
    thread t1(calculate_sum, 1, 5);
    thread t2(calculate_sum, 6, 10);

    // 等待两个线程结束
    t1.join();
    t2.join();

    // 输出总和
    cout << "Total sum: " << sum << endl;

    return 0;
}

```

### 信号量

注意：此方法仅在c++20中可用

```
#include <iostream>
#include <thread>
#include <semaphore.h>
#include <vector>

using namespace std;

// 全局变量
int sum = 0;
sem_t semaphore; // POSIX 信号量

void calculate_sum(int start, int end) {
    int local_sum = 0;

    // 计算局部和
    for (int i = start; i <= end; ++i) {
        local_sum += i;
    }

    // 请求进入临界区，等待信号量
    sem_wait(&semaphore);

    // 修改共享资源
    sum += local_sum;

    // 释放信号量，允许其他线程进入临界区
    sem_post(&semaphore);
}

int main() {
    // 初始化信号量，初始值为 1
    sem_init(&semaphore, 0, 1);

    // 创建两个线程分别计算 1-5 和 6-10 的和
    thread t1(calculate_sum, 1, 5);
    thread t2(calculate_sum, 6, 10);

    // 等待两个线程结束
    t1.join();
    t2.join();

    // 输出总和
    cout << "Total sum: " << sum << endl;

    // 销毁信号量
    sem_destroy(&semaphore);
    
    return 0;
}
```

## 线程的销毁和多线程并发服务器端的实现

## 聊天室

server端

```
#include <iostream>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include <unistd.h>
#include <thread>
#include <arpa/inet.h>
#include <mutex>
#include <sys/socket.h>

#define MAX 1010

using namespace std;

void error_handler(const string& msg) {
    cerr << msg << " " << strerror(errno) << endl;
    exit(1);
}

int serverSock;
vector<int> clientSocks;
struct sockaddr_in serverAddr, clientAddr;
socklen_t clientAddrSize;
mutex mtx;

void server_prepare(const string& port) {
    serverSock = socket(PF_INET, SOCK_STREAM, 0);
    if (serverSock < 0) error_handler("socket() error");

    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = PF_INET;
    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    serverAddr.sin_port = htons(stoi(port));

    if (bind(serverSock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) == -1)
        error_handler("bind() error");

    if (listen(serverSock, 5) == -1)
        error_handler("listen() error");
}

void wait_login() {
    clientAddrSize = sizeof(clientAddr);
    int clientSock = accept(serverSock, (struct sockaddr*)&clientAddr, &clientAddrSize);
    if (clientSock < 0) error_handler("accept() error");

    {
        lock_guard<mutex> lock(mtx);
        clientSocks.push_back(clientSock);
    }
}

void logout(int clientSock) {
    {
        lock_guard<mutex> lock(mtx);
        clientSocks.erase(remove(clientSocks.begin(), clientSocks.end(), clientSock), clientSocks.end());
    }
    close(clientSock); // 关闭 socket
}

void send_msg(const char msg[], int len) {
    lock_guard<mutex> lock(mtx);
    for (int clientSock : clientSocks) {
        if (write(clientSock, msg, len) < 0) {
            logout(clientSock);
        }
    }
}

void recv_msg(int clientSock) {
    int len = 0;
    char msg[1024];

    while ((len = read(clientSock, msg, sizeof(msg))) > 0) {
        send_msg(msg, len);
    }

    if (len < 0) {
        cerr << "recv_msg error: " << strerror(errno) << endl;
    }
    
    logout(clientSock);
}

void server_start() {
    while (true) {
        wait_login();
        int clientSock;

        {
            lock_guard<mutex> lock(mtx);
            clientSock = clientSocks.back();
        }

        thread t(recv_msg, clientSock);
        t.detach(); // 分离线程
        cout << "Connected client IP: " << inet_ntoa(clientAddr.sin_addr) << endl;
    }
}

int main(int argc, char* argv[]) {
    if (argc != 2) error_handler("Usage: " + string(argv[0]) + " <port>");

    cout << "Start preparing..." << endl;
    server_prepare(argv[1]);

    cout << "Server is starting!" << endl;
    server_start(); 

    cout << "Server is closing" << endl;
    close(serverSock);
    return 0;
}
```

client端

```
#include <iostream>
#include <string>
#include <cstring>

#include <unistd.h>
#include <thread>

#include <arpa/inet.h>
#include <mutex>
#include <sys/socket.h>

using namespace std;

void error_handler(const string& msg) {
    cerr << msg << " " << strerror(errno) << endl;
    exit(1);
}

int cSock;
struct sockaddr_in sAddr;
string username;

void connect_server(const string&ip , const string& port){
    cSock = socket(PF_INET , SOCK_STREAM , 0 );

    memset(&sAddr , 0 , sizeof (sAddr));
    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = inet_addr(ip.c_str());
    sAddr.sin_port = htons(stoi(port));
    
    if(connect(cSock , (struct sockaddr *)&sAddr , sizeof(sAddr)) == -1) error_handler("connect failed");

}

void send_msg(int cSock){
    string msg;
    string name_msg;
    while(1){

        cout << "Insert Message(q to quite) :";
        getline(cin,msg);
        if(msg == "q"){
            cout << "close connect" << endl;
            close(cSock);
            return;
        }
        name_msg = username + ":" + msg; 
        write(cSock , name_msg.c_str() , name_msg.size());
    }
}

void recv_msg(int cSock) {
    char buffer[1024];
    while (true) {
        int len = read(cSock, buffer, sizeof(buffer) - 1);
        if (len <= 0) {
            cerr << "Connection closed or read error." << endl;
            break;
        }
        buffer[len] = '\0'; // Null-terminate the string
        cout << buffer << endl;
    }
}

int main(int argc , char* argv[]){
    
    if(argc != 4) error_handler("Usage: " + string(argv[0]) + " <ip addr> <port> <username>");
    username = argv[3];

    cout << "connect server...." << endl;
    connect_server(argv[1],argv[2]);
    cout << "connect success!" << endl;

    thread t1(send_msg,cSock);
    thread t2(recv_msg,cSock);
    t1.join();
    t2.join();

    cout << "close connect" << endl;
    close(cSock);
    return 0;
}
```

## 基于TCP协议的WEB服务器搭建

web服务器端：基于**HTTP** （超文本传输协议）协议将网页对应**文件**传输给客户端的服务器端

### http特点：

服务器端不会维持客户端的状态，即使同一个客户再次发送请求，服务器端也无法辨认原先哪个，而是以相同的方式处理请求

因此被称为 无状态的Stateless 协议

为了弥补这一缺点，引入了cookie和session技术

### 请求格式

```
GET filepath HTTP/1.1
```

服务器端会返回客户端状态码，常见的状态码有以下几种

```
200 OK ： 处理请求成功
404 NOTfOUND ：请求的文件不存在
400 BAD REQUEST ： 请求方式错误
```

### 实现

```
#include <iostream>
#include <cstring>
#include <string>
#include <fstream>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <thread>

using namespace std;

void error_handler(const string& msg) {
    cerr << msg << " " << strerror(errno) << endl;
    exit(1);
}

int sSock;
struct sockaddr_in sAddr, cAddr;
socklen_t cAddr_size;

void server_prepare(const string& port) {
    sSock = socket(PF_INET, SOCK_STREAM, 0);
    if (sSock == -1) error_handler("socket() error");

    memset(&sAddr, 0, sizeof(sAddr));
    sAddr.sin_family = PF_INET;
    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sAddr.sin_port = htons(stoi(port));

    if (bind(sSock, (struct sockaddr*)&sAddr, sizeof(sAddr)) == -1) error_handler("bind() error");
    if (listen(sSock, 20) == -1) error_handler("listen() error");
}

void send_error(int cSock) {
    string error_msg = "HTTP/1.1 404 Not Found\r\n"
                       "Content-Length: 0\r\n"
                       "Connection: close\r\n\r\n";
    write(cSock, error_msg.c_str(), error_msg.size());
    close(cSock);
}

string get_content_type(const string& filename) {
    if (filename.find(".html") != string::npos) return "text/html";
    if (filename.find(".css") != string::npos) return "text/css";
    if (filename.find(".js") != string::npos) return "application/javascript";
    if (filename.find(".jpg") != string::npos) return "image/jpeg";
    if (filename.find(".png") != string::npos) return "image/png";
    return "application/octet-stream";  // 默认为二进制流
}

void send_file_data(const string& filename, int cSock) {
    // 使用 root/ 作为文件的基础路径
    string filepath = "root" + filename;

    ifstream file(filepath, ios::binary);
    if (!file) {
        cerr << "File not found: " << filepath << endl;  // 输出完整文件路径
        send_error(cSock);
        return;
    }
    
    file.seekg(0, ios::end);
    size_t filesize = file.tellg();
    file.seekg(0, ios::beg);
    
    string header = "HTTP/1.1 200 OK\r\n"
                    "Content-Length: " + to_string(filesize) + "\r\n"
                    "Content-Type: text/html\r\n"
                    "Connection: close\r\n\r\n";
    write(cSock, header.c_str(), header.size());
    
    char buffer[1024];
    while (file.read(buffer, sizeof(buffer))) {
        write(cSock, buffer, file.gcount());
    }
    write(cSock, buffer, file.gcount());
    
    file.close();
    close(cSock);
}


void request_handler(int cSock) {//处理客户端的请求，并且将客户端请求的文件名传给发送的函数
    char req_line[1024] = {0};
    ssize_t bytes_read = read(cSock, req_line, sizeof(req_line) - 1);

    if (bytes_read <= 0) {
        cerr << "Failed to read request from client" << endl;
        close(cSock);
        return;
    }

    // 打印客户端的请求行 : Request: GET /index2.html HTTP/1.1
    cout << "Request: " << req_line << endl;
    
    string request(req_line);
    size_t pos = request.find(" ");
    size_t pos2 = request.find(" ", pos + 1);
    string filename = request.substr(pos + 1, pos2 - pos - 1);

    if (filename == "/") {
        filename = "index.html";
    }

    send_file_data(filename, cSock);
}

void server_start() {
    while (1) {
        cAddr_size = sizeof(cAddr);
        int clientSock = accept(sSock, (struct sockaddr*)&cAddr, &cAddr_size);
        if (clientSock == -1) {
            error_handler("accept() error");
            continue;
        }
        cout << "connect request : " << inet_ntoa(cAddr.sin_addr) << ":" << ntohs(cAddr.sin_port) << endl;
        thread t(request_handler, clientSock);
        t.detach();
    }
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        error_handler("Usage: " + string(argv[0]) + " <port>");
    }

    cout << "server prepare ....." << endl;
    server_prepare(argv[1]);

    cout << "server is start!" << endl;
    server_start();

    cout << "close server" << endl;
    close(sSock);
    return 0;
}
```

```
./server_start 启动后使用curl或者浏览器访问

http://ip:port/index.html即可
```

```
注意本机的文件路径
webserver
	server_start
	root
		index.html(css、js)
```



# 课后习题

## 第一章课后习题答案

1. 套接字在网络编程中的作用是什么？为什么称它为套接字？

   ```
   套接字是网络传输传输用的软件设备
   
   socket英文原意是插座：我们把插头插到插座上就能从电网获得电力供给，同样，为了与远程计算机进行数据传输，需要连接到Internet,而变成中的“套接字”就是用来连接该网络的工具
   ```

2. 在服务器端创建套接字后，会依次调用listen函数和accept函数。请比较并说明两者作用

   ```
   listen:将套接字转为可接受连接方式
   
   accept:受理连接请求，并且在没有连接请求的情况调用该函数，不会返回， 直到有连接请求为止。
   ```

3. Linux中，对套接字数据进行I/O时可以直接使用I/O相关函数；而在Windows中则不可以。原因为何？

   ```
   Linux把套接字也看作是文件，所以可以用文件I/O相关函数；
   
   而Windows要区分套接字和文件，所以设置了特殊的函数
   ```

4. 创建套接字后一般会给它分配地址，为什么？为了完成地址分配需要调用哪些函数？

   ```
   要在网络上区分来自不同机器的套接字，所以需要地址信息。分配地址是通过bind()函数实现
   int bind(int sock , const struct sockaddr *addr , socklen_t addrlen);
   ```

5. Linux中的文件描述符与Windows的句柄实际上非常类似。请以套接字为对象说明他们的含义。

   ```
   Linux的文件描述符是为了区分指定文件而赋予文件的整数值（相当于编号）。
   
   Windows的文件描述符其实也是套接字的整数值，其目的也是区分指定套接字。s
   ```

6. 底层文件I/O函数与ANSI标准定义的文件I/O函数之间有何区别？

   ```
   ANSI标准定义的输入、输出函数是与操作系统（内核）无关的以C标准写成的函数。
   
   相反，底层文件I/O函数是直接提供的。
   
   理论上ANSI标准I/O提供了某些机制，性能上由于底层I/O
   ```

## 第二章课后习题答案

- 什么是协议？在收发数据中定义协议有何意义？

```
协议就是为了完成数据交换而定好的约定。因此，定义协议意味着对数据传输所必需的的承诺进行定义。
```

- 面向连接的TCP套接字传输特性有3点，请分别说明。

```
传输过程中数据不会丢失

按序传输数据

传输的数据不存在数据边界(Boundary)
```

- 下面哪些是面向消息的套接字的特性？

```
传输数据可能丢失

以快速传递为目标

与面向连接的套接字不同，不存在连接的概念
```

- 什么时候用UDP，什么时候用TCP（非原题）

```
要快UDP，要稳TCP
```

- 何种类型的套接字不存在数据边界？这类套接字接收数据时需要注意什么？

```
连接指向型TCP套接字不存在数据边界。
因此输入输出函数的响应次数不具有意义。重要的不是函数的响应次数，而是数据的收发量。
因此，必须将传输数据的量和接收数据的量制作成编码，保证发送数据的量和接收数据的量是一致的，特别要注意是制作依赖函数响应次数判断代码
```

- 服务端write一次，客户端read多次，改成write多次，read一次有什么区别（非原题）

  ```
  大文件或大数据块传输：服务端 write 一次，客户端 read 多次可能更为合适，因为这样可以减少系统调用和网络延迟。
  
  实时性要求高的场景：如聊天应用、流媒体等场景，服务端 write 多次，客户端 read 一次可以更好地逐步发送小数据包，保证实时响应。
  
  资源限制：如果系统资源（如内存、带宽）有限，选择多次发送小数据包能更好地节省资源。
  ```

  

## 第三章课后习题答案

1. IP地址族IPv4和IPv6有何区别？在何种背景下诞生了IPv6?

   ```
   IPV4是4字节地址族，IPV6是16字节地址族。
   
   IPV6的诞生是为了应对2010年前后IP地址耗尽的问题而提出的标准
   ```

2. 通过IPV4网络ID、主机ID及路由器的关系说明向公司局域网中的计算机传输数据的过程

   ```
   首先数据传输的第一个环节是向目标IP所属的网络传输数据。此时使用的是IP地址中的网络ID。
   传输的数据将被传到管理网络的路由器，接受数据的路由器将参照IP地址的主机号找自己保存的路由表，找到对应的主机发送数据
   ```

3. 套接字地址分为IP地址和端口号。为什么需要IP地址和端口号？或者说，通过IP可以区分哪些对象？通过端口号可以区分哪些对象？

   ```
   IP地址是为了区分网络上的主机。
   
   端口号是区分同一主机下的不同的SOCKET，以确保软件准确收发数据。
   ```

4. IP地址分类

   ```
   A类地址：1.0.0.0 到 126.255.255.255
   B类地址：128.0.0.0 到 191.255.255.255
   C类地址：192.0.0.0 到 223.255.255.255
   D类地址：224.0.0.0 到 239.255.255.255（组播地址）
   ```

5. 计算机通过路由器或交换机连接到互联网。请说出路由器和交换机的作用

   ```
   路由器是帮助数据传输到目的地的中介。
   
   不仅如此，还起到帮助连接本地网络的电脑和互联网的作用
   ```

6. 什么是知名端口？其范围是多少？知名端口中具有代表性的HTTP合同FTP端口号各是多少？

   ```
   “知名端口(Well-known PROT)”是指预定分配给特定操作的端口。
   
   其范围是0~1023，其中最知名的端口是HTTP:80端口和TCP:21
   ```

7. 题目大概意思是：为什么bind中第二个参数是`sockaddr`，但是传入的是`sockaddr_in`

​		

```
	bind函数第二个参数类型是sockaddr结构体，很难份分配IP地址和端口号，因此IP地址和PORT号的分配是通过sockaddr_in完成的。
	因为该结构体和sockaddr结构体的组成字节序和大小完全相同，所以可以强转
```

- 请解释大端序、小端序、网络字节序，并说明为何需要网络字节序

```
小端序是把高位字节存储到高位地址上；大端序是把高位字节存储到低位地址上。

因为保存栈的方式有差异，所以对网络传输数据的过程制定了标准，这就是“网路字节序”。

而且，在网络字节序中，数据传输的标准是“大端序”
```

- 大端计算机希望将4字节整型数据12传到小端序计算机。请说出数据传输过程中发生的字节序变换过程

```
因为网络字节序的顺序标准是“大端序”，所以大端序的计算机在网络传输中不需要先转换字节顺序，直接传输。

但是接受数据的是小端序计算机，因此，要经过网络转本地序的过程，再保存到存储设备上
```

- 怎么表示回送地址？其含义是什么？如果向回送地址传输数据将会发生什么情况？

```
回送地址表示计算机本身，为127.0.0.1。

因此，如果将数据传送到IP地址127.0.0.1，数据会不会通过传输到网络的其他设备上而直接返回。
```

## 第四章课后习题答案

- 请说明TCP/IP的4层协议栈，并说明TCP和UDP套接字经过的层级结构差异

```
链路层—>IP层—>TCP层—>应用层

链路层—>IP层—>UDP层—>应用层
```



- 请说出TCP/IP协议栈中链路层和IP层的作用，并给出两者关系。

```
链路层是LAN、WAN、MAN等网络标准相关的协议栈，是定义物理性质标准的层级。

相反，IP层是定义网络传输数据标准的层级。即IP层负责以链路层为基础的数据传输
```

- 为何需要把TCP/IP协议栈分成4层（或7层）？结合开放式系统回答

```
将复杂的TCP/IP协议分层化的话，就可以将分层的层级标准发展成开放系统。

实际上，TCP/IP是开放系统，各层级都被初始化，并以该标准为依据组成了互联网。

因此，按照不同层级标准，硬件和软件可以相互替代，这种标准化是TCP/IP蓬勃发张的依据
```

- 客户端调用connect函数向服务器端发送连接请求。服务器端调用哪个函数后，客户端可以调用connect函数？

```
listen函数，客户端才可以调用connect函数
```

- 什么时候创建连接请求等待队列？它有何作用？与accept有什么关系

```
listen函数的调用创建了请求等待队列。它是存储客户端连接请求信息的空间。

accept函数调用后，将从本地存储的连接请求信息取出，与客户端建立连接。
```

- 客户端中为何不需要调用bind函数分配地址？如果不调用bind函数，那何时、如何向套接字分配IP地址和端口号？

```
客户端是请求连接的程序，不是一个接收连接的程序。所以，指导服务器的地址信息是更重要的因素，没有必要通过bind函数明确地分配地址信息。

但是，要想和服务器通信，必须将自己的地址信息分配到套接字上，因此，在connect函数调用时，自动把IP地址和端口号输入到套接字上
```

## 第五章课后习题答案

- 请说明TCP套接字连接设置的三次握手过程。尤其是3次数据交换过程每次收发的数据内容

```
A -》 B（提出连接申请 SYN）

B -》 A（接受并回复 SYN + ACK）

A -》 B（回复收到 ACK）
```

- TCP是可靠的数据传输协议，但在通过网络通信的过程可能丢失数据。请通过ACK和SEQ说明TCP通过何种机制保证丢失数据的可靠传输。

```
SEQ顺序标识符是给信息编号。

ACK是用于回复带有编号的信息

也就是说，每次传输信息时，都同时发送SEQ标识，而受到信息的主机应以SEQ信息为基础回复发送信息的主机。

通过这种机制，传输数据的主机就可以确认数据是否被正确接收。在传输失败时，可以重新传送。
```



- TCP套接字中调用write和read函数时数据如何移动？结合I/O缓冲进行说明

```
当write函数被调用时，数据就会向端口的输出缓冲区移动。

然后经过网络传输传输到对方主机套接字的输入缓冲。这样，输入缓冲中存储的数据通过read函数的响应来读取
```

- 对方主机的输入缓冲剩余50字节空间时，若本方主机通过write函数请求传输70字节，问TCP如何处理这种情况？

```
对方主机会把输入缓冲中可存储的数据大小传送给要传输数据的数据（本方）。

因此，在剩余空间为50字节的情况，即使要求传送70字节的数据，也不能传输50字节以上，剩余的部分保存在传输方的输出缓冲中，等待对方主机的输入缓冲出现空间。

而且，这种交换缓冲多余空间信息的协议被称为滑动窗口协议
```

## 第六章课后习题答案

1. UDP为什么比TCP速度快？为什么TCP数据传输可靠而UDP数据传输不可靠？

   ```
   UDP和TCP不同，不进行流量控制。
   由于该控制涉及到套接字的连接和结束，以及整个数据收发过程，因此，TCP传输的数据是可以信赖的。相反,UDP不进行这种控制，因此无法信任数据的传输，
   但正因UDP不进行流量控制，所以比TCP更快
   ```

2. 下面不属于UDP特点的是？

   ```
   利用UDP进行传输的时候，如果有两个目标字，则需要两个套接字
   
   UDP套接字中无法使用已分配给TCP的同一端口号
   
   UDP变已连接后也需要三次握手
   ```

3. UDP数据包向对方主机的UDP套接字传递过程中，IP和UDP分别负责哪些部分？

   ```
   IP负责链路选择。
   
   UDP负责端到端的传输
   ```

4. UDP一般比TCP快，但根据交换数据的特点，其差异可大可小。请说明何种情况下UDP的性能优于TCP

   ```
   UDP与TCP不同，不经过连接以及断开SOCKET的过程；
   
   因此，在频繁的连接及断开的情况下，UDP的数据收发能力会凸显出更好的性能。
   ```

5. 客户端TCP套接字调用connect函数时自动分配IP和端口号。UDP中不调用bind函数，那何时分配IP和端口号？

   ```
   首次调用sendto函数时，发现尚未分配信息，则给相应的套接字自动分配IP和端口号
   ```

6. TCP客户端必须调用connect函数，而UDP中可以选择性调用。请问，在UDP中调用connect函数有哪些好处？

   ```
   每当以UDP套接字为对像调用sendto函数时，都要经过以下过程
   
   - 第一阶段：为目标UDP注册端口和IP
   - 第二阶段：数据传输
   - 第三阶段：删除UDP注册的IP和端口信息
   
   其中，只要调用connect函数，就可以忽略每次传输数据时反复进行的第一阶段和第三阶段。
   
   然而，调用connect函数并不意味着经过连接过程，只是将IP地址和端口号指定在UDP的发送对象上。
   
   这样connect函数使用后，还可以用write、read函数进行数据处理，而不必使用sendto、recvfrom
   ```

   

## 第七章课后习题

1. 解释TCP中“流”的概念。UDP中能否形成流？请说明原因

   ```
   TCP的流指，两台主机通过套接字建立连接后进入可交换数据的状态，也称为“流形成的状态”。
   
   而对于UDP来说，不存在流，因为两个SOCKET不能相互连接
   ```

2. Linux中的close函数或Windows中的`closesocket`函数属于单方面断开连接的方法，有可能带来一些问题。什么是单方面断开连接？什么情况下会出现问题？

   单

   ```
   方面的断开连接意味着套接字无法再发送数据。
   
   一般在对方有剩余数据为发送完成时，断开己方连接，会造成问题。
   ```

3. 什么是半关闭？针对输出流执行半关闭的主机处于何种状态？半关闭会导致对方主机接收什么信息？

   ```
   半关闭是指只完成输入和输出流中的一个。
   
   如果对输出流进行半关闭，EOF无法被传送到对方主机，己方套接字无法传送数据，但可以接收对方主机传送的数据。
   ```

## 第八章课后习题

略（太简单了）

## 第九章课后习题

1. 下列关于Time-wait状态的说法错误的是？

   ```
   Time-wait状态只在服务器端出现
   
   time-wait状态与断开连接的过程无关，而与请求连接中发送的SYN消息有关
   ```

2. TCP_NODELAY可选项与Nagle算法有关，可通过它禁止Nagle算法。请问何时应考虑禁用Nagle算法？结合收发数据的特性给出说明

   ```
   根据传输数据的特性，网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快。例如“传输大文件数据”。将文件数据传入输出缓冲不会花太多时间，因此，即便不使用Nagle算法那，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而会在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。
   ```

   

## 第十章课后习题

- 下列关于进程的说法错误的是？

  ```
  进程可以包括其他进程，即一个进程的内存空间还可以包含其他的进程
  
  子进程可以创建其他的子进程，而创建出来的子进程还可以创建其他的子进程，但所有的进程只与一个父进程建立父子关系
  （进程是颗树）
  ```

- 调用fork函数将创建子进程，以下关于子进程描述错误的是？acd(a选项我测试过，真的不会销毁)

  ```
  父进程销毁时会同时销毁子进程
  （当父进程结束时，子进程会成为孤儿进程，并由 init 进程（或在现代系统中，由 systemd 或类似的系统进程）收养）
  
  子进程是复制父进程所有资源创建出的进程
  （只有在父进程或子进程试图修改这些资源时，系统才会实际进行复制。）
  
  通过fork创建的子进程将执行从开始到fork调用为止的代码
  （子进程从 fork 调用后的代码开始执行）
  ```

- 创建子进程时将复制父进程的所有内容，此时的复制对象也包含套接字文件描述符。复制的文件描述符整数值是否与原文件描述符整数值相同？

  ```
  是
  ```

- 请说明进程变为僵尸进程的过程及预防措施

  ```
  僵尸进程是子进程。
  
  在子进程结束时，其返回值会传到操作系统，直到返回值被其父进程接收为止，该（子）进程会一直作为僵尸进程存在。
  
  所以，为了防止这种情况的发生，父进程必须明确接收子进程结束时的返回值。
  ```

  

## 第十一章课后习题

1. 什么是进程间通信？分别从概念和内存的角度进行说明

   ```
   概括性地说，进程间通信是指两个进程之间交换数据。
   
   但是从内存的角度看，可以理解为两个进程共有内存。因为共享的内存区域存在，可以进行数据交换
   ```

2. 进程间通信需要特殊的IPC机制，这是由操作系统提供的。进程间通信时为何需要操作系统的帮助？

   ```
   要想实现IPC机制，需要共享的内存，
   
   但由于两个进程之间不共享内存，因此需要操作系统的帮助，也就是说，两进程共享的内存空间必须由操作系统来提供
   ```

   

   **IPC：Inter-Process Communucation ： 进程之间的通信**

   

3. “管道”是典型的IPC技术。关于管道，请回答如下问题。

   - 管道是进程间交换数据的路径。如何创建该路径?由谁创建？

     ```
     管道是由pip函数产生的，而实际产生管道的主体是操作系统
     ```

   - 为了完成进程间通信，2个进程需同时连接管道。那2个进程如何连接到同一管道？

     ```
     pipe函数通过输入参数返回管道的输入输出文件描述符。
     
     这个文件描述符在fork函数中复制到了其子进程，因此，父进程和子进程可以同时访问同一管道。
     ```

   - 管道允许进行2个进程间的双向通信。双向通信中需要注意哪些内容？

     ```
     管道并不管理进程间的数据通信。因此，如果数据流入管道，任何进程都可以读取数据。因此，要合理安排共享空间的输入和读取
     ```

     

## 第十二章课后习题答案

1. 请解释复用技术的通用含义，并说明何为I/O复用。

   ```
   复用技术指为了提高物理设备的效率，用最少的物理要素传递最多数据时使用的技术。
   
   同样，I/O复用是指将需要I/O的套接字捆绑在一起，利用最少限度的资源来收发数据的技术
   ```

2. 多进程并发服务器的缺点有哪些？如何在I/O复用服务器端中弥补？

   ```
   多进程并发服务器的服务方式是，每当客户端提出连接要求时，就会追加生成进程。
   
   但构建进程是一项非常有负担的工作，因此，向众多客户端提供服务存在一定的局限性。
   
   而复用服务器则是将套接字的文件描述符捆绑在一起管理的方式，因此可以一个进程管理所有的I/O操作
   ```

3. 下列select中描述错误的是

   ```
   若已通过select 注册成为监视对象，则后序调用select时无需重复注册
   
   复用服务器同一时间只能服务一个客户端，因此需要服务的客户端接入服务器端后只能等待
   ```

   

4. select函数的观察对象中应包含服务器端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因

   ```
   服务器套接字的作用是监听有无连接请求，即判断接收的连接请求是否存在
   
   应该将其包含到“读”类监听对象的集合中
   ```

5. select函数使用的fd_set结构体在Windows和Linux中具有不同的声明。请说明却别，同时解释存在区别的必然性

   ```
   Linux的文件描述符从0开始递增，因此可以找出当前文件描述符数量和最后生成的文件描述符之间的关系。
   
   但Windows的套接字句柄并非从0开始，并且句柄的整数值之间并无规律可循，因此需要直接保存句柄的数组和记录句柄数的变量
   ```

   

## 第十三章答案

1. 下面关于MSG_OOB可选项的说法错误

   ```
   MSG_OOB 指通过其他路径高速传输数据，因此 TCP中设置该选项数据先到达对方主机
   
   MSGOOB只是提高了传输速度，接受方无法识别
   ```

2. 利用readv&writev函数收发数据有何优点？分别从函数调用次数和I/O缓冲的角度给出说明

   ```
   readv&writev函数可以将分散保存在多个缓冲中的数据一并接受和发送，是对数据进行整合传输及发送的函数，因此可以进行更有效的数据传输。
   
   而且，输入输出函数的调用次数也相应减少，也会产生相应的优势
   ```

3. 通过recv函数见证输入缓冲是否存在数据时（确认后立即返回），如何设置recv函数最后一个参数中的可选项？分别说明各可选项的含义

   ```
   同时设置MSG_PEEK选项和MSG_DONTWAIT选项，以验证输入缓冲是否存在可接收的数据。
   
   设置MSG_PEEK选项并调用recv函数时，即使读取了输入缓冲数据也不会删除。
   
   因此，该选项通常与MSG_DONTWAIT合作，用于调用以非阻塞方式验证待读数据存在与否的函数。
   ```

4. 可在Linux平台通过注册时间处理函数接收MSG_OOB数据。那Windows中如何接受？请说明接收方法

   ```
   MSG_OOB数据的接收，在select函数中属于异常数据，既在Windows中可以通过异常处理来接收Out-of-band数据
   ```

   

## 第十四章答案

1. TTL的含义是什么？请从路由器的角度说明较大的TTL值与较小的TTL值之间的区别及问题

   ```
   TTL是Time to Live的缩写，是决定“信息传递距离”的主要因素。
   
   TTL表现为整数，没经过一个路由器就减1。如果该值为0，该数据报就会因无法再传递而消失。
   
   TTL设置大了会对网络流量造成不良影响，设置太小的话，就可能无法到达目的地
   ```

2. 多播和广播的异同是什么？请从数据通信的角度进行说明

   ```
   多播和广播的相同点是，两者都是以UDP形式传输数据。一次传输数据，可以向两个以上主机传送数据。
   
   但传送的范围是不同的：广播是对局域网的广播；而多播是对网络注册机器的多播
   ```

3. 下面是错误的

   ```
   多播无法跨越多个网络
   
   只能够有一个主机向多播组发送数据
   ```

4. 多播也对网络流量有利，请比较TCP数据交换方式解释其原因。

   ```
   多播数据在路由器进行复制。因此，即使主机数量很多，如果各主机存在的相同路径，也可以通过一次数据传输到多台主机上。
   
   但TCP无论路径如何，都要根据主机数量进行数据传输。
   ```

5. 多播方式的数据通信需要MBone虚拟网络。换言之，MBone是用于多播的网络，但它是虚拟网络。请解释此处“虚拟网络”。

   ```
   以物理网络为基础，通过软件方法实现的多播通信必备的虚拟网络
   ```

   

## 第十五章答案

- 说明标准I/O函数的2个优点。它为何拥有这2个优点？


```
可移植性强 ： 基于ANSIX标准具有良好的一致性

性能更高 ： 可以利用缓冲提高性能
```

- 标准IO中，“调用fputs函数传输数据时，调用后应立即开始发送！”，为何这种想法是错误的？为了达到这种效果应添加哪些处理过程？


```
通过标准输出函数的传输的数据不直接通过套接字的输出缓冲区发送，而是保存在标准输出函数的缓冲中，然后再用fflush函数进行输出。

因此，即使调用“fputs"函数，也不能立即发送数据。如果想保障数据传输的时效性，必须经过fflush函数的调用过程
```

## 第十七章答案

- 利用select函数实现服务器端时，代码层面存在的2个缺点是？


```
调用select函数后常见的针对所有文件描述符的循环语句

每次调用select函数时都需要向该函数传递监视对象信息
```

- 无论是select方式还是epoll方式，都需要将监视对象文件描述符信息通过函数调用传递给操作系统。请解释传递该信息的原因


```
select和epoll是系统函数，准确地说，是要求观察套接字变化的方式的。

套接字是受操作系统进行管理的。

既，select和epoll是一个有操作系统执行的函数。因此，应该将监视对象的文件描述符传递给操作系统
```

- select方式和epoll方式的最大差异在于监视对象文件描述符传递给操作系统的方式。请说明具体的差异，并解释为何存在这种差异。


```
epoll不同于select的地方是只要将监视对象文件描述符的信息传递一个给操作系统就可以了。

因此epoll方式克服了select方式的缺点，体现在linux内核上保存监视对象信息的方式。
```

- 虽然epoll是select的改进方式，但select也有自己的缺点。在何种情况下使用select方式更合理


```
如果连接服务器的人数不多（不需要高性能），而且需要在多种操作系统（windows和linux）下进行操作，在兼容性方面，使用select会比epoll更合理
```

- epoll以条件触发或边缘触发方式工作。二者有何区别？从输入缓冲的角度说明这2中方式通知事件的时间点的差异


```
在条件触发方式中，只要输入缓冲有数据，就会持续进行事件通知；

而在边缘触发中，只有当输入缓冲数据为空时才进行通知
```

- 采用边缘触发时可以分离数据的接收和处理时间点。说明其原因及优点。


```
如果使用边缘触发方式，在输入缓冲中接收数据时，只会发生一次事件通知，而且输入缓冲中仍有数据时，不会进行通知，因此可以在数据被接收后，在想要的时间内处理数据。

而且，如果分离数据的接收和处理时间点，在服务器中会有更大的灵活性
```

## 第十八章答案

- 单CPU系统中如何同时执行多个进程？请解释该过程中发生的上下文切换


```
因为系统将CPU切分成多个微小的块后分配给多个进程，为了分时使用CPU,需要”上下文切换“过程。”

上下文切换“是指，在CPU改变运行对象的过程中，执行准备的过程将之前执行的进程数据从换出内存，并将待执行额进程数据传到内存的工作区域
```

- 为何线程的上下文切换速度相对更快？线程间数据交换为何不需要类似IPC的特别技术？


```
因为线程进行上下文切换时不需要切换数据区和堆区。同时，可以利用数据区和堆区进行数据交换
```

- 请从执行流角度说明进程和线程的区别


```
进程：在操作系统中构成单独执行流的单位
线程：在进程内构成单独执行流的单位
```

- 下面关于临界区说法错误

  ```
  线程安全的函数不存在临界区，即便多个线程同时调用也不会发生问题
  
  1个临界区只能有一个代码块构成，而非多个代码块，换言之线程A的代码块A和线程B的代码块B绝对不会有临界区
  
  临界区由访问全局变量的代码构成，其他变量不会出问题
  ```

  

- 下面关于线程同步描述错误

  ```
  线程同步是代替进程IPC的技术
  ```

- 请说明完全销毁Linux线程的两种方法


```
pthread_join函数和pthread_detach函数
```

