---
title: 单调栈
categories: 力扣
date: 2024-03-07 16:28:45
tags: 力扣
---

# 单调栈

## 一、什么是单调栈？

一个栈里的顺序只有单调递增和单调递减

## 二、单调栈有什么用？

求一个元素 左边/右边 第一个比他 大/小的元素

## 三、单调栈里面存放的是什么？

下标

<!--more-->

## 四、例题

### 1、力扣 739.每日温度

```
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

解法：

1、本题可以看作是求一个元素右边第一个比他大的元素，使用单调递增的单调栈

2、遍历数组，将元素存入栈中，初次直接入栈，若即将入栈的元素（即下边为当前的i的元素）小于等于栈顶元素，直接压入

3、若即将入栈的元素大于栈顶元素，进入循环判定，直到栈内为空和栈内没有元素大于他，一一计算差值（i-st.top）并全部弹出

4、将最大的元素继续入栈

```
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> st;
        
        for(int i=0;i<n;i++){
            while(!st.empty() && temperatures[i] > temperatures[st.top()]){ 
                ans[st.top()] = i-st.top(); 
                st.pop();
            }
            st.push(i);
        }
        return ans;    
    }       
};
```

### 2、力扣 84.矩形中最大的面积

```
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形面积为 10
```

解法：

1、本题思路是锁定高度求底边最长，因此可以看作是找一个元素左边以及右边第一个小于当前元素的元素下标距离，所以使用单调栈

2、因为是小于，所以使用递减的单调栈

3、为了方便操作，在数组的收尾都加上0，这样最左边和最右边都有一个最小的终结值。

4、如果相同或者大于栈顶元素就将他压入

5、如果小于栈顶元素就开始进入循环计算

6、当前的元素就是栈顶元素，也就是锁定的高

7、左边第一个比他小的元素就是栈顶的第二个元素

8、右边第一个比他小的元素就是即将入栈的元素

9、因为存储的是下标，所以底边长为右减左减1；

10、将当前的元素压入，做下次对比。

```
class Solution {
public:
    //寻找左/右边第一个大于/小于当前元素的元素，单调栈
    //单调栈中存储的是元素的下表
    //本题是小于，栈内是单调递减
    int largestRectangleArea(vector<int>& heights) {
        heights.insert(heights.begin(),0);//数组头尾加0
        heights.push_back(0);
        
        stack<int> st;
        st.push(0);//栈里推初始值0
        
        int n = heights.size();
        int ans=0;
        for(int i=1;i<n;i++){
            while(!st.empty() && heights[i]<heights[st.top()]){//小于栈顶元素开始计算   
            int h_index = st.top();//当前的元素即为栈顶元素。
            st.pop();
            if(!st.empty()){
                int left =st.top(); //左边第一个比他小的即为弹出当前元素后的栈顶元素
                int right = i;//右边第一个比他大的元素是当前比较的即将入栈的元素
                ans = max(ans,(right-left-1)*heights[h_index]);//因为存的是下标，所以底边长为右减左减1；
            }
            }            
            st.push(i);  //将当前元素入栈做下次对比
        }
        
        return ans;
    }
};
```

### 3、力扣 496 下一个更大的元素Ⅰ

```
nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。
```

解法：

1、题目明示是右边下一个更大的元素，所以确定是递增单调栈，将结果存储至ans数组，ans默认值为-1，大小和子数组大小一致

2、因为需要求的是子数组，为了方便确认目前求的元素是否属于子数组，用unordered_map来存储子数组的元素<key：元素，value：下标>

3、如果当前元素大于栈顶元素，并且他属于子数组（map中存在），那么就将它存入ans数组，否则直接不要。

```
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack <int> st;
        vector<int> ans(nums1.size(),-1);
        if(nums1.size() == 0) return ans;
        unordered_map<int,int>checkMap;
        for(int i=0;i<nums1.size();i++) checkMap[nums1[i]] = i;
        
        for(int i=0;i<nums2.size();i++){
            while(!st.empty()&&nums2[i] > nums2[st.top()]){
                if(checkMap.count(nums2[st.top()]) > 0){//如果他在map里存在,就执行操作
                    int index = checkMap[nums2[st.top()]];
                    ans[index] = nums2[i];
                }
                st.pop();
            }
            
            st.push(i);
        }
        
        return ans;
    }
};
```

### 4、力扣503 下一个更大的元素Ⅱ

```
给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。

数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。
```

解法：

1、下一个更大->递增单调栈

2、首尾相连的数组我们可以用求余的方法，i的取值范围扩展到2n即可

```
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> st;
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n*2;i++){//环形绕一圈就行
            while(!st.empty()&&nums[i%n] > nums[st.top()]){
                ans[st.top()] = nums[i%n];
                st.pop();
            }
            st.push(i%n);
        }
        return ans;
    }
};
```

### 5、力扣42 接雨水

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

解法：

1、该题可以看成求当前元素左边第一个比他大的和右边第一个比他大的元素，所以用递增单调栈

2、水槽的面积就是左边第一个比他大的到右边第一个比他大的距离 乘以 左右两边最小的那一个高度

3、因为是递增的单调栈，所以栈顶元素就是当前元素，即将入栈的就是右边第一个比他大的，栈内第二个元素就是左边第一个比他大的

```
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        stack<int> st;
        
        for (int i = 0; i < height.size(); i++) {
            while (!st.empty() && height[i] > height[st.top()]) {
                int mid = st.top();
                st.pop();
                if (st.empty()) break; // 无法形成容器，退出循环                
                int left = st.top();
                int right = i;
                int h = min(height[left], height[right]) - height[mid];
                int w = right - left - 1;
                ans += h * w;
            }
            st.push(i);
        }
        
        return ans;
    }
};

```

