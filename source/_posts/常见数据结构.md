---
title: 常见数据结构
categories: 力扣
date: 2024-03-16 19:28:45
tags: 力扣
top: true
---

# 常见数据结构

<!--more-->

# 特殊、数组/集合

### 数组

特点：连续的空间

定义

```
int n[10];
int n[10][10]//死空间

int* n = (int*)malloc(sizeof(int) * 10);
int** n = (int**)malloc(10 * sizeof(int*)); // 分配行指针数组
for (int i = 0; i < 10; ++i) {
    n[i] = (int*)malloc(10 * sizeof(int)); // 分配每行的列数
}//指针,可改变大小,但需要手动释放

vector<int>n;
vector<vector<int>>n//容器，动态大小，方便
```

常用方法（ vector）

```
push_back(val);
pop_back();
sort(n.begin(),n.end());
```

### 集合

###### set

在内部使用红黑树等数据结构来维护元素的顺序，是一种有序集合。

定义

```
set<int> mySet
```

常用方法

```
find(val)
insert(val)
erase(val) //删除
size()
empty()
clear()
```

###### multiset

允许 重复元素存在

定义

```
multiset<int> multiSet
```

## 例题

### 1、力扣	704 二分查找

```
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

解法：没啥好说的，记就完事了

注意开闭的区别

开区间的left和right就直接等于mid

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int right = nums.size()-1;
        int left =0;
        int mid = (right+left) /2;
        
        while(nums[mid] != target){
            if(nums[mid] < target) left = mid+1;
            else if(nums[mid] > target) right =  mid -1;
            mid = (right+left) / 2;
            if(left > right) return -1;
        }
        return mid;
    }
};
```

### 2、力扣 27 移除元素

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1：

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

解法：双指针

定义一个快指针用来遍历，一个慢指针用来存放结果

如果快指针指到的元素是我们需要的，慢指针就存放快指针当前存放的元素，并且向前进一步

```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow =0;
        for(int fast=0;fast<nums.size();fast++)
            if(nums[fast]!=val) 
                nums[slow++] = nums[fast];
        return slow;
    }
};
```

### 3、力扣 977 有序数组的平方

```
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
示例 2：

输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

解法：

定义头尾双指针，还需要一个存放用的指针

因为在本题中是已经有序的带负数的数组，那么它平方后的趋势就是头尾大，中间小

所以我们可以用两个指针一头一尾，判定，将大的存放到ans后面，存放过的指针就--，小的不动

```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0, j = n - 1, pos = n - 1; i <= j;) {
            if (nums[i] * nums[i] > nums[j] * nums[j]) {
                ans[pos] = nums[i] * nums[i];
                ++i;
            }
            else {
                ans[pos] = nums[j] * nums[j];
                --j;
            }
            --pos;
        }
        return ans;
    }
};
```

### 4、 力扣 209 长度最小的子数组

```
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 连续
子数组
 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

解法：

这题可以用到一个滑动窗口的思想

从第一个元素开始累加，一直到满足条件为止是第一个长度大小。

此时先将下标定在这里。从开头开始减去元素，看看是否还满足条件。

期间每次操作后都记录长度大小的最小值

如此反复一直到数组末尾即可

```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left=0;
        int ans = INT_MAX;
        int sum=0;
        for(int right=0;right<nums.size();right++){
            sum+=nums[right];
            while(sum >= target){
                ans = min(ans,right-left+1);
                sum-=nums[left];
                left++;
            }
        }
        if (ans == INT_MAX) return 0;
        return ans;
    }
};
```

### 5、力扣 54 螺旋矩阵

```
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：


输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

解法：模拟它行走的路程

每次走完后可以理解为缩圈

走完第一行就把第一行剪掉就是了（top++）；

走完最后一列就把最后一列剪掉（right--）；

走完最后一行就把底端剪切（down--）；

走完第一列再把第一列剪除（left++）；

直到上边界遇到下边界，或者左边界碰上右边界

```
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int top = 0; //赋值上下左右边界
        int down = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;
        while(true)
        {
            for(int i = left; i <= right; ++i) ans.push_back(matrix[top][i]); //向右移动直到最右
            if(++ top > down) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = top; i <= down; ++i) ans.push_back(matrix[i][right]); //向下
            if(-- right < left) break; //重新设定右边界
            for(int i = right; i >= left; --i) ans.push_back(matrix[down][i]); //向左
            if(-- down < top) break; //重新设定下边界
            for(int i = down; i >= top; --i) ans.push_back(matrix[i][left]); //向上
            if(++ left > right) break; //重新设定左边界
        }
        return ans;
    }
};

```



# 一、链表

特点：每个结点都有一个指向下一个结点的指针

定义

```
ListNode* list = new ListNode()
```

###### 实现（c++中需要手动实现）

```
struct ListNode {// 定义链表节点结构体
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {} //初始化参数
    
    ListNode() : val(0), next(nullptr) {}//可选
	ListNode(int x, ListNode *next) : val(x), next(next) {}//可选
};
```

###### 在指定位置插入链表

```
ListNode* insert(ListNode* head,int val,int index){
	ListNode* sp_head = new ListNode(0);
	sp_head->next = head; 
	ListNode* newnode = new ListNode(val);
	ListNode* pre = sp_head;
	while(--index && pre->next!=nullptr){
		pre = pre->next;
	}
	if(index >0 ) return head;
	newnode->next = pre->next;
	pre->next = newnode->next;
	
	head = sp_head->next;
    delete sp_head;
    return head;
}
```

###### 在指定位置删除值

```
ListNode* deleteNode(int index){//删除指定位置值 
		ListNode* sp_head = new ListNode(0);
		sp_head->next = head;
		ListNode* pre = sp_head;
		while(--index && pre->next){
			pre = pre->next;
		}
		if(index > 0) {
			delete sp_head;
			return head;
		}
		ListNode* q =pre->next;
		pre->next = pre->next->next;
		delete q;
		
		head = sp_head->next;
		delete sp_head;
		return head;
	}
```

###### 头插法逆序

```
ListNode* reverseList() {
    	ListNode* L2 = NULL;
    	ListNode* current = head;

    	while (current) {
        	ListNode* nextNode = current->next; // 暂存下一个节点
        	current->next = L2; // 将当前节点插入到新链表头部
        	L2 = current; // 更新新链表的头部
        	current = nextNode; // 移动到下一个节点
    	}
    	head = L2; // 更新原链表的头部
    	return head;
	}
```

## 一、例题

### 1、力扣 203 移除链表元素

```
给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
 

示例 1：


输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
示例 2：

输入：head = [], val = 1
输出：[]
示例 3：

输入：head = [7,7,7,7], val = 7
输出：[]
```

题解

加个特殊头节点防止在头节点进行修改，一直遍历到需要删除的结点的前一个结点，直接next = next->next就行了



```
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        struct ListNode* null_head = new ListNode(0,head);
        struct ListNode* p = null_head;
        while(p->next!=NULL){
            if(p->next->val == val){
                p->next = p->next->next;
            }
            else{
                p=p->next;
            }
        }
        return null_head->next;
    }
};
```



### 2、 力扣 707 设计链表

```
你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。

实现 MyLinkedList 类：

MyLinkedList() 初始化 MyLinkedList 对象。
int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。
void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。
void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。
 

示例：

输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
```

题解

​	私有成员一个头节点和一个数量统计，方便在末尾进行修改，添加和删除都遍历到需要元素的前一个元素

```
class MyLinkedList {

private:
    int size;
    ListNode *head;
public:
    MyLinkedList() {
        this->size = 0;
        this->head = new ListNode(0);
    }
    
    int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode *cur = head;
        for (int i = 0; i <= index; i++) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        size++;
        ListNode *pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred->next;
        }
        ListNode *toAdd = new ListNode(val);
        toAdd->next = pred->next;
        pred->next = toAdd;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode *pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred->next;
        }
        ListNode *p = pred->next;
        pred->next = pred->next->next;
        delete p;
    }
};
```

### 3、 力扣 206 反转链表

```
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 

示例 1：


输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
示例 2：


输入：head = [1,2]
输出：[2,1]
示例 3：

输入：head = []
输出：[]
 
```

题解：利用头插法的原理逆序

```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* L2 = new ListNode(0);
        L2->next = NULL;
        
        while(head){
            ListNode* temp= new ListNode(head->val);
            temp->next = L2->next;
            L2->next = temp;
            head = head->next;
        }
        return L2->next; 
    }
};
```

### 4、 力扣 24 两两交换链表中的元素

```
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
示例 3：

输入：head = [1]
输出：[1]
```

题解：

添加一个特殊头节点，方便在头部进行操作

定义三个指针，

一个用来记录需要交换的两个元素前一个结点（index）

一个用来记录需要交换的第一个结点（first）

一个用来记录第二个结点（second）

每次交换完后，让index向后移动两位 也就是移动到 交换的第一个结点（first）处

```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;
        
        ListNode* null_head = new ListNode(0,head);
        ListNode* index = null_head;
        
        while(index->next != NULL && index->next->next != NULL){
            ListNode* first=index->next;
            ListNode* second=index->next->next;
            
            index->next = second;
            first->next = second->next;
            second->next = first;
            index = first;
            
        }
        return null_head->next;
    }
};
```

### 5、力扣 19 删除链表的倒数第N个结点

```
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。


示例 1：


输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
示例 2：

输入：head = [1], n = 1
输出：[]
示例 3：

输入：head = [1,2], n = 1
输出：[1]
```

题解：

定义一个特殊头节点，方便于顶端操作

定义快慢两个指针，当快指针走够n步后，慢指针开始走。当快指针走到末尾，慢指针指向的元素就是第n个元素

为了方便删除，也可以让快指针走到倒数第二个元素，这样慢指针走到的就是第n-1个元素。

```
	class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == NULL) return head;
        ListNode* null_head = new ListNode(0,head);
       if(head->next ==NULL && n == 1) return NULL;
        int count =n;
        ListNode* low=null_head;
        ListNode* fast=null_head;
        while(fast->next!=NULL){
            fast=fast->next;
            count--;
            if(count <0) low = low->next;
        }
        low->next = low->next->next;
        return null_head->next;
    }
};
```

### 6 、力扣 142 环形链表 Ⅱ

```
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

 

示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

题解：

首先明确，定义快慢指针，一个走的快，一个走的慢，如果有环，那一定会重逢。

当重逢的时候就证明了有环的存在，问题就是如何寻找环的入口了

我们假设 （从左到右）

```
从起点到环入口的距离为x

入口到重逢地点的距离为y

重逢地点到入口的距离为z
```

```
慢指针走过的路即为 2*（x+y） （因为慢指针的速度是快指针的一半）

快指针走过的路即为 x+（y+z）*n +y

等式连接 约分 可得 x = n*(y+z) - y
x = ny +nz -y
x = (n-1)y + nz
x = (n-1)y + (n-1+1)*z
x = (n-1)y + (n-1)z + z
x = (n-1)(y+z) + z
```

我们可以发现，当n==1的时候，x是等于z的

也就是说，当一个指针从起点开始移动，一个指针从重逢地点开始移动，必会在入口处重逢

所以当快慢指针重逢时，再声明两个指针（index1和index2）在头部和重逢部 移动

当index1 == index2 的时候，环的入口也就找到了

```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast=head;
        ListNode* slow=head;
        
        while(fast!=NULL && fast->next!=NULL){
            fast = fast->next->next;
            slow = slow->next;
                if(fast == slow){
                    ListNode* index1  = fast;
                    ListNode* index2  = head;
                    while(index1!=index2){
                        index1 = index1->next;
                        index2 = index2->next;
                    }
                    return index1;
                    break;
                }
        }
        return NULL;
    }
};
```



# 二、栈

特点 ：先进后出

定义

```
stack<int> st;
```

常用方法

```
push(val);
pop();
top();
empty();
size();
```

## 例题

### 1、力扣 225 用栈实现队列

```
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
```

题解

用两个栈来模拟，一个栈用来入，一个栈用来出。

先进后出，先进后出 ==》先进先出

```
class MyQueue {
public:

    stack<int> InSt,OutSt;
    
    void in_too_out(){
        while(!InSt.empty()){
            OutSt.push(InSt.top());
            InSt.pop();
        }
    }
    
    MyQueue() {

    }
    
    void push(int x) {
        InSt.push(x);
    }
    
    int pop() {
       if(OutSt.empty()) {
        in_too_out();   
       }
        int x = OutSt.top();
        OutSt.pop();
        return x;
    }
    
    int peek() {
        if(OutSt.empty()){
            in_too_out();    
        }
        
        int x = OutSt.top();
        return x;
    }
    
    bool empty() {
        return InSt.empty()&&OutSt.empty();
    }
};
```

### 2、力扣 20 有效的括号

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
 

示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false
```

题解

利用栈来做

左括号入队，右括号判定

合法栈顶弹出，不合法直接return false

若栈为空，又遇到右括号，说明缺少左括号，直接报错

若遍历完了，栈还不为空，说明缺少右括号，报错

```
class Solution {
public:
    
    bool is_check(char x,char ch){
        if(x=='(' && ch == ')') return true;
        else if(x =='[' && ch==']') return true;
        else if(x == '{' && ch =='}') return true;
        else return false;
    }
    
    bool isValid(string s) {
        stack<char> st;
        for(char ch:s){
            if(ch == '(' || ch == '[' || ch == '{'){
                st.push(ch);        
            }
            else if(ch == ')'||ch == ']'||ch =='}'){
                if(st.empty()) return false;
                char x = st.top();
                if(!is_check(x,ch)) return false;
                else st.pop();
            }
        }
        return st.empty();
    }
};
```



### 3、力扣 1047 别除字符串中的所有相邻重复项

```
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
 
```

题解：

和括号大同小于，栈处理，同等就出栈，不同就入栈，最后反转一下出栈后的字符串就行

```
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> st;
        string ans;
        for(char ch:s){
            if(st.empty() || st.top()!=ch) st.push(ch);
            else st.pop(); 
        }
        
        while(!st.empty()){
            char x = st.top();
            ans+=x;
            st.pop();
        }
        
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```



### 4、力扣 150 逆波兰表达式求值

```
给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

注意：

有效的算符为 '+'、'-'、'*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示。
```

题解：

由于本体是后缀表达式，所以不用考虑符号的优先级

遇到数字就压入，遇到符号就连续弹出，计算，注意后弹出的作为第一个元素

计算完后将结果继续压入

最后栈内的数字就是结果

```
class Solution {
public:
    
    bool is_num(string s){
        if(s.size() != 1 && s[0] == '-') return true;
        for(char ch:s){
            if(ch > '9' || ch <'0' ) return false;
        }
        return true;
    }
    
    int change_num(string s){
        int sum=0;
        int flag = 1;
        for(char ch:s){
            if(ch == '-') {
                flag = -1;
                continue;
            }
            sum = sum*10+ch-'0';
        }
        return sum*flag;
    }
    
    int operation(int num1,int num2,string s){
        char ch = s[0];
        int sum=0;
        switch(ch){
            case '+': sum = num1+num2; break;
            case '-': sum = num1-num2; break;
            case '/': sum = num1/num2; break;
            case '*': sum = num1*num2;
        }
        return sum;
    }
    
    int evalRPN(vector<string>& tokens) {
        stack<int> st_num;
        int sum=0;
        for(string s:tokens){
            if(is_num(s)){
                int sum = change_num(s);
                st_num.push(sum);
            }else{
                int num1 = st_num.top();
                st_num.pop();
                int num2 = st_num.top();
                st_num.pop();
                int num3 = operation(num2,num1,s);
                st_num.push(num3);
            }
        }
        return st_num.top();
    }
};
```



## 衍生结构：单调栈

定义

```
栈中的元素单调增加/减少

存放的是下标

适合求左边/右边 第一个比他 大/小 的元素
```

### 例题

#### 1、力扣 739.每日温度

```
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

解法：

1、本题可以看作是求一个元素右边第一个比他大的元素，使用单调递增的单调栈

2、遍历数组，将元素存入栈中，初次直接入栈，若即将入栈的元素（即下边为当前的i的元素）小于等于栈顶元素，直接压入

3、若即将入栈的元素大于栈顶元素，进入循环判定，直到栈内为空和栈内没有元素大于他，一一计算差值（i-st.top）并全部弹出

4、将最大的元素继续入栈

```
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> st;
        
        for(int i=0;i<n;i++){
            while(!st.empty() && temperatures[i] > temperatures[st.top()]){ 
                ans[st.top()] = i-st.top(); 
                st.pop();
            }
            st.push(i);
        }
        return ans;    
    }       
};
```

#### 2、力扣 84.矩形中最大的面积

```
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形面积为 10
```

解法：

1、本题思路是锁定高度求底边最长，因此可以看作是找一个元素左边以及右边第一个小于当前元素的元素下标距离，所以使用单调栈

2、因为是小于，所以使用递减的单调栈

3、为了方便操作，在数组的收尾都加上0，这样最左边和最右边都有一个最小的终结值。

4、如果相同或者大于栈顶元素就将他压入

5、如果小于栈顶元素就开始进入循环计算

6、当前的元素就是栈顶元素，也就是锁定的高

7、左边第一个比他小的元素就是栈顶的第二个元素

8、右边第一个比他小的元素就是即将入栈的元素

9、因为存储的是下标，所以底边长为右减左减1；

10、将当前的元素压入，做下次对比。

```
class Solution {
public:
    //寻找左/右边第一个大于/小于当前元素的元素，单调栈
    //单调栈中存储的是元素的下表
    //本题是小于，栈内是单调递减
    int largestRectangleArea(vector<int>& heights) {
        heights.insert(heights.begin(),0);//数组头尾加0
        heights.push_back(0);
        
        stack<int> st;
        st.push(0);//栈里推初始值0
        
        int n = heights.size();
        int ans=0;
        for(int i=1;i<n;i++){
            while(!st.empty() && heights[i]<heights[st.top()]){//小于栈顶元素开始计算   
            int h_index = st.top();//当前的元素即为栈顶元素。
            st.pop();
            if(!st.empty()){
                int left =st.top(); //左边第一个比他小的即为弹出当前元素后的栈顶元素
                int right = i;//右边第一个比他大的元素是当前比较的即将入栈的元素
                ans = max(ans,(right-left-1)*heights[h_index]);//因为存的是下标，所以底边长为右减左减1；
            }
            }            
            st.push(i);  //将当前元素入栈做下次对比
        }
        
        return ans;
    }
};
```

#### 3、力扣 496 下一个更大的元素Ⅰ

```
nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。
```

解法：

1、题目明示是右边下一个更大的元素，所以确定是递增单调栈，将结果存储至ans数组，ans默认值为-1，大小和子数组大小一致

2、因为需要求的是子数组，为了方便确认目前求的元素是否属于子数组，用unordered_map来存储子数组的元素<key：元素，value：下标>

3、如果当前元素大于栈顶元素，并且他属于子数组（map中存在），那么就将它存入ans数组，否则直接不要。

```
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack <int> st;
        vector<int> ans(nums1.size(),-1);
        if(nums1.size() == 0) return ans;
        unordered_map<int,int>checkMap;
        for(int i=0;i<nums1.size();i++) checkMap[nums1[i]] = i;
        
        for(int i=0;i<nums2.size();i++){
            while(!st.empty()&&nums2[i] > nums2[st.top()]){
                if(checkMap.count(nums2[st.top()]) > 0){//如果他在map里存在,就执行操作
                    int index = checkMap[nums2[st.top()]];
                    ans[index] = nums2[i];
                }
                st.pop();
            }
            
            st.push(i);
        }
        
        return ans;
    }
};
```

#### 4、力扣503 下一个更大的元素Ⅱ

```
给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。

数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。
```

解法：

1、下一个更大->递增单调栈

2、首尾相连的数组我们可以用求余的方法，i的取值范围扩展到2n即可

```
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> st;
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n*2;i++){//环形绕一圈就行
            while(!st.empty()&&nums[i%n] > nums[st.top()]){
                ans[st.top()] = nums[i%n];
                st.pop();
            }
            st.push(i%n);
        }
        return ans;
    }
};
```

#### 5、力扣42 接雨水

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

解法：

1、该题可以看成求当前元素左边第一个比他大的和右边第一个比他大的元素，所以用递增单调栈

2、水槽的面积就是左边第一个比他大的到右边第一个比他大的距离 乘以 左右两边最小的那一个高度

3、因为是递增的单调栈，所以栈顶元素就是当前元素，即将入栈的就是右边第一个比他大的，栈内第二个元素就是左边第一个比他大的

```
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        stack<int> st;
        
        for (int i = 0; i < height.size(); i++) {
            while (!st.empty() && height[i] > height[st.top()]) {
                int mid = st.top();
                st.pop();
                if (st.empty()) break; // 无法形成容器，退出循环                
                int left = st.top();
                int right = i;
                int h = min(height[left], height[right]) - height[mid];
                int w = right - left - 1;
                ans += h * w;
            }
            st.push(i);
        }
        
        return ans;
    }
};

```



# 三、队列

特点：先进先出

## 1、单端队列

定义

```
queue<int> q1
```

常用方法

```
push(val);
pop();
front();
back();
empty();
size();
```



#### 例题、力扣 225 用队列实现栈

```
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 

注意：

你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
 
```

题解

只需要使用一个队列。在需要出栈的时候，循环出队入队size-1次，便是栈顶元素（其实就是队尾）

```
class MyStack {
public:
    queue<int> q1;
    
    void find_end(){
        for(int i=0;i<q1.size()-1;i++){
            int x = q1.front();
            q1.pop();
            q1.push(x);
        }
    }
    
    MyStack() {

    }
    
    void push(int x) {
        q1.push(x);
    }
    
    int pop() {
        if(!q1.empty()){
            find_end();
        }
        int x = q1.front();
        q1.pop();
        return x;
    }
    
    int top() {
        int x =q1.back();
        return x;
    }
    
    bool empty() {
        return q1.empty();
    }
};
```



## 2、双端队列

定义

```
deque<int> q1;
```

常用方法

```;
push_front(val);
push_back(val);
pop_front(val);
pop_back(val);
front();
back();
empty();
size();
```

### 衍生类型1：单调队列

定义

```
遇到比当前元素 大（小）的，就全部出队

遇到小的就加到最后

当 下标 超出范围弹出

存放的是下标

求滑动窗口中的 最大值
```

#### 例题、力扣 239 滑动窗口最大值

```
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]
 
```

题解：

使用单调队列（双端队列）实现滑动窗口

单调队列内存放的是数组元素的下标

只保留从队首到队尾的从大到小元素

如果最大元素的下标，小于i-k+1，就将他出队

如果遇到比当前最大元素还要大的，就将队内全部清空，因为不可能成为最大值

```
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q1;
        vector<int> ans;
        for (int i = 0; i < nums.size(); ++i) {
            // 删除队列中不在当前窗口内的元素
            if (!q1.empty() && q1.front() < i - k + 1) {
                q1.pop_front();
            }
            
            // 删除队列中比当前元素小的元素，因为它们不可能成为窗口中的最大值
            while (!q1.empty() && nums[q1.back()] < nums[i]) {
                q1.pop_back();
            }
            
            // 将当前元素的索引加入队列
            q1.push_back(i);
            // 如果窗口已经形成，记录窗口中的最大值
            
            if (i >= k - 1) {
                ans.push_back(nums[q1.front()]);
            }
            
        }
        return ans;
    }
};
```



### 衍生类型2：顶堆（优先队列）

定义：

```
 priority_queue<数据类型,存储数据用的容器,自定义比较方法所在的类>
```

```
顶堆（或最大堆）是一种特殊的二叉堆数据结构，其中每个节点的值都大于或等于其子节点的值。顶堆的根节点（顶部节点）是堆中的最大值。

优先队列通过堆的性质，特别是顶堆的性质，来保证队列中元素的有序性。当你向优先队列插入元素时，它会根据一定的优先级规则将元素放置在适当的位置，以保持堆的顶部是最大元素。因此，通过使用顶堆，优先队列可以实现高效的元素插入和删除操作，并且始终能够快速地访问最大元素。

适合求前k个高（低）频词
```

实现

```
	// 小顶堆，求前k个高频词
    class mycomparison {//通过重载operator方法来实现自定义排序
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {//它会根据这个比较函数的逻辑来维护队列的顺序
            return lhs.second > rhs.second;
        }
    };
    
    // 定义一个小顶堆，大小为k
    priority_queue<pair<int,int>,vector<pair<int,int>>,mycomparison> pri_que;
```

#### 例题、力扣 347 前K个高频元素

```
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]
```

题解：

使用哈希表记录出现的频率

使用优先队列（小顶堆）找出频率最高的前k个数值

```
class Solution {
public:
    // 小顶堆，求前k个高频词
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    
    vector<int> topKFrequent(vector<int>& nums, int k) {
        
        unordered_map<int, int> map;// 要统计元素出现频率 
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }

        // 定义一个小顶堆，大小为k
        priority_queue<pair<int,int>,vector<pair<int,int>>,mycomparison> pri_que;

        // 用固定大小为k的小顶堆，扫面所有频率的数值
        for(auto it = map.begin();it!=map.end();it++) {
            pri_que.push(*it);
            if (pri_que.size() > k){ // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                pri_que.pop();
            }
        }

        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;
    }
};
```

# 四、串

定义

```
string s
```

常用方法

```
length() 或者 size()
append(str) : 末尾添加另一个字符串
insert(index,str) :指定位置添加字符串
erase(index,len) :指定位置删除长度为len的字符串
substr(index,len) : 返回从指定位置开始的子串
find(str,index): 从指定位置开始寻找子串
replace(index,len,str): 从指定位置开始替换长度为n的字符串
empty()
clear()
reverse(s.begin(),s.end())：反转字符串
```

### KMP算法

求Next数组（1）

```
void getNext(vector<int>& next, const string& s, int n) {
    for (int i = 1; i < n; ++i) {
        int j = next[i - 1];
        while (j != -1 && s[j + 1] != s[i]) {
            j = next[j];
        }
        if (s[j + 1] == s[i]) {
            next[i] = j + 1;
        } else {
            next[i] = -1;
        }
    }
}
```

求Next数组（2）

```
void getNext(vector<int>& next,string s){
	int i=0,j=-1;
	while(i<s.size()){
		if(j==-1 || s[i] == s[j]){
			i++;
			j++;
			next[i] = j;
		}else{
			j=next[j];
		}
	}
}
```

KMP

```
getNext(next,s2);
int i=0,j=-1;
while(i<s1.size()){
	if(j==-1||s1[i] == s2[j]){
		i++;
		j++;
		if(j == s2.size()) return i-j;
	}else{
		j= next[j];
	}
}
```

### 例题

####  1.力扣 344 反转字符串

```
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。


示例 1：

输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

题解：

双指针，一头一尾交换就是了

```
class Solution {
public:
    void reverseString(vector<char>& s) {
        int head = 0;
        int tail = s.size()-1;
        while(head < tail){
            char temp = s[head];
            s[head] = s[tail];
            s[tail] = temp;
            head++;
            tail--;
        }
    }
};
```

#### 2.反转字符串Ⅱ

```
给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
 

示例 1：

输入：s = "abcdefg", k = 2
输出："bacdfeg"
示例 2：

输入：s = "abcd", k = 2
输出："bacd"
 
```

题解：

这题需要思维反转一下，不是到2k开始对0-k的元素反转，而是对2k到k的元素进行反转

所以

2*k是下次需要反转时的起始坐标
每次反转的内容就是起始坐标到 i+k的距离
如果i+k大于n，就取n

```
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        //2*k是下次需要反转时的起始坐标
        //每次反转的内容就是起始坐标到 i+k的距离
        //如果i+k大于n，就取n
        for(int i = 0; i < s.size(); i+= (2 * k))
        {
            if(i + k < s.size())
                reverse(s.begin() + i, s.begin() + i + k);
            else
                reverse(s.begin() + i, s.end());
        }
        return s;
    }
};

```

#### 3.卡玛 53 替换数字

```
目描述
给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。
输入描述
输入一个字符串 s,s 仅包含小写字母和数字字符。
输出描述
打印一个新的字符串，其中每个数字字符都被替换为了number
输入示例
a1b2c3
输出示例
anumberbnumbercnumber
提示信息
数据范围：
1 <= s.length < 10000。
```

题解：

定义一个字符串，遍历存放，遇到数字换就是了

```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin >> s;
    string ans;
    for(char ch:s){
        if(ch >= '0' && ch <='9'){
            ans+="number";
        }
        else ans+=ch;
    }
    cout << ans;
    return 0;
}
```

#### 4.力扣 151 翻转字符串里的单词

```
给你一个字符串 s ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

 

示例 1：

输入：s = "the sky is blue"
输出："blue is sky the"
示例 2：

输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
示例 3：

输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

题解：

其实反转也可以看成先进后出，所以可以用栈的思维来转换

先遍历字符串将单词入栈

随后再挨个弹出就行了，注意加空格

```
class Solution {
public:
    string reverseWords(string s) {//先进后出，用栈
        stack<string> st;
        string ans;

        for(int i=0;i<s.size();i++){//分割单词存入栈中
            if(s[i]!=' '){
                string temp;
                while(s[i]!='\0' && s[i]!=' '){
                    temp +=s[i++];
                }
                st.push(temp);
            }
        } 

        while(!st.empty()){//栈不为空就输出栈
            ans += st.top();
            st.pop();
            if(!st.empty()) ans+=' ';
        }
        return ans;
    }
};
```

#### 5.卡玛 55 右旋转字符串

```
字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

输入描述
输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。
输出描述
输出共一行，为进行了右旋转操作后的字符串。
输入示例
2
abcdefg
输出示例
fgabcde
提示信息
数据范围：
1 <= k < 10000,
1 <= s.length < 10000;
```

题解：利用栈很简单

```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
 
int main(){
    int n;
    string s;
    string ans;
    cin >> n >> s;
    stack<char> st;
    int len = s.size();
    int i;
    for(i = len-1;i>len-n-1;i--){
        st.push(s[i]);
    }
    while(!st.empty()){
        ans+=st.top();
        st.pop();
    }
    for(i=0;i<len-n;i++){
        ans+=s[i];
    }
    cout << ans;
    return 0;
}
```

#### 6.力扣 459 重复的子字符串

```
给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

 

示例 1:

输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
示例 2:

输入: s = "aba"
输出: false
示例 3:

输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

题解：巧用next数组求最大重复的前缀长度

再用n除以前缀长度，看看能否整除；

一定要用优化next的算法，这样末尾如果不同才会是-1

```
class Solution {
public:

    void getNext(vector<int>& next,const string& s,int n){
         for (int i = 1; i < n; ++i) {
            int j = next[i - 1];
            while (j != -1 && s[j + 1] != s[i]) {
                j = next[j];
            }
            if (s[j + 1] == s[i]) {
                next[i] = j + 1;
            }
        }
    }

    bool repeatedSubstringPattern(string s) {
        int n = s.size();
        vector<int> next(n, -1);
        getNext(next,s,n);
        return next[n - 1] != -1 && n % (n - next[n - 1] - 1) == 0;
    }
};

```



# 五、哈希表

## 1、无序表

定义

```
unordered_map<int,int>map;
```

常用方法

```
insert(key, value)：向哈希映射中插入键值对。
erase(key)：从哈希映射中删除指定键对应的键值对。
find(key)：查找指定键对应的值。
size()：返回哈希映射中键值对的数量。
empty()：检查哈希映射是否为空。
```

### 例题

#### 1、力扣 242 有效的字母异位词

```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
 
```

题解：

因为本题范围只有26个字母，所以可以采用数组代替hash表，用下标代表a-z的字母

判断异位词，换句话说就是判断他们两个之间的字符是否完全相同

遍历第一个字符串，将每个元素出现次数记录下来。

再遍历第二个字符串，将每个元素出现一次减少一次

如果最后数组中有非0元素，那说明有元素没有出现（多出现了）

```
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.size()!=t.size()) return false;
        int check[27] = {0};
        for(int i=0;i<s.length();i++){
            check[s[i]-'a']++;
            check[t[i]-'a']--;
        }
        
        for(int i : check){
            if(i != 0 )return false;
        }
         return true;
    }
};
```



#### 2、力扣 349 两个数组的交集

```
给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
 
```

题解：

先将两个数组都排序，定义两个下标分别指向两个数组首地址

因为不允许重复，所以可以判定当index不为头元素的时候，前一个元素和当前元素相同，那就直接下标++后continue

当遇到两个数组中相等的元素时把他加入ans

并且因为答案的不可重复，可以直接全部++

如果数组1的元素大于数组二的元素，因为数组是排序过的，所以只要让数组二的下标++就行

小于同理

```
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<int> ans;
        if(nums1.size() == 0 || nums2.size() == 0) return ans;
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        int index1=0,index2=0;
        
        while(index1<nums1.size() && index2<nums2.size()){
            if(index1!=0&&nums1[index1] == nums1[index1-1]) {
                index1++;
                continue;
            }
            if(index2!=0&&nums2[index2] == nums2[index2-1]) {
                index2++;
                continue;
            }
            
            if(nums1[index1] == nums2[index2]) {
                ans.push_back(nums1[index1]);
                index1++;
                index2++;
            }
            else if(nums1[index1] < nums2[index2]) index1++;
            else   index2++;
        }
        
        
        return ans;
    }
};
```



#### 3、力扣 1 两数之和

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
```

题解：

很简单，将数据都存入hashmap中后，将指针指向第一个元素

我们需要找的目标就是target-第一个元素

向hashmap中找有没有这个元素，有就返回，没有继续

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> check_map;
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            // 记录每个数字的索引
            check_map[nums[i]] = i;
        }
        for (int i = 0; i < nums.size(); i++) {
            int temp = target - nums[i];
            // 检查是否存在配对
            if (check_map.count(temp) && check_map[temp] != i) {
                return {i, check_map[temp]};
            }
        }
        return ans;
    }
};

```

#### 4、力扣 15三数之和

```
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
示例 2：

输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
示例 3：

输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
 
```

题解：

其实这题可以用回溯做，但是会超时，剪枝剪不了一点

首先我们将数组排序

需要一个指针i从头到倒数第三个元素遍历（三元组，保证有两个元素空余）

因为数组是有序的 那么 i和后两个元素相加如果已经大于target了的话，那说明已经不存在符合条件的组合了，直接break

如果i和数组末尾的两个元素相加还小于target的话，那说明当前的i不可能符合条件，向后寻找更大的i，continue

我们假设（i）和末尾的元素（right）就是我们需要的元素之一，

那么我们需要的第三个元素就是0-i-right

我们设一个left，他从i的后一个元素开始遍历

那么right就是决定sum的最大值，left就是决定sum的最小值

那我们只需要移动left就可以找到目标的元素

当left>right的时候，组合就不存在了，可以继续下一个循环了

当sum比traget小的时候，left就得++

当sum大于traget的时候，right就得--

当sum等于traget的时候，我们就可以存放一个组合了。

注意题目要求不重复，那么如果left右边的元素/right左边的元素和当前的left/right相同，那就继续移动。



```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());
        int n = nums.size();

        for (int i = 0; i < n - 2; i++) {//三元组i最多到倒数第3个元素
            if (nums[i] > 0) break;
            if (i > 0 && nums[i] == nums[i - 1]) continue; 

            int traget = 0 - nums[i];
            if(nums[i+1] + nums[i+2] > traget) break;//剪枝
            if(nums[n-1] + nums[n-2] < traget) continue;
            int left = i + 1;
            int right = n - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    ans.push_back({nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) left++; //注意重复
                    while (left < right && nums[right] == nums[right - 1]) right--; 
                    left++;
                    right--;
                } else if (sum < 0) {//小于0left就右移，也不用担心相同元素，因为就算相同也是小于
                    left++;
                } else {//right同理
                    right--;
                }
            }
        }
        return ans;
    }
};

```

#### 5、力扣 18四数之和

```
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

 

示例 1：

输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
示例 2：

输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

题解：这题和三数之和相比就是多嵌套了一层

```
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for(int i = 0; i < n - 3; i++)
        {
            if (i > 0 && nums[i] == nums[i-1]) continue;

            if ((long)nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;//前4个元素就是最小的了，如果4个最小加起来还大于目标值，那就没必要看了

            if ((long)nums[i] + nums[n-1] + nums[n-2] + nums[n-3] < target) continue;//最后三个一定是最大的，如果当前元素加上最后三个还是小于目标值，那就直接continue

            for(int j = i + 1; j < n - 2; j++)
            {
                if (j > i + 1 && nums[j] == nums[j-1]) continue; //去除重复
                
                int newTarget = target - nums[i] - nums[j]; //目标值是减去i,j后的元素
                if (nums[j+1] + nums[j+2] > newTarget) break;//前两个元素就是最小的了，如果两个最小加起来还大于目标值，那就没必要看了
                if (nums[n-2] + nums[n-1] < newTarget) continue;//最后两个一定是最大的，如果当前元素加上最后两个还是小于目标值，那就直接continue
                
                int left = j + 1, right = n - 1;//下面和仨数之和一样
                while (left < right)
                {
                    long value = (long)nums[i] + nums[j] + nums[left] + nums[right];
                    if(value == target)
                    {
                        res.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while(left < right && nums[left] == nums[left+1]) left++;
                        while(left < right && nums[right] == nums[right-1]) right--;
                        left ++ ;
                        right -- ;
                    }
                    else if (value < target ) left++;
                    else right -- ;
                }     
            }
        }
        return res;
    }
};
```

#### 6、力扣 454四数相加

```
给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
 

示例 1：

输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
示例 2：

输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

题解：

这题我们要将问题换过来思考

abcd四个数相加，可以看成是 (a+b) + (c+d)

分开归纳

用两层循环遍历a，b相加的和的所有可能，存入哈希表中

同样用两层循环遍历c，d相加的和的所有可能，和哈希表中的数值对比

因为target是0，所以看看有没有相反数

有的话就ans++

```
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
            int ans=0;
            unordered_map<int,int> A_B_Sum;
            //将nums1和nums2数组中的所有和可能，计数存入哈希表中
            for(int i:nums1){
                for(int j :nums2){
                    ++A_B_Sum[i+j];
                }
            }
            //将所有nums3nums4和的可能的相反数，去哈希表中找，即可找到所有和为0的可能
            for(int i:nums3){
                for(int j:nums4){
                    if(A_B_Sum.count(-i-j)){
                        ans+=A_B_Sum[-i-j];
                    }
                }
            }
            return ans;
    }
};
```

#### 7、力扣 202快乐数

```
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

示例 1：

输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：

输入：n = 2
输出：false
```

题解：

这题的关键在于重复

当sum的重复为1时，就为真

当sum的重复为其他时，就为假

用一个哈希记录所有sum可能

如果在哈希中遇到一样的，就看时什么

如果没遇到过就加入到哈希中

```
class Solution {
public:
    // 取数值各个位上的单数之和
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    
    bool isHappy(int n) {
        unordered_map<int,int> check_map;
        while(1) {
            int sum = getSum(n);
            if (sum == 1) {
                return true;
            }
            // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
            if (check_map.count(sum) > 0) {
                return false;
            } else {
                check_map[sum] = sum;
            }
            n = sum;
        }
    }
};
```



#### 8、力扣 383赎金信

```
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

示例 1：

输入：ransomNote = "a", magazine = "b"
输出：false
示例 2：

输入：ransomNote = "aa", magazine = "ab"
输出：false
示例 3：

输入：ransomNote = "aa", magazine = "aab"
输出：true
```

题解：因为有个条件：magazine 中的每个字符只能在 ransomNote 中使用一次。

所以这题就变成了，ransomNote 中出现的字符，是不是都在magazine中出现的过

和异位词有异曲同工之处。先记录magazine 中每个字符出现的次数

然后遍历ransomNote，开始进行删减

如果哈希数组中出现了负数值，那么说明ransomNote中有magazine没有的字符

return false

```
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int cheak[27] = {0};
        for(char ch:magazine){
            cheak[ch-'a']++;
        }
        for(char ch : ransomNote){
            cheak[ch-'a']--;
        }
        for(int i: cheak){
            if(i < 0) return false;
        }
        return true;
    }
};
```



## 2、有序表

定义

```
map<int,int>map
```

常用方法

```
同上
```

判断元素是否在表中

```
map.count(val) > 0 ? true:false
```



# 六、并查集

并查集用于处理不相交集合的合并和查询操作。它主要支持两种操作：

```
查找（Find）：查找元素所属的集合（或者称为根节点）。这个操作通常用于确定两个元素是否属于同一个集合，即检查它们的根节点是否相同。

合并（Union）：将两个集合合并为一个集合。这个操作通常在查找操作之后进行，如果发现两个元素属于不同的集合，则将它们所在的两个集合合并为一个。
```

并查集通常使用一个数组来实现，数组的每个元素代表一个节点，数组的值代表该节点的父节点（或者根节点）。通过路径压缩（Path Compression）和按秩合并（Union by Rank）等优化技术，可以使得查找和合并操作的时间复杂度接近于常数。

并查集在解决一些图论和连通性问题时非常有用

###### 实现：

```
class UnionFind {
```

成员：

```
private:
    vector<int> parent; // 存储每个节点的父节点
    int count; // 集合数量
```

```
public:
```

  //构造函数：初始化并查集，每个节点都是一个单独的集合，初始时父节点指向自身

```
  UnionFind(int n) {
        count = n;
        parent.resize(n);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
```

​    // 查找函数：找到节点 p 所在集合的根节点，并进行路径压缩

```
int find(int p) {
        while (p != parent[p]) {
            parent[p] = parent[parent[p]]; // 路径压缩：将节点 p 的父节点指向父节点的父节点
            p = parent[p];
        }
        return p;
    }
```

​    // 合并函数：将节点 p 和节点 q 所在的集合进行合并

```
 void unite(int p, int q) {
        int rootP = find(p); // 找到节点 p 的根节点
        int rootQ = find(q); // 找到节点 q 的根节点
        if (rootP == rootQ) return; // 如果节点 p 和节点 q 已经在同一个集合中，则不进行合并操作
        parent[rootP] = rootQ; // 将节点 p 的根节点的父节点指向节点 q 的根节点
        count--; // 集合数量减少一个
    }
```

​    // 获取当前集合数量

```
 int getCount() {
        return count;
    }
```

```
};
```

# 七、二叉树

## Ⅰ、种类

#### 1、满二叉树

```
		root
left  / 	\ right
	node    node
	/  \    /  \
node  node node node
```

```
深度为k的满二叉树，结点数量为
2^k - 1；
```

### 2、完全二叉树

除了底层没满，其他都满，并且底层必须从左到右连续

满二叉树 是 完全二叉树

堆也是通过完全二叉树实现

```
		root
left  / 	\ right
	node    node
	/  \    /  \
node  node 
```

### 3、二叉搜索树

有顺序

所有结点都满足 ：一个结点的左子树都小于它，右子树都大于它

搜索一个结点的时间复杂度是 log n

```
		6
left  / 	
	  3      
	/  \    
   1   4   
```

### 4、平衡二叉搜索树

左子树和右子树的高度绝对值不超过 **1**

常见使用平衡二叉搜索树的数据结构 ：map 、set 、multimap 、multiset

使用平衡二叉搜索树的数据结构 插入搜索的时间复杂度都是 log n

```
		root
left  / 	\ right
	node    node
	/  \    /  \
node  node 
/
node
```

## Ⅱ、存储方式

### 1、链式存储

用链表实现

### 2、线性存储

用数组实现

```
		a(0)
left  / 	\ right
	b(1)    c(2)
	/  \    /  \
d(3)  e(4) f(5) g(6)

num[] ="abcdefg";

某个结点的左子树
2*i+1

某个结点的右子树
2*i+2
```

## Ⅲ、二叉树的遍历

### 1、深度优先遍历

###### 前序遍历

根左右

###### 中序遍历

左根右

###### 后序遍历

左右根

递归 /迭代（用栈来模拟递归）

### 2、广度优先遍历

层次遍历（用队列来模拟）

## Ⅳ、定义

###### 结构体

```
struct TreeNode{
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int x): val(x),left(nullptr),right(nullptr){}
};
```

###### 递归前序遍历（中后遍历就是换个顺序）

```
// 递归前序遍历二叉树	深度优先搜索
void firstTravel(TreeNode *root,vector<int>& ans){
        if(root == nullptr) return;
        ans.push_back(root->val);
        firstTravel(root->left,ans);
        firstTravel(root->right,ans);
}
```

###### 迭代前序遍历

```
vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;
        if(root) st.push(root);
        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            ans.push_back(node->val);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);
        }
        return ans;
}
```

###### 迭代中序遍历

```
vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;
        TreeNode* curr = root;
        while(curr||!st.empty()){
            while(curr){	//先遍历左子树
                st.push(curr);
                curr = curr->left;
            }
            
            curr = st.top();//获得根
            st.pop();
            ans.push_back(curr->val);
            
            curr = curr->right;//遍历右子树
        }
        return ans;
    }
```

###### 迭代后序遍历

```
vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;
        TreeNode* prev = nullptr; //prev 的作用是用来追踪上一个访问的节点。它主要用于判断当前节点的右子节点是否已经被访问过。
        while (root || !st.empty()) {
            while (root) {	//遍历左子树
                st.push(root);
                root = root->left;
            }
            
            root = st.top();//遍历右子树
            if (root->right && root->right != prev) {
                root = root->right;
            } else {//没有右子树,或者右子树已经遍历过了，再获取根
                ans.push_back(root->val);
                st.pop();
                prev = root;
                root = nullptr;
            }
        }
        return ans;
    }
```

###### 层次遍历

```
vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        queue<TreeNode*> q1;
        if(root == nullptr) return ans;
        q1.push(root);
        
        while(!q1.empty()){
            int len = q1.size();	//每一层的结点数，就是当前队列里的元素数量
            ans.push_back(vector <int> ());//这一行代码创建了一个空的向量，并将其添加到结果数组 当前层的节点值创建了一个新的分组
            for (int i = 0; i < len; i++) {
                auto node = q1.front(); q1.pop();
                ans.back().push_back(node->val);	//将当前节点的值添加到这个刚刚添加的向量中
                if (node->left) q1.push(node->left);
                if (node->right) q1.push(node->right);
            }
        }
        return ans;
 }
```



## Ⅴ、例题

### 1、 力扣 226 翻转二叉树

```
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

 

示例 1：



输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
示例 2：



输入：root = [2,1,3]
输出：[2,3,1]
示例 3：

输入：root = []
输出：[]
```

题解：

从根节点开始左右互换，递归往下，直到根结点为空

```
void overturn(TreeNode* root){
        if(!root) return;
        TreeNode* node;
        node = root->left;
        root->left = root->right;
        root->right = node;
        if(root->left) overturn(root->left);
        if(root->right) overturn(root->right);
    }
TreeNode* invertTree(TreeNode* root) {
    	overturn(root);
    	return root;
}
```

### 2、 力扣 101 对称二叉树

```
给你一个二叉树的根节点 root ， 检查它是否轴对称。

 

示例 1：


输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：


输入：root = [1,2,2,null,3,null,3]
输出：false
 

提示：

树中节点数目在范围 [1, 1000] 内
-100 <= Node.val <= 100
```

题解：

本题也可以看成两个二叉树是否可以翻转后相等

也可以看成是同时遍历两个二叉树

因为本题我们需要收割子树，最后再判断根，所以用后序遍历

递归-后序遍历：

```
bool compare(TreeNode* left,TreeNode* right){
        if(left == NULL && right !=NULL) return false; 	//如果左子树为空，右子树不为空，不对称
       
        else if(left != NULL && right ==NULL) return false;	//同理如果右子树为空，左子树不为空，不对称
        
        else if(left == nullptr && right == nullptr) return true;//如果两边都空，那就是对称的
        
        else if(left->val != right->val) return false;	//如果都不为空，值却不一样，那也是不对称的
        
        return compare(left->left,right->right) && compare(left->right,right->left); 
        //需要比较的是左子树的左子树和右子树的右子树（外圈），左子树的右子树和右子树的左子树（内圈）
    }

    bool isSymmetric(TreeNode* root) {
        return compare(root->left,root->right);
    }
```

迭代

```
初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。
```

```
bool check(TreeNode* root1,TreeNode* root2){
        queue<TreeNode*> q1;
        q1.push(root1);
        q1.push(root2);
        while(!q1.empty()){
            TreeNode* node1 = q1.front();
            q1.pop();
            TreeNode* node2 = q1.front();
            q1.pop();
            if (!node1 && !node2) continue;		//两个同时为空就继续看其他结点
            if (!node1 || !node2) return false;	//有一个不为空就说明不对称
            if (node1->val != node2->val) return false;	//值不相等就不对称

            q1.push(node1->left);q1.push(node2->right);	//检查外圈
            q1.push(node1->right);q1.push(node2->left);	//检查内圈
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
```

### 3、 力扣103 二叉树的最大深度

```
给定一个二叉树 root ，返回其最大深度。

二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：3
示例 2：

输入：root = [1,null,2]
输出：2
```

###### 什么是深度？什么是高度？

```
深度是二叉树里从根节点到某个节点的唯一路径的长度	（先序遍历求）

高度是二叉树种任意一个结点到叶子节点的最长距离 （后序遍历求）
```

本题求的虽然是二叉树的最大深度

但其实是求根节点的最大高度

所以用后序遍历



递归去求左子树和右子树最大深度

根的深度就是子树最大深度+1；

```
int maxDepth(TreeNode* root) {
    if (!root) return 0;
       return 1+max(maxDepth(root->left),maxDepth(root->right));
    }
```

### 4、 力扣 111 二叉树的最小深度

```
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：2
示例 2：

输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

本题用迭代法更简单

```
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode*> q1;
        q1.push(root);
        int deep =1;
        while(!q1.empty()){
            int len = q1.size();
            for(int i=0;i<len;i++){
                TreeNode* node = q1.front();
                q1.pop();
                if(node->left) q1.push(node->left);
                if(node->right) q1.push(node->right);
                if(!node->left && !node->right) return deep;
            }
            deep++;
        }
        return deep;
    }
};
```

当然递归也能做，加两个如果左右有一个为空，那么就返回不为空的那个子树长度＋1

```
int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(root->left == nullptr && root->right) return 1+minDepth(root->right);
        if(root->left && root->right == nullptr) return 1+minDepth(root->left);
        return min(minDepth(root->left),minDepth(root->right))+1;
    }
```

### 5、 力扣 222 完全二叉树的结点个数

```
给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

 

示例 1：


输入：root = [1,2,3,4,5,6]
输出：6
示例 2：

输入：root = []
输出：0
示例 3：

输入：root = [1]
输出：1
```

题解：

普通二叉树直接遍历计数就行，此处用的是后序遍历

```
return getNum(root->left)+getNum(root->right)+1;
```

但这题是完全二叉树，我们可以利用他的性质

一个深度为k的满二叉树，结点数量为2^k-1

而完全二叉树是底层从右往左缺少结点的二叉树。所以如果可以证明左子树是满二叉树，能快一点

```
class Solution {
public:

    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        
        TreeNode *left = root,*right = root;
        int DeepLeft=0,DeepRight = 0;
        while(left){
            left=left->left;
            DeepLeft++;
        }
        while(right){
            right = right->right;
            DeepRight++;
        }
        if(DeepLeft == DeepRight) return pow(2,DeepLeft)-1;
        else
            return countNodes(root->left) + countNodes(root->right) +1;
        
        return 0;
    }
};
```

