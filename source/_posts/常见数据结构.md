---
title: 常见数据结构
categories: 力扣
date: 2024-03-16 19:28:45
tags: 力扣
top: true
---

# 常见数据结构

<!--more-->

# 特殊、数组/集合

### 数组

特点：连续的空间

定义

```
int n[10];
int n[10][10]//死空间

int* n = (int*)malloc(sizeof(int) * 10);
int** n = (int**)malloc(10 * sizeof(int*)); // 分配行指针数组
for (int i = 0; i < 10; ++i) {
    n[i] = (int*)malloc(10 * sizeof(int)); // 分配每行的列数
}//指针,可改变大小,但需要手动释放

vector<int>n;
vector<vector<int>>n//容器，动态大小，方便
```

常用方法（ vector）

```
push_back(val);
pop_back();
sort(n.begin(),n.end());
```

### 集合

###### set

在内部使用红黑树等数据结构来维护元素的顺序，是一种有序集合。

定义

```
set<int> mySet
```

常用方法

```
find(val)
insert(val)
erase(val) //删除
size()
empty()
clear()
```

###### multiset

允许 重复元素存在

定义

```
multiset<int> multiSet
```

## 例题

### 1、力扣	704 二分查找（双指针）

```
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例 2:
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

解法：没啥好说的，记就完事了

注意开闭的区别

开区间的left和right就直接等于mid

```
int search(vector<int>& nums, int target) {
        int left =0;
        int right = nums.size()-1;

        while(left <= right){
            int mid = (left+right)/2;
            if(nums[mid] == target) return mid;
            else if(nums[mid] < target) left = mid+1;
            else right = mid - 1;
        }
        return -1;
    }
```

### 2、力扣 27 移除元素（双指针）

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1：

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

解法：双指针

定义一个快指针用来遍历，一个慢指针用来存放结果

如果快指针指到的元素是我们需要的，慢指针就存放快指针当前存放的元素，并且向前进一步

```
int removeElement(vector<int>& nums, int val) {
        int slow =0;
        for(int fast=0;fast<nums.size();fast++){
            if(nums[fast]!=val) nums[slow++] = nums[fast];
        }
        return slow;
    }
```

### 3、力扣 977 有序数组的平方（双指针）

```
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
示例 2：

输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

解法：

定义头尾双指针，还需要一个存放用的指针

因为在本题中是已经有序的带负数的数组，那么它平方后的趋势就是头尾大，中间小

所以我们可以用两个指针一头一尾，判定，将大的存放到ans后面，存放过的指针就--，小的不动

```
vector<int> sortedSquares(vector<int>& nums) {
        int head=0;
        int tail = nums.size()-1;
        
        vector<int>ans(tail+1);
        int ans_tail = tail;

        while(ans_tail >=0 ){
            int num1 = nums[head]*nums[head];
            int num2 = nums[tail]*nums[tail];
            if(num1 > num2){
                ans[ans_tail] = num1;
                head++;
            }else{
                ans[ans_tail] = num2;
                tail--;
            }
            ans_tail--;
        }
       
        return ans;
    }
```

### 4、 力扣 209 长度最小的子数组（滑动窗口）

```
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 连续
子数组
 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

解法：

注意审题，这题要求的是大于等于

这题可以用到一个滑动窗口的思想

从第一个元素开始累加，一直到满足条件为止是第一个长度大小。

此时先将下标定在这里。从开头开始减去元素，看看是否还满足条件。

期间每次操作后都记录长度大小的最小值

如此反复一直到数组末尾即可

```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left=0;
        int ans = INT_MAX;
        int sum=0;
        for(int right=0;right<nums.size();right++){
            sum+=nums[right];
            while(sum >= target){
                ans = min(ans,right-left+1);
                sum-=nums[left];
                left++;
            }
        }
        if (ans == INT_MAX) return 0;
        return ans;
    }
};
```

### 5、力扣 54 螺旋矩阵（模拟遍历）

```
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：


输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

解法：模拟它行走的路程

每次走完后可以理解为缩圈

走完第一行就把第一行剪掉就是了（top++）；

走完最后一列就把最后一列剪掉（right--）；

走完最后一行就把底端剪切（down--）；

走完第一列再把第一列剪除（left++）；

直到上边界遇到下边界，或者左边界碰上右边界

```
vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>ans;
        if(matrix.empty()) return ans;
        int left =0;
        int top =0;
        int right = matrix[0].size()-1;
        int down = matrix.size()-1;

        while(true){
            for(int i=left;i <= right;i++)//上边界左到右
                ans.push_back(matrix[top][i]);
            if(++top > down) break;

            for(int i = top;i<=down;i++)//右边界上到下
                ans.push_back(matrix[i][right]);
            if(--right < left) break;
            
            for(int i=right;i>=left;i--){//底边界右到左
                ans.push_back(matrix[down][i]);
            }
            if(--down < top) break;

            for(int i=down;i>=top;i--){//左边界从下到上
                ans.push_back(matrix[i][left]);
            }
            if(++left > right) break;
        }
        return ans;
    }
```



# 一、链表

特点：每个结点都有一个指向下一个结点的指针

定义

```
ListNode* list = new ListNode()
```

## 实现（c++中需要手动实现）

```
struct ListNode {// 定义链表节点结构体
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {} //初始化参数
    
    ListNode() : val(0), next(nullptr) {}//可选
	ListNode(int x, ListNode *next) : val(x), next(next) {}//可选
};
```

### 在指定位置插入链表

```
ListNode* insert(ListNode* head,int val,int index){
	ListNode* sp_head = new ListNode(0);
	sp_head->next = head; 
	ListNode* newnode = new ListNode(val);
	ListNode* pre = sp_head;
	while(--index && pre->next!=nullptr){
		pre = pre->next;
	}
	if(index >0 ) return head;
	newnode->next = pre->next;
	pre->next = newnode->next;
	
	head = sp_head->next;
    delete sp_head;
    return head;
}
```

## 例题

### 1、力扣 203 移除链表元素

```
给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
 

示例 1：


输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
示例 2：

输入：head = [], val = 1
输出：[]
示例 3：

输入：head = [7,7,7,7], val = 7
输出：[]
```

题解

加个特殊头节点防止在头节点进行修改，一直遍历到需要删除的结点的前一个结点，直接next = next->next就行了



```
ListNode* removeElements(ListNode* head, int val) {
        ListNode* sp_head = new ListNode(0);
        sp_head->next = head;
        ListNode* pre = sp_head;
        while(pre->next){
            if(pre->next->val == val){
                ListNode* temp = pre->next;
                pre->next = pre->next->next;
                delete temp;
            }else{
                pre = pre->next;
            }
        }
        return sp_head->next;
    }
```



### 2、 力扣 707 设计链表

```
你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。

实现 MyLinkedList 类：

MyLinkedList() 初始化 MyLinkedList 对象。
int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。
void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。
void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。
 

示例：

输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
```

题解

​	私有成员一个头节点和一个数量统计，方便在末尾进行修改，添加和删除都遍历到需要元素的前一个元素

```
class MyLinkedList {

private:
    int size;
    ListNode *head;
public:
    MyLinkedList() {
        this->size = 0;
        this->head = new ListNode(0);
    }
    
    int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode *cur = head;
        for (int i = 0; i <= index; i++) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        size++;
        ListNode *pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred->next;
        }
        ListNode *toAdd = new ListNode(val);
        toAdd->next = pred->next;
        pred->next = toAdd;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode *pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred->next;
        }
        ListNode *p = pred->next;
        pred->next = pred->next->next;
        delete p;
    }
};
```

### 3、 力扣 206 反转链表

```
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 

示例 1：


输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
示例 2：


输入：head = [1,2]
输出：[2,1]
示例 3：

输入：head = []
输出：[]
 
```

题解：利用头插法的原理逆序（迭代法）

```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* L2 = new ListNode(0);
        L2->next = NULL;
        
        while(head){
            ListNode* temp= new ListNode(head->val);
            temp->next = L2->next;
            L2->next = temp;
            head = head->next;
        }
        return L2->next; 
    }
};
```

递归

原理

```
2->1->nullptr 

2->1->2

2->nullptr

1->2->nullptr
```



```
ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
```



### 4、 力扣 24 两两交换链表中的元素

```
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
示例 3：

输入：head = [1]
输出：[1]
```

题解：

添加一个特殊头节点，方便在头部进行操作

定义三个指针，

一个用来记录需要交换的两个元素前一个结点（index）

一个用来记录需要交换的第一个结点（first）

一个用来记录第二个结点（second）

每次交换完后，让index向后移动两位 也就是移动到 交换的第一个结点（first）处

```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;
        
        ListNode* null_head = new ListNode(0,head);
        ListNode* index = null_head;
        
        while(index->next != NULL && index->next->next != NULL){
            ListNode* first=index->next;
            ListNode* second=index->next->next;
            
            index->next = second;
            first->next = second->next;
            second->next = first;
            index = first;
            
        }
        return null_head->next;
    }
};
```

### 5、力扣 19 删除链表的倒数第N个结点

```
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。


示例 1：


输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
示例 2：

输入：head = [1], n = 1
输出：[]
示例 3：

输入：head = [1,2], n = 1
输出：[1]
```

题解：

定义一个特殊头节点，方便于顶端操作

定义快慢两个指针，当快指针走够n步后，慢指针开始走。当快指针走到末尾，慢指针指向的元素就是第n个元素

为了方便删除，也可以让快指针走到倒数第二个元素，这样慢指针走到的就是第n-1个元素。

```
ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return head;
        ListNode* sp_head = new ListNode(0);
        sp_head->next = head;
        ListNode* slow = sp_head;
        ListNode* fast = sp_head;
        while(fast->next){
            fast = fast->next;
            n--;
            if(n <0)
                slow = slow->next;
        }
        slow->next = slow->next->next;
        return sp_head->next;
    }
```

### 6 、力扣 142 环形链表 Ⅱ

```
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

 

示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

题解：

首先明确，定义快慢指针，一个走的快，一个走的慢，如果有环，那一定会重逢。

当重逢的时候就证明了有环的存在，问题就是如何寻找环的入口了

我们假设 （从左到右）

```
从起点到环入口的距离为x

入口到重逢地点的距离为y

重逢地点到入口的距离为z
```

```
慢指针走过的路即为 2*（x+y） （因为慢指针的速度是快指针的一半）

快指针走过的路即为 x+（y+z）*n +y

等式连接 约分 可得 x = n*(y+z) - y
x = ny +nz -y
x = (n-1)y + nz
x = (n-1)y + (n-1+1)*z
x = (n-1)y + (n-1)z + z
x = (n-1)(y+z) + z
```

我们可以发现，当n==1的时候，x是等于z的

也就是说，当一个指针从起点开始移动，一个指针从重逢地点开始移动，必会在入口处重逢

所以当快慢指针重逢时，再声明两个指针（index1和index2）在头部和重逢部 移动

当index1 == index2 的时候，环的入口也就找到了

```
ListNode *detectCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if(slow == fast){
                ListNode* index1 = head;
                ListNode* index2 = fast;
                while(index1!=index2){
                    index1=index1->next;
                    index2=index2->next;
                }
                return index1;
            }
        }
        return nullptr;
    }
```



# 二、栈

特点 ：先进后出

入栈顺序 ：a[0],a[1],a[2]

出栈顺序 ：a[2],a[1],a[0]

定义

```
stack<int> st;
```

常用方法

```
push(val);
pop();
top();
empty();
size();
```

## 例题

### 1、力扣 232 用栈实现队列

```
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
```

题解

用两个栈来模拟，一个栈用来入，一个栈用来出。

先进后出，先进后出 ==》先进先出

```
class MyQueue {
public:

    stack<int> InSt,OutSt;
    
    void in_too_out(){
        while(!InSt.empty()){
            OutSt.push(InSt.top());
            InSt.pop();
        }
    }
    
    MyQueue() {

    }
    
    void push(int x) {
        InSt.push(x);
    }
    
    int pop() {
       if(OutSt.empty()) {
        in_too_out();   
       }
        int x = OutSt.top();
        OutSt.pop();
        return x;
    }
    
    int peek() {
        if(OutSt.empty()){
            in_too_out();    
        }
        
        int x = OutSt.top();
        return x;
    }
    
    bool empty() {
        return InSt.empty()&&OutSt.empty();
    }
};
```

### 2、力扣 20 有效的括号

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
 

示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false
```

题解

利用栈来做

左括号入队，右括号判定

合法栈顶弹出，不合法直接return false

若栈为空，又遇到右括号，说明缺少左括号，直接报错

若遍历完了，栈还不为空，说明缺少右括号，报错

```
bool check(char ch1,char ch2){
        if(ch1 == '(' && ch2 == ')' ) return true;
        if(ch1 == '[' && ch2 == ']' ) return true;
        if(ch1 == '{' && ch2 == '}' ) return true;
        return false;
    }

    bool isValid(string s) {
        stack<char>st;
        for(char ch:s){
            if(st.empty() && (ch == ')' || ch =='}' || ch == ']') )
                return false;
            if(ch == '(' || ch == '{' || ch == '[')
                st.push(ch);
            else{
                if(!check(st.top(),ch)) return false;
                st.pop();
            }
        }
        return st.empty();
    }
```

### 3、力扣 1047 删除字符串中的所有相邻重复项

```
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
 
```

题解：

和括号大同小于，栈处理，同等就出栈，不同就入栈，最后反转一下出栈后的字符串就行

```
string removeDuplicates(string s) {
        string st;
        for(char ch:s){
            if(st.empty() || st.back()!=ch)
                st.push_back(ch);
            else
                st.pop_back();
        }
        return st;
    }
```

### 4、力扣 150 逆波兰表达式求值

```
给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

注意：

有效的算符为 '+'、'-'、'*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示。
```

题解：

由于本体是后缀表达式，所以不用考虑符号的优先级

遇到数字就压入，遇到符号就连续弹出，计算，注意后弹出的作为第一个元素

计算完后将结果继续压入

最后栈内的数字就是结果

```
int evalRPN(vector<string>& tokens) {
        stack<int>st;

        for (const string& s : tokens) {
        if (s == "+" || s == "-" || s == "*" || s == "/") {
            int num2 = st.top();
            st.pop();
            int num1 = st.top();
            st.pop();
            if (s == "+")
                st.push(num1 + num2);
            else if (s == "-")
                st.push(num1 - num2);
            else if (s == "*")
                st.push(num1 * num2);
            else if (s == "/")
                st.push(num1 / num2);
        } else {
            st.push(stoi(s));
        }
    }
        return st.top();
    }
```

## 衍生结构：单调栈

定义

```
栈中的元素单调增加/减少

存放的是下标

适合求左边/右边 第一个比他 大/小 的元素
```

### 例题

#### 1、力扣 739.每日温度

```
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

解法：

1、本题可以看作是求一个元素右边第一个比他大的元素，

​	使用单调递增(**从栈顶往栈底**)的单调栈

2、遍历数组，将元素存入栈中，初次直接入栈，若即将入栈的元素（即下边为当前的i的元素）小于等于栈顶元素，直接压入

3、若即将入栈的元素大于栈顶元素，进入循环判定，直到栈内为空和栈内没有元素大于他，一一计算差值（i-st.top）并全部弹出

4、将最大的元素继续入栈

```
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> st;
        
        for(int i=0;i<n;i++){
            while(!st.empty() && temperatures[i] > temperatures[st.top()]){ 
                ans[st.top()] = i-st.top(); 
                st.pop();
            }
            st.push(i);
        }
        return ans;    
    }       
};
```

#### 2、力扣 84.矩形中最大的面积

```
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形面积为 10
```

解法：

1、本题思路是锁定高度求底边最长，因此可以看作是找一个元素左边以及右边第一个小于当前元素的元素下标距离，所以使用单调栈

2、因为是小于，所以使用递减的单调栈

3、为了方便操作，在数组的收尾都加上0，这样最左边和最右边都有一个最小的终结值。

4、如果相同或者大于栈顶元素就将他压入

5、如果小于栈顶元素就开始进入循环计算

6、当前的元素就是栈顶元素，也就是锁定的高

7、左边第一个比他小的元素就是栈顶的第二个元素

8、右边第一个比他小的元素就是即将入栈的元素

9、因为存储的是下标，所以底边长为右减左减1；

10、将当前的元素压入，做下次对比。

```
//找左边和右边第一个比他小的
    int largestRectangleArea(vector<int>& heights) {
        
        heights.insert(heights.begin(),0);
        heights.push_back(0);
        
        stack<int>st;
        st.push(0);
        int ans = 0;
        
        for(int i=1;i<heights.size();i++){
            while(!st.empty() && heights[i] < heights[st.top()]){
                int h_index = st.top();//高
                st.pop();
                int left = st.top();
                int right = i;
                ans = max(ans,heights[h_index]*(right-left-1));
            }
            st.push(i);
        }
        return ans;
    }
```

#### 3、力扣 496 下一个更大的元素Ⅰ

```
nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。
```

解法：

1、题目明示是右边下一个更大的元素，所以确定是递增单调栈，将结果存储至ans数组，ans默认值为-1，大小和子数组大小一致

2、因为需要求的是子数组，为了方便确认目前求的元素是否属于子数组，用unordered_map来存储子数组的元素<key：元素，value：下标>

3、如果当前元素大于栈顶元素，并且他属于子数组（map中存在），那么就将它存入ans数组，否则直接不要。

```
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack <int> st;
        vector<int> ans(nums1.size(),-1);
        if(nums1.size() == 0) return ans;
        unordered_map<int,int>checkMap;
        for(int i=0;i<nums1.size();i++) checkMap[nums1[i]] = i;
        
        for(int i=0;i<nums2.size();i++){
            while(!st.empty()&&nums2[i] > nums2[st.top()]){
                if(checkMap.count(nums2[st.top()]) > 0){//如果他在map里存在,就执行操作
                    int index = checkMap[nums2[st.top()]];
                    ans[index] = nums2[i];
                }
                st.pop();
            }
            
            st.push(i);
        }
        
        return ans;
    }
};
```

#### 4、力扣503 下一个更大的元素Ⅱ

```
给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。

数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。
```

解法：

1、下一个更大->递增单调栈

2、首尾相连的数组我们可以用求余的方法，i的取值范围扩展到2n即可

```
vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int>st;
        vector<int> ans(nums.size(),-1);
        st.push(0);
        int n = nums.size();
        for(int i=1;i< n*2;i++){
            int index = i%n;
            while(!st.empty() && nums[index] > nums[st.top()]){
                ans[st.top()] = nums[index];
                st.pop();
            }
            st.push(index);
        }
        return ans;
    }
```

#### 5、力扣42 接雨水

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

解法：

1、该题可以看成求当前元素左边第一个比他大的和右边第一个比他大的元素，所以用递增单调栈

2、水槽的面积就是左边第一个比他大的到右边第一个比他大的距离 乘以 左右两边最小的那一个高度

3、因为是递增的单调栈，所以栈顶元素就是当前元素，即将入栈的就是右边第一个比他大的，栈内第二个元素就是左边第一个比他大的

```
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        stack<int> st;
        
        for (int i = 0; i < height.size(); i++) {
            while (!st.empty() && height[i] > height[st.top()]) {
                int mid = st.top();
                st.pop();
                if (st.empty()) break; // 无法形成容器，退出循环                
                int left = st.top();
                int right = i;
                int h = min(height[left], height[right]) - height[mid];
                int w = right - left - 1;
                ans += h * w;
            }
            st.push(i);
        }
        
        return ans;
    }
};

```



# 三、队列

特点：先进先出

入队顺序 ：a[0],a[1],a[2]

**rear** -------------------------------- front

​			a[2]	  a[1]	 a[0]

**rear** -------------------------------- front



出队顺序 ：a[0],a[1],a[2]

rear -------------------------------- **front**

​															a[2]	  a[1]	 a[0]

rear -------------------------------- **front**

## 1、单端队列

定义

```
queue<int> q1
```

常用方法

```
push(val);
pop();
front();
back();
empty();
size();
```



#### 例题、力扣 225 用队列实现栈

```
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 

注意：

你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
 
```

题解

只需要使用一个队列。在需要出栈的时候，循环出队入队size-1次，便是栈顶元素（其实就是队尾）

```
class MyStack {
public:
    queue<int> q1;
    
    void find_end(){
        for(int i=0;i<q1.size()-1;i++){
            int x = q1.front();
            q1.pop();
            q1.push(x);
        }
    }
    
    MyStack() {

    }
    
    void push(int x) {
        q1.push(x);
    }
    
    int pop() {
        if(!q1.empty()){
            find_end();
        }
        int x = q1.front();
        q1.pop();
        return x;
    }
    
    int top() {
        int x =q1.back();
        return x;
    }
    
    bool empty() {
        return q1.empty();
    }
};
```



## 2、双端队列

定义

```
deque<int> q1;
```

常用方法

```;
push_front(val);
push_back(val);
pop_front(val);
pop_back(val);
front();
back();
empty();
size();
```

### 衍生类型1：单调队列

定义

```
遇到比当前元素 大（小）的，就全部出队

遇到小的就加到最后

当 下标 超出范围弹出

存放的是下标

求滑动窗口中的 最大值
```

#### 例题、力扣 239 滑动窗口最大值

```
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]
 
```

题解：

使用单调队列（双端队列）实现滑动窗口

单调队列内存放的是数组元素的下标

只保留从队首到队尾的从大到小元素

如果最大元素的下标，小于i-k+1，就将他出队

如果遇到比当前最大元素还要大的，就将队内全部清空，因为不可能成为最大值

```
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q1;
        vector<int> ans;
        for (int i = 0; i < nums.size(); ++i) {
            // 删除队列中不在当前窗口内的元素
            if (!q1.empty() && q1.front() < i - k + 1) {
                q1.pop_front();
            }
            
            // 删除队列中比当前元素小的元素，因为它们不可能成为窗口中的最大值
            while (!q1.empty() && nums[q1.back()] < nums[i]) {
                q1.pop_back();
            }
            
            // 将当前元素的索引加入队列
            q1.push_back(i);
            // 如果窗口已经形成，记录窗口中的最大值
            
            if (i >= k - 1) {
                ans.push_back(nums[q1.front()]);
            }
            
        }
        return ans;
    }
};
```

大顶堆法

```
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int, int>> q1;
        vector<int> ans;

        for (int i = 0; i < nums.size(); i++) {
            while (!q1.empty() && q1.top().second <= i - k) // 移除超出窗口范围的元素
                q1.pop();
            q1.push({nums[i], i});
            if (i >= k - 1) // 当窗口大小达到 k 时，将队列的顶部元素加入结果数组
                ans.push_back(q1.top().first);
        }

        return ans;
    }
```

### 衍生类型2：顶堆（优先队列）

定义：

```
 priority_queue<数据类型,存储数据用的容器,自定义比较方法所在的类>
```

```
顶堆（或最大堆）是一种特殊的二叉堆数据结构，其中每个节点的值都大于或等于其子节点的值。顶堆的根节点（顶部节点）是堆中的最大值。

优先队列通过堆的性质，特别是顶堆的性质，来保证队列中元素的有序性。当你向优先队列插入元素时，它会根据一定的优先级规则将元素放置在适当的位置，以保持堆的顶部是最大元素。因此，通过使用顶堆，优先队列可以实现高效的元素插入和删除操作，并且始终能够快速地访问最大元素。

适合求前k个高（低）频词
```

实现

```
	// 小顶堆，求前k个高频词
    class mycomparison {//通过重载operator方法来实现自定义排序
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {//它会根据这个比较函数的逻辑来维护队列的顺序
            return lhs.second > rhs.second;
        }
    };
    
    // 定义一个小顶堆，大小为k
    priority_queue<pair<int,int>,vector<pair<int,int>>,mycomparison> pri_que;
```

```
在 C++ 中，priority_queue 默认使用的是大顶堆，如果你想要使用小顶堆，需要通过指定比较器来实现。在我之前的代码中，我使用了默认的 less 比较器来实现大顶堆，以获取最大元素。

关于重载 operator() 的问题，对于优先队列（priority_queue）来说，并不需要重载 operator()。因为在优先队列中，需要比较元素大小的是队列中的元素，而不是比较器对象本身。所以你可以通过传递一个比较器对象来指定元素的比较方式，而不需要重载 operator()。
```

#### 例题、力扣 347 前K个高频元素

```
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]
```

题解：

使用哈希表记录出现的频率

使用优先队列（小顶堆）找出频率最高的前k个数值

```
class Solution {
public:
    // 小顶堆，求前k个高频词
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    
    vector<int> topKFrequent(vector<int>& nums, int k) {
        
        unordered_map<int, int> map;// 要统计元素出现频率 
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }

        // 定义一个小顶堆，大小为k
        priority_queue<pair<int,int>,vector<pair<int,int>>,mycomparison> pri_que;

        // 用固定大小为k的小顶堆，扫面所有频率的数值
        for(auto it = map.begin();it!=map.end();it++) {
            pri_que.push(*it);
            if (pri_que.size() > k){ // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                pri_que.pop();
            }
        }

        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;
    }
};
```

# 四、串

定义

```
string s
```

常用方法

```
length() 或者 size()
append(str) : 末尾添加另一个字符串
insert(index,str) :指定位置添加字符串
erase(index,len) :指定位置删除长度为len的字符串
substr(index,len) : 返回从指定位置开始的子串
find(str,index): 从指定位置开始寻找子串
replace(index,len,str): 从指定位置开始替换长度为n的字符串
empty()
clear()
reverse(s.begin(),s.end())：反转字符串
```

### KMP算法

求Next数组（1）

```
void getNext(vector<int>& next, const string& s, int n) {
    for (int i = 1; i < n; ++i) {
        int j = next[i - 1];
        while (j != -1 && s[j + 1] != s[i]) {
            j = next[j];
        }
        if (s[j + 1] == s[i]) {
            next[i] = j + 1;
        } else {
            next[i] = -1;
        }
    }
}
```

求Next数组（2）

```
void getNext(vector<int>& next,string s){
	int i=0,j=-1;
	while(i<s.size()){
		if(j==-1 || s[i] == s[j]){
			i++;
			j++;
			next[i] = j;
		}else{
			j=next[j];
		}
	}
}
```

KMP

```
getNext(next,s2);
int i=0,j=-1;
while(i<s1.size()){
	if(j==-1||s1[i] == s2[j]){
		i++;
		j++;
		if(j == s2.size()) return i-j;
	}else{
		j= next[j];
	}
}
```

### 例题

####  1.力扣 344 反转字符串

```
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。


示例 1：

输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

题解：

双指针，一头一尾交换就是了

```
class Solution {
public:
    void reverseString(vector<char>& s) {
        int head = 0;
        int tail = s.size()-1;
        while(head < tail){
            char temp = s[head];
            s[head] = s[tail];
            s[tail] = temp;
            head++;
            tail--;
        }
    }
};
```

单指针

```
 void reverseString(vector<char>& s) {
        int len = s.size();
        for(int i=0;i<len/2;i++){
            char ch = s[i];
            s[i] = s[len-i-1];
            s[len-i-1] = ch;
        }
    }
```



#### 2.力扣 541 反转字符串Ⅱ

```
给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
 

示例 1：

输入：s = "abcdefg", k = 2
输出："bacdfeg"
示例 2：

输入：s = "abcd", k = 2
输出："bacd"
 
```

题解：

这题需要思维反转一下，不是到2k开始对0-k的元素反转，而是对2k到k的元素进行反转

所以

2*k是下次需要反转时的起始坐标
每次反转的内容就是起始坐标到 i+k的距离
如果i+k大于n，就取n

```
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        //2*k是下次需要反转时的起始坐标
        //每次反转的内容就是起始坐标到 i+k的距离
        //如果i+k大于n，就取n
        for(int i = 0; i < s.size(); i+= (2 * k))
        {
            if(i + k < s.size())
                reverse(s.begin() + i, s.begin() + i + k);
            else
                reverse(s.begin() + i, s.end());
        }
        return s;
    }
};

```

双指针法

```
string reverseStr(string s, int k) {
        int start=0;
        int fast=0;
        int len = s.size();

        while(fast+2*k <= len){
            fast = start + 2*k;
            reverse(s.begin()+start,s.begin()+start + k);
            start = fast;
        }
        
        len - fast < k ? reverse(s.begin()+fast,s.end()) : reverse(s.begin()+start,s.begin()+start + k);
        
        return s;
```

#### 3.卡玛 53 替换数字

```
目描述
给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。
输入描述
输入一个字符串 s,s 仅包含小写字母和数字字符。
输出描述
打印一个新的字符串，其中每个数字字符都被替换为了number
输入示例
a1b2c3
输出示例
anumberbnumbercnumber
提示信息
数据范围：
1 <= s.length < 10000。
```

题解：

定义一个字符串，遍历存放，遇到数字换就是了

```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin >> s;
    string ans;
    for(char ch:s){
        if(ch >= '0' && ch <='9'){
            ans+="number";
        }
        else ans+=ch;
    }
    cout << ans;
    return 0;
}
```

#### 4.力扣 151 翻转字符串里的单词

```
给你一个字符串 s ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

 

示例 1：

输入：s = "the sky is blue"
输出："blue is sky the"
示例 2：

输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
示例 3：

输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

题解：

其实反转也可以看成先进后出，所以可以用栈的思维来转换

先遍历字符串将单词入栈

随后再挨个弹出就行了，注意加空格

```
class Solution {
public:
    string reverseWords(string s) {//先进后出，用栈
        stack<string> st;
        string ans;

        for(int i=0;i<s.size();i++){//分割单词存入栈中
            if(s[i]!=' '){
                string temp;
                while(s[i]!='\0' && s[i]!=' '){
                    temp +=s[i++];
                }
                st.push(temp);
            }
        } 

        while(!st.empty()){//栈不为空就输出栈
            ans += st.top();
            st.pop();
            if(!st.empty()) ans+=' ';
        }
        return ans;
    }
};
```

双指针法

```
string reverseWords(string s) {
        int slow =0;
	    for(int fast=0;fast < s.size();fast++){
            if(s[fast]!=' ') s[slow++] =s[fast];
            else if(s[fast] == ' ' && fast>0 && s[fast-1] !=' ') s[slow++]=' ';
        }
        if(s[slow-1] == ' ') slow--;
	    s.resize(slow);
	    reverse(s.begin(),s.end());
        int start =0;
        int end =0;
    
        while(end < s.size()){
            while(end < s.size() && s[end]!=' ') {
        	    end++;
		    }
            reverse(s.begin()+start,s.begin()+end);
            end++;
		    start = end;
        }
        return s;
    }
```



#### 5.卡玛 55 右旋转字符串

```
字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

输入描述
输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。
输出描述
输出共一行，为进行了右旋转操作后的字符串。
输入示例
2
abcdefg
输出示例
fgabcde
提示信息
数据范围：
1 <= k < 10000,
1 <= s.length < 10000;
```

题解：利用栈很简单

```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
 
int main(){
    int n;
    string s;
    string ans;
    cin >> n >> s;
    stack<char> st;
    int len = s.size();
    int i;
    for(i = len-1;i>len-n-1;i--){
        st.push(s[i]);
    }
    while(!st.empty()){
        ans+=st.top();
        st.pop();
    }
    for(i=0;i<len-n;i++){
        ans+=s[i];
    }
    cout << ans;
    return 0;
}
```

#### 6.力扣 459 重复的子字符串

```
给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

 

示例 1:

输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
示例 2:

输入: s = "aba"
输出: false
示例 3:

输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

题解：巧用next数组求最大重复的前缀长度

再用n除以前缀长度，看看能否整除；

next一种

```
class Solution {
public:

    void getNext(vector<int>& next,const string& s,int n){
         for (int i = 1; i < n; ++i) {
            int j = next[i - 1];
            while (j != -1 && s[j + 1] != s[i]) {
                j = next[j];
            }
            if (s[j + 1] == s[i]) {
                next[i] = j + 1;
            }
        }
    }

    bool repeatedSubstringPattern(string s) {
        int n = s.size();
        vector<int> next(n, -1);
        getNext(next,s,n);
        return next[n - 1] != -1 && n % (n - next[n - 1] - 1) == 0;
    }
};

```

第二种next

```
class Solution {
public:

    void getNext(vector<int>& next,const string& s,int n){
         int i=0,j=-1;
        while(i<n){
            if(j == -1 || s[i] == s[j]){
                i++;
                j++;
                next[i]= j;
            }
            else 
                j = next[j];
        }
    }

    bool repeatedSubstringPattern(string s) {
        int n = s.size();
        vector<int> next(n+1, -1);
        getNext(next,s,n);
        return next[n] != 0 && ((n % (n-next[n])) == 0);
    }
};

```

# 五、哈希表

## 1、无序表

定义

```
unordered_map<int,int>map;
```

常用方法

```
insert(key, value)：向哈希映射中插入键值对。
erase(key)：从哈希映射中删除指定键对应的键值对。
find(key)：查找指定键对应的值。
size()：返回哈希映射中键值对的数量。
empty()：检查哈希映射是否为空。
```

### 例题

#### 1、力扣 242 有效的字母异位词

```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
 
```

题解：

因为本题范围只有26个字母，所以可以采用数组代替hash表，用下标代表a-z的字母

判断异位词，换句话说就是判断他们两个之间的字符是否完全相同

遍历第一个字符串，将每个元素出现次数记录下来。

再遍历第二个字符串，将每个元素出现一次减少一次

如果最后数组中有非0元素，那说明有元素没有出现（多出现了）

```
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.size()!=t.size()) return false;
        int check[27] = {0};
        for(int i=0;i<s.length();i++){
            check[s[i]-'a']++;
            check[t[i]-'a']--;
        }
        
        for(int i : check){
            if(i != 0 )return false;
        }
         return true;
    }
};
```



#### 2、力扣 349 两个数组的交集

```
给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
 
```

题解：

先将两个数组都排序，定义两个下标分别指向两个数组首地址

因为不允许重复，所以可以判定当index不为头元素的时候，前一个元素和当前元素相同，那就直接下标++后continue

当遇到两个数组中相等的元素时把他加入ans

并且因为答案的不可重复，可以直接全部++

如果数组1的元素大于数组二的元素，因为数组是排序过的，所以只要让数组二的下标++就行

小于同理

```
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<int> ans;
        if(nums1.size() == 0 || nums2.size() == 0) return ans;
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        int index1=0,index2=0;
        
        while(index1<nums1.size() && index2<nums2.size()){
            if(index1!=0&&nums1[index1] == nums1[index1-1]) {
                index1++;
                continue;
            }
            if(index2!=0&&nums2[index2] == nums2[index2-1]) {
                index2++;
                continue;
            }
            
            if(nums1[index1] == nums2[index2]) {
                ans.push_back(nums1[index1]);
                index1++;
                index2++;
            }
            else if(nums1[index1] < nums2[index2]) index1++;
            else   index2++;
        }
        
        
        return ans;
    }
};
```

双哈希表法

```
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int>map1;
        unordered_map<int,int>map2;

        for(int i:nums1) map1[i] = i;
        for(int i:nums2){
            if(map1.count(i) > 0 )
                map2[i] = i;
        }
        vector<int>ans;
        for(auto it:map2){
            ans.push_back(it.first);
        }
        return ans;
    }
```

#### 3、力扣 1 两数之和

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
```

题解：

很简单，将数据都存入hashmap中后，将指针指向第一个元素

我们需要找的目标就是target-第一个元素

向hashmap中找有没有这个元素，有就返回，没有继续

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> check_map;
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            // 记录每个数字的索引
            check_map[nums[i]] = i;
        }
        for (int i = 0; i < nums.size(); i++) {
            int temp = target - nums[i];
            // 检查是否存在配对
            if (check_map.count(temp) && check_map[temp] != i) {
                return {i, check_map[temp]};
            }
        }
        return ans;
    }
};

```

双指针法

```
vector<int> twoSum(vector<int>& nums, int target) {
        multimap<int,int>index1;//允许重复值存在的map
        for(int i=0;i<nums.size();i++){
            index1.emplace(nums[i], i);//插入
        }
       
        auto left = index1.begin();
        auto right = index1.end();
        right--;
        
        while(left->first <= right->first){
            int sum = left->first + right->first;     
            if (sum > target){
                right--;
            }else if(sum < target){
                left++;
            }else{
                return {left->second,right->second};
            }
        }
        
        return {};
    }
```



#### 4、力扣 15三数之和（双指针）

```
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
示例 2：

输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
示例 3：

输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
 
```

题解：

其实这题可以用回溯做，但是会超时，剪枝剪不了一点

首先我们将数组排序

需要一个指针i从头到倒数第三个元素遍历（三元组，保证有两个元素空余）

因为数组是有序的 那么 i和后两个元素相加如果已经大于target了的话，那说明已经不存在符合条件的组合了，直接break

如果i和数组末尾的两个元素相加还小于target的话，那说明当前的i不可能符合条件，向后寻找更大的i，continue

我们假设（i）和末尾的元素（right）就是我们需要的元素之一，

那么我们需要的第三个元素就是0-i-right

我们设一个left，他从i的后一个元素开始遍历

那么right就是决定sum的最大值，left就是决定sum的最小值

那我们只需要移动left就可以找到目标的元素

当left>right的时候，组合就不存在了，可以继续下一个循环了

当sum比traget小的时候，left就得++

当sum大于traget的时候，right就得--

当sum等于traget的时候，我们就可以存放一个组合了。

注意题目要求不重复，那么如果left右边的元素/right左边的元素和当前的left/right相同，那就继续移动。



```
vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());//数组变成单调增
        vector<vector<int>> ans;

        for(int left=0;left<nums.size()-2;left++){
            if(nums[left] > 0) break;
            //nums[left] == nums[left-1] 1 1 2 i 和 j 两个1都能取到
            //nums[left] == nums[left+1] 1 1 2 i 只能取到第二个1
            if(left>0 && nums[left] == nums[left-1]) continue;
            
            int right = nums.size()-1;
            int find = left + 1;
            int target = 0-nums[left];
            if(nums[left]+nums[find] > target) break;
            if(nums[right] + nums[right-1] < target) continue;

            while(find < right){
                int sum = nums[right] + nums[find];
                if(sum == target){
                    ans.push_back({nums[left],nums[find],nums[right]});
                    while(find < right && nums[find] == nums[find+1]) find++;
                    while(find < right && nums[right] == nums[right-1]) right--;
                    find++;
                    right--;
                }else if(sum < target){
                    find++;
                }else{
                    right--;
                }
            }

        }
        return ans;
    }
```

#### 5、力扣 18四数之和

```
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

 

示例 1：

输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
示例 2：

输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

题解：这题和三数之和相比就是多嵌套了一层

```
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for(int i = 0; i < n - 3; i++)
        {
            if (i > 0 && nums[i] == nums[i-1]) continue;

            if ((long)nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;//前4个元素就是最小的了，如果4个最小加起来还大于目标值，那就没必要看了

            if ((long)nums[i] + nums[n-1] + nums[n-2] + nums[n-3] < target) continue;//最后三个一定是最大的，如果当前元素加上最后三个还是小于目标值，那就直接continue

            for(int j = i + 1; j < n - 2; j++)
            {
                if (j > i + 1 && nums[j] == nums[j-1]) continue; //去除重复
                
                int newTarget = target - nums[i] - nums[j]; //目标值是减去i,j后的元素
                if (nums[j+1] + nums[j+2] > newTarget) break;//前两个元素就是最小的了，如果两个最小加起来还大于目标值，那就没必要看了
                if (nums[n-2] + nums[n-1] < newTarget) continue;//最后两个一定是最大的，如果当前元素加上最后两个还是小于目标值，那就直接continue
                
                int left = j + 1, right = n - 1;//下面和仨数之和一样
                while (left < right)
                {
                    long value = (long)nums[i] + nums[j] + nums[left] + nums[right];
                    if(value == target)
                    {
                        res.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while(left < right && nums[left] == nums[left+1]) left++;
                        while(left < right && nums[right] == nums[right-1]) right--;
                        left ++ ;
                        right -- ;
                    }
                    else if (value < target ) left++;
                    else right -- ;
                }     
            }
        }
        return res;
    }
};
```

#### 6、力扣 454四数相加

```
给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
 

示例 1：

输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
示例 2：

输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

题解：

这题我们要将问题换过来思考

abcd四个数相加，可以看成是 (a+b) + (c+d)

分开归纳

用两层循环遍历a，b相加的和的所有可能，存入哈希表中

同样用两层循环遍历c，d相加的和的所有可能，和哈希表中的数值对比

因为target是0，所以看看有没有相反数

有的话就ans++

```
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
            int ans=0;
            unordered_map<int,int> A_B_Sum;
            //将nums1和nums2数组中的所有和可能，计数存入哈希表中
            for(int i:nums1){
                for(int j :nums2){
                    ++A_B_Sum[i+j];
                }
            }
            //将所有nums3nums4和的可能的相反数，去哈希表中找，即可找到所有和为0的可能
            for(int i:nums3){
                for(int j:nums4){
                    if(A_B_Sum.count(-i-j)){
                        ans+=A_B_Sum[-i-j];
                    }
                }
            }
            return ans;
    }
};
```

#### 7、力扣 202快乐数

```
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

示例 1：

输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：

输入：n = 2
输出：false
```

题解：

这题的关键在于重复

当sum的重复为1时，就为真

当sum的重复为其他时，就为假

用一个哈希记录所有sum可能

如果在哈希中遇到一样的，就看时什么

如果没遇到过就加入到哈希中

```
	int n_sum(int n){
        int sum =0;
        while(n){
            sum += (n%10)* (n%10);
            n/=10;
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_map<int,int>check;
        while(true){
            int sum = n_sum(n);
            if(check.empty() || check.count(sum) == 0){
                ++check[sum];
            }else if(check.count(sum) != 0 && sum==1) 
                return true;
            else if(check.count(sum) != 0 && sum!=1) 
                return false;
            n=sum;
        }
    }
```



#### 8、力扣 383赎金信

```
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

示例 1：

输入：ransomNote = "a", magazine = "b"
输出：false
示例 2：

输入：ransomNote = "aa", magazine = "ab"
输出：false
示例 3：

输入：ransomNote = "aa", magazine = "aab"
输出：true
```

题解：因为有个条件：magazine 中的每个字符只能在 ransomNote 中使用一次。

所以这题就变成了，ransomNote 中出现的字符，是不是都在magazine中出现的过

和异位词有异曲同工之处。先记录magazine 中每个字符出现的次数

然后遍历ransomNote，开始进行删减

如果哈希数组中出现了负数值，那么说明ransomNote中有magazine没有的字符

return false

```
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int cheak[27] = {0};
        for(char ch:magazine){
            cheak[ch-'a']++;
        }
        for(char ch : ransomNote){
            cheak[ch-'a']--;
        }
        for(int i: cheak){
            if(i < 0) return false;
        }
        return true;
    }
};
```



## 2、有序表

定义

```
map<int,int>map
```

常用方法

```
同上
```

判断元素是否在表中

```
map.count(val) > 0 ? true:false
```



# 六、并查集

并查集用于处理不相交集合的合并和查询操作。它主要支持两种操作：

```
查找（Find）：查找元素所属的集合（或者称为根节点）。这个操作通常用于确定两个元素是否属于同一个集合，即检查它们的根节点是否相同。

合并（Union）：将两个集合合并为一个集合。这个操作通常在查找操作之后进行，如果发现两个元素属于不同的集合，则将它们所在的两个集合合并为一个。
```

并查集通常使用一个数组来实现，数组的每个元素代表一个节点，数组的值代表该节点的父节点（或者根节点）。通过路径压缩（Path Compression）和按秩合并（Union by Rank）等优化技术，可以使得查找和合并操作的时间复杂度接近于常数。

并查集在解决一些图论和连通性问题时非常有用

###### 实现：

```
class UnionFind {
```

成员：

```
private:
    vector<int> parent; // 存储每个节点的父节点
    int count; // 集合数量
```

```
public:
```

  //构造函数：初始化并查集，每个节点都是一个单独的集合，初始时父节点指向自身

```
  UnionFind(int n) {
        count = n;
        parent.resize(n);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
```

​    // 查找函数：找到节点 p 所在集合的根节点，并进行路径压缩

```
int find(int p) {
        while (p != parent[p]) {
            parent[p] = parent[parent[p]]; // 路径压缩：将节点 p 的父节点指向父节点的父节点
            p = parent[p];
        }
        return p;
    }
```

​    // 合并函数：将节点 p 和节点 q 所在的集合进行合并

```
 void unite(int p, int q) {
        int rootP = find(p); // 找到节点 p 的根节点
        int rootQ = find(q); // 找到节点 q 的根节点
        if (rootP == rootQ) return; // 如果节点 p 和节点 q 已经在同一个集合中，则不进行合并操作
        parent[rootP] = rootQ; // 将节点 p 的根节点的父节点指向节点 q 的根节点
        count--; // 集合数量减少一个
    }
```

​    // 获取当前集合数量

```
 int getCount() {
        return count;
    }
```

```
};
```

# 七、二叉树

## Ⅰ、种类

#### 1、满二叉树

```
		root
left  / 	\ right
	node    node
	/  \    /  \
node  node node node
```

```
深度为k的满二叉树，结点数量为
2^k - 1；
```

### 2、完全二叉树

除了底层没满，其他都满，并且底层必须从左到右连续

满二叉树 是 完全二叉树

堆也是通过完全二叉树实现

```
		root
left  / 	\ right
	node    node
	/  \    /  \
node  node 
```

### 3、二叉搜索树

有顺序

所有结点都满足 ：一个结点的左子树都小于它，右子树都大于它

搜索一个结点的时间复杂度是 log n

```
		6
left  / 	
	  3      
	/  \    
   1   4   
```

### 4、平衡二叉搜索树

左子树和右子树的高度绝对值不超过 **1**

常见使用平衡二叉搜索树的数据结构 ：map 、set 、multimap 、multiset

使用平衡二叉搜索树的数据结构 插入搜索的时间复杂度都是 log n

```
		root
left  / 	\ right
	node    node
	/  \    /  \
node  node 
/
node
```

## Ⅱ、存储方式

### 1、链式存储

用链表实现

### 2、线性存储

用数组实现

```
		a(0)
left  / 	\ right
	b(1)    c(2)
	/  \    /  \
d(3)  e(4) f(5) g(6)

num[] ="abcdefg";

某个结点的左子树
2*i+1

某个结点的右子树
2*i+2
```

## Ⅲ、二叉树的遍历

### 1、深度优先遍历

###### 前序遍历

根左右

###### 中序遍历

左根右

###### 后序遍历

左右根

递归 /迭代（用栈来模拟递归）

### 2、广度优先遍历

层次遍历（用队列来模拟）

## Ⅳ、定义

###### 结构体

```
struct TreeNode{
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int x): val(x),left(nullptr),right(nullptr){}
};
```

###### 递归前序遍历（中后遍历就是换个顺序）

```
// 递归前序遍历二叉树	深度优先搜索
void firstTravel(TreeNode *root,vector<int>& ans){
        if(root == nullptr) return;
        ans.push_back(root->val);
        firstTravel(root->left,ans);
        firstTravel(root->right,ans);
}
```

###### 迭代前序遍历

```
vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;
        if(root) st.push(root); 
        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            ans.push_back(node->val);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);
        }
        return ans;
}
```

###### 迭代中序遍历

```
vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;
        TreeNode* curr = root;
        while(curr||!st.empty()){
            while(curr){	//先遍历左子树
                st.push(curr);
                curr = curr->left;
            }
            
            curr = st.top();//获得根
            st.pop();
            ans.push_back(curr->val);
            
            curr = curr->right;//遍历右子树
        }
        return ans;
    }
```

###### 迭代后序遍历

```
vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;
        TreeNode* prev = nullptr; //prev 的作用是用来追踪上一个访问的节点。它主要用于判断当前节点的右子节点是否已经被访问过。
        while (root || !st.empty()) {
            while (root) {	//遍历左子树
                st.push(root);
                root = root->left;
            }
            
            root = st.top();//遍历右子树
            if (root->right && root->right != prev) {
                root = root->right;
            } else {//没有右子树,或者右子树已经遍历过了，再获取根
                ans.push_back(root->val);
                st.pop();
                prev = root;
                root = nullptr;
            }
        }
        return ans;
    }
```

###### 层次遍历

```
vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        queue<TreeNode*> q1;
        if(root == nullptr) return ans;
        q1.push(root);
        
        while(!q1.empty()){
            int len = q1.size();	//每一层的结点数，就是当前队列里的元素数量
            ans.push_back(vector <int> ());//这一行代码创建了一个空的向量，并将其添加到结果数组 当前层的节点值创建了一个新的分组
            for (int i = 0; i < len; i++) {
                auto node = q1.front(); q1.pop();
                ans.back().push_back(node->val);	//将当前节点的值添加到这个刚刚添加的向量中
                if (node->left) q1.push(node->left);
                if (node->right) q1.push(node->right);
            }
        }
        return ans;
 }
```



## Ⅴ、例题

### 1、 力扣 226 翻转二叉树

```
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]

示例 2：
输入：root = [2,1,3]
输出：[2,3,1]

示例 3：
输入：root = []
输出：[]
```

题解：

从根节点开始左右互换，递归往下，直到根结点为空

根左右，所以是**前序遍历**

```
TreeNode* invertTree(TreeNode* root) {
        if(!root) return;
        //交换,处理中间结点
        TreeNode* node;
        node = root->left;
        root ->left = root->right;
        root->right = root->left;
        //遍历左右子树
        if(root->left) invertTree(root->left);
        if(root->right) invertTree(root->right);

        return root;
    }
```

### 2、 力扣 101 对称二叉树

```
给你一个二叉树的根节点 root ， 检查它是否轴对称。
示例 1：
输入：root = [1,2,2,3,4,4,3]
输出：true

示例 2：
输入：root = [1,2,2,null,3,null,3]
输出：false
提示：
树中节点数目在范围 [1, 1000] 内
-100 <= Node.val <= 100
```

题解：

本题也可以看成两个二叉树是否可以翻转后相等

也可以看成是同时遍历两个二叉树

因为本题我们需要收割子树，最后再判断根，所以用**后序遍历**

递归-后序遍历：

```
bool compare(TreeNode* root1, TreeNode* root2){//对比两个结点是否相同
        if(root1 == nullptr && root2 !=nullptr) return false;
        else if(root1 != nullptr && root2 ==nullptr) return false;
        else if(!root1 && !root2) return true;//两个都为空肯定相同
        else if(root1->val != root2->val) return false;
        
        return compare(root1->left,root2->right) && compare(root1->right,root2->left);//注意对称二叉树需要对比的是内外对应
    }

    bool isSymmetric(TreeNode* root) {
        return compare(root->left,root->right);
    }
```

迭代

```
初始化时我们把根节点入队两次。
每次提取两个结点并比较它们的值
然后将两个结点的左右子结点按相反的顺序插入队列中。
当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。
```

```
bool isSymmetric(TreeNode* root) {
       queue<TreeNode*>q1;
       q1.push(root);
       q1.push(root);
       while(!q1.empty()){
            TreeNode* node1 = q1.front();
            q1.pop();
            TreeNode* node2 = q1.front();
            q1.pop();

            if(!node1 && !node2) continue;
            if(!node1 || !node2) return false;
            if(node1->val != node2->val) return false;

            q1.push(node1->left);q1.push(node2->right);
            q1.push(node1->right);q1.push(node2->left);
       }
        return true;
    }
```

### 3、 力扣104 二叉树的最大深度

```
给定一个二叉树 root ，返回其最大深度。

二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数
示例 1：
输入：root = [3,9,20,null,null,15,7]
输出：3

示例 2：
输入：root = [1,null,2]
输出：2
```

###### 什么是深度？什么是高度？

```
深度是二叉树里从根节点到某个节点的唯一路径的长度	（先序遍历求）

高度是二叉树种任意一个结点到叶子节点的最长距离 （后序遍历求）
```

本题求的虽然是二叉树的最大深度

但其实是求根节点的最大高度

所以用**后序遍历**



递归去求左子树和右子树最大深度

根的深度就是子树最大深度+1；

```
int maxDepth(TreeNode* root) {
    if (!root) return 0;
       return 1+max(maxDepth(root->left),maxDepth(root->right));
    }
```

### 4、 力扣 111 二叉树的最小深度

```
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：2
示例 2：

输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

本题用迭代法更简单

```
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode*> q1;
        q1.push(root);
        int deep =1;
        while(!q1.empty()){
            int len = q1.size();
            for(int i=0;i<len;i++){
                TreeNode* node = q1.front();
                q1.pop();
                if(node->left) q1.push(node->left);
                if(node->right) q1.push(node->right);
                if(!node->left && !node->right) return deep;
            }
            deep++;
        }
        return deep;
    }
};
```

当然递归也能做，加两个如果左右有一个为空，那么就返回不为空的那个子树长度＋1

本体时从下往上，**后序遍历**

```
int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(root->left == nullptr && root->right) return 1+minDepth(root->right);
        if(root->left && root->right == nullptr) return 1+minDepth(root->left);
        return min(minDepth(root->left),minDepth(root->right))+1;
    }
```

### 5、 力扣 222 完全二叉树的结点个数

```
给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
示例 1：
输入：root = [1,2,3,4,5,6]
输出：6
示例 2：

输入：root = []
输出：0
示例 3：

输入：root = [1]
输出：1
```

题解：

普通二叉树直接遍历计数就行，此处用的是**后序遍历**

```
if(!root) return 0;
return countNodes(root->left) + countNodes(root->right) +1;
```

但这题是完全二叉树，我们可以利用他的性质

一个深度为k的满二叉树，结点数量为2^k-1

而完全二叉树是底层从右往左缺少结点的二叉树。所以如果可以证明左子树是满二叉树，能快一点

```
int countNodes(TreeNode* root) {
        if(!root) return 0;
        TreeNode* left = root;
        TreeNode* right =root;
        int deep=0;
        while(left && right){
            left = left->left;
            right = right->right;
            deep++;
        }
        if(!left && !right) return pow(2,deep)-1;
        else
            return countNodes(root->left) + countNodes(root->right) +1;
    }
```

### 6、力扣 110 平衡二叉树

```
给定一个二叉树，判断它是否是 
平衡二叉树
  
示例 1：
输入：root = [3,9,20,null,null,15,7]
输出：true

示例 2：
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false

示例 3：
输入：root = []
输出：true
```

题解：

计算每个结点的左右子树高度，其差值的绝对值超过1的就返回-1

如果已经有一个为-1，那这棵树就不是平衡二叉树

```
int getHeight(TreeNode* root){
        if(!root) return 0;

        int left,right;
        left = getHeight(root->left);
        if(left == -1) return -1;

        right = getHeight(root->right);
        if(right == -1) return -1;

        return abs(left-right) > 1 ?  -1 : 1+max(left,right);
    }
    
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;    
    }
```

### 7 、 力扣 257 二叉树的所有路径

```
给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。

示例 1：
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]

示例 2：
输入：root = [1]
输出：["1"]
```

题解：

深度优先算法

```
void dfs(TreeNode* root,string path,vector<string>& ans){
        if(root){
            path += to_string(root->val);
            if(!root->left && !root->right)
                ans.push_back(path);
            else{
                path+="->";
                dfs(root->left,path,ans);
                dfs(root->right,path,ans);
            }
        }else{
            return;
        }
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string>ans;
        string s="";
        dfs(root,s,ans);
        return ans;
    }
```

### 8、力扣 404 左叶子之和

```
给定二叉树的根节点 root ，返回所有左叶子之和。

示例 1：
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

示例 2:
输入: root = [1]
输出: 0
```

题解

​	所谓左叶子，就是每一层最左边的叶子结点。用层序遍历更简单。

（1）深搜解法

```
    int ans=0;
    void dfs(TreeNode* root,bool is_left){
        if(root){
            if(!root->left && !root->right && is_left){
                ans+=root->val;
            }else if(root->left || root->right){
                dfs(root->left,true);
                dfs(root->right,false);
            }

        }
    }
    
    int sumOfLeftLeaves(TreeNode* root) {
        dfs(root,false);
        return ans;
    }
```

（2）递归遍历

```
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right== NULL) return 0;

        int leftValue = sumOfLeftLeaves(root->left);    // 左
        if (root->left && !root->left->left && !root->left->right) { // 左子树就是一个左叶子的情况
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = leftValue + rightValue;               // 中
        return sum;
    }
```

（3）、迭代法

```
int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode*> q1;
        q1.push(root);
        int ans=0;
        while(!q1.empty()){
            int len = q1.size();
            for(int i=0;i<len;i++){    
                TreeNode* node = q1.front();
                q1.pop();
                if(node->left){
                    q1.push(node->left);
                    if(!node->left->left && !node->left->right)
                        ans+=node->left->val;
                } 
                if(node->right) q1.push(node->right);
                
            }
        }
        return ans;
    }
```

### 9、力扣 513 找到树左下角的值

```
给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。
假设二叉树中至少有一个节点。

示例 1:
输入: root = [2,1,3]
输出: 1

示例 2:
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

题解

本题用其他方法还需要考虑左右子树那边更高

还是迭代好

迭代法

```
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode*>q1;
        q1.push(root);
        int ans;
        while(!q1.empty()){
            int len=q1.size();
            for(int i=0;i<len;i++){
                TreeNode* node = q1.front();
                q1.pop();
                if(i==0) ans = node->val;
                if(node->left) q1.push(node->left);
                if(node->right) q1.push(node->right); 
            }
        }       
        return ans;
    }
};
```

### 10、力扣 112 路径总和

```
给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。
示例 1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。

示例 2：
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。

示例 3：
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

题解

深度优先搜索，将每一条路径记录下来，左子树和右子树，有一个满足就可以了

如果到叶子节点或者根节点不存在，那就返回false

```
bool dfs(TreeNode* root,int targetSum ,int sum){
        if(root){
            sum += root->val;
            if(!root->left && !root->right){
              return  sum == targetSum ;
            }
            return dfs(root->left,targetSum,sum) || dfs(root->right,targetSum,sum);
        }
        return false;
    }
    
    bool hasPathSum(TreeNode* root, int targetSum) {
        return dfs(root,targetSum,0);
    }
```

### 11、 力扣 106 从中序与后序遍历序列构造二叉树

```
给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

 

示例 1:


输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
示例 2:

输入：inorder = [-1], postorder = [-1]
输出：[-1]
```

题解：

利用后序遍历确定根节点

利用中序遍历确定左右子树范围

递归创建

注意vector截取数组是**左闭右开**区间

```
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (postorder.empty() || inorder.empty()) return nullptr;

        int root_val = postorder.back();
        TreeNode* node = new TreeNode(root_val);
        
        auto index = find(inorder.begin(),inorder.end(),root_val);
        auto begin = inorder.begin();
        int len = index - begin;
        
        //vcetor这个创建是左闭右开区间
        vector<int> left_in(inorder.begin(), index);
        vector<int> left_post(postorder.begin(), postorder.begin()+len);
        
        //右子树创建时要跳过root
        vector<int> right_in(index+1, inorder.end());
        vector<int> right_post(postorder.begin()+len, postorder.end()-1);
        
        node->left = buildTree(left_in, left_post);
        node->right = buildTree(right_in, right_post);
        
        return node;
    }
};

```

 下标法

```
unordered_map<int,int>indexMap;

    TreeNode* build(vector<int>& inorder, vector<int>& postorder, int start_in, int end_in, int start_post, int end_post) {
    if (start_in > end_in) return nullptr;

    int rootVal = postorder[end_post];
    int rootIndex = indexMap[rootVal];
    TreeNode* root = new TreeNode(rootVal);

    // 构建左子树
    int left_size = rootIndex - start_in;
    root->left = build(inorder, postorder, start_in, rootIndex - 1, start_post, start_post + left_size - 1);
    // 构建右子树
    root->right = build(inorder, postorder, rootIndex + 1, end_in, start_post + left_size, end_post - 1);

    return root;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for(int i=0;i<inorder.size();i++)
            indexMap[inorder[i]] = i;
        int index = postorder.size()-1;
        return build(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);
    }
```

```
inorder   = [9,3,15,20,7]
postorder = [9,15,7,20,3]

start_in=0,end_in=4,start_post=0 ,end_post = 4

rootVal = postorder[end_post] = 3 
rootIndex = indexMap[rootVal] = 1

leftsize =rootIndex - start_in = 1 - 0 = 1

左子树 -> 中序 [9] （start_in:start_in      end_in: rootIndex-1）
	  -> 后序 [9] (start_post:start_post  end_post:start_post + left_size - 1)
右子树 -> 中序 [15,20,7]	(start_in:rootIndex+1 end_in:end_in)
	  -> 后序 [15,7,20] (start_post:start_post+left_size,end_post:end_post-1)
	  
	  inorder [9]
	  postorder[9]
	  inorder [15,20,7]
	  postorder [15,7,20]
..............
```

### 12、 力扣 654 最大二叉树

```
给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。
示例 1：
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

题解：

和上题类似，不过根结点是数组中最大的数，根节点左右两边的子数组为左右子树

```
class Solution {
public:
    
    int find_max(vector<int>& nums){
        int max = 0;
        for(int i=0;i<nums.size();i++){
            if(nums[i] > nums[max]) max = i;
        }
        return max;
    }
    
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if(nums.empty()) return nullptr;
        int index = find_max(nums);
        TreeNode* node = new TreeNode(nums[index]);
        
        vector<int>left(nums.begin(),nums.begin()+index);
        vector<int>right(nums.begin()+index+1,nums.end());
        
        node->left = constructMaximumBinaryTree(left);
        node->right =  constructMaximumBinaryTree(right);
        return node;
    }
};
```

非递归构造

```
TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int n = nums.size();
        TreeNode* root = new TreeNode(nums[0]);
        for(int i=1;i<nums.size();i++){
            TreeNode* node = new TreeNode(nums[i]);

            if(nums[i] < root->val){
                TreeNode* pre = root;
                while(pre->right && pre->right->val > nums[i]) pre = pre->right;
                
                if(!pre->right){
                    pre->right = node;
                }else{
                    node->left = pre->right;
                    pre->right = node;
                }

                }else{
                   node->left = root;
                   root = node;
            }
        }
        return root;
    }
```

单调栈解法

栈顶元素永远是根节点

如果新元素比栈顶元素大，那栈顶元素就是他的左结点

如果栈顶元素比它大，那它就是栈顶元素的右结点

```
当我们遇到元素 3 时，我们将其作为根节点，放入单调栈中。

Stack: [3]
当我们遇到元素 2 时，我们发现其比栈顶元素 3 小，因此 2 应该是 3 的右子节点。我们将 2 放入栈中。
3
 \
  2
Stack: [3, 2]

当我们遇到元素 1 时，我们发现其比栈顶元素 2 小，1 应该是 2 的右子节点。因此，我们需要将 1 放入栈中
3
 \
  2
   \
    1

Stack: [3,2,1]

当我们遇到元素 6 时，我们发现其比栈顶元素 1 大，不断弹出栈内比6小的元素直到栈空，将他们变成6的左子树
6->left = 1 -> =2 -> =3

    6
   /
  3
   \
    2
     \
      1
Stack: [6]

然后我们继续遍历数组，当遇到元素 0 时，我们发现其比栈顶元素 6 小，因此 0 应该是 6 的右子节点。

     6
   /   \
  3     0
   \     
    2   
     \   
      1 
Stack: [6,0]

最后，当遇到元素 5 时，我们发现其比栈顶元素 0 大，因此 5 应该是 0 的父亲节点，0变成5的左节点。


     6
   /   \
  3     5
   \   /   
    2 0   
     \   
      1 
Stack: []
```

```
TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        stack<TreeNode*>st;
        for(int i:nums){
            TreeNode* node = new TreeNode(i);
            while(!st.empty() && st.top()->val < i){//确保栈顶是根
                node->left = st.top();
                st.pop();
            }
            if(!st.empty()){
                st.top()->right = node;
            }
            st.push(node);
        }
        
        TreeNode* root = nullptr; 
        while (!st.empty()) { //栈顶元素是根节点
            root = st.top(); 
            st.pop(); 
        }
        return root; 
    }
```

### 13、 力扣 617 合并二叉树

```
想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。
示例 1：
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]

示例 2：

输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

题解：

同时操控两个二叉树，当左右子树都存在的时候，把2数的值加到1树上

如果有任何一颗子树存在，而另一颗不存在，返回对应的子树就行了

```
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;//如果该位置root1为空，就链接root2
        if(!root2) return root1;//同上
        
        root1->val += root2->val;
        
        root1->left = mergeTrees(root1->left,root2->left);
        root1->right = mergeTrees(root1->right,root2->right);
        
        return root1;
    }
};
```

### 14、 力扣 700 二叉树中的搜索

```
给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

 

示例 1:


输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

题解：

利用二叉搜索树的性质，左子树必定小于根节点，右子树必定大于根结点，并且对于所有结点生效

```
class Solution {
public:
    
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root || root->val == val) return root;
        
        while( root && (root->left  || root->right)){
            root = root-> val > val ? root->left : root->right;
            if(root && root->val == val) return root;
        }
        return nullptr;
    }
};
```

### 15、力扣 98 验证二叉搜索树 	

```
给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左
子树
只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
 

示例 1：
输入：root = [2,1,3]
输出：true
```

题解：

利用二叉搜索树的另一个性质：二叉搜索树的中序遍历应该是单调递增的序列

1、利用数组存储二叉搜索树的**中序遍历**，然后确认数组是否是单调递增

2、利用双指针，一个用来记录上一个结点（中序左右根），也就是左子树的结点，在根处判断，如果根小于左子树，那必然不是二叉搜索树。

```
class Solution {
public:
    //中序遍历应该是单调增
    TreeNode * pre=nullptr;//双指针法，pre记录上一个节点
    bool isValidBST(TreeNode* root) {
        if(!root) return true;
        bool left =isValidBST(root->left);
        
        if(pre && pre->val >= root->val) return false;//如果当前节点比上一个节点大
        pre = root;
        
        bool right =isValidBST(root->right);
        return left && right;
    }
};
```

### 16、 力扣 530 二叉搜索树的最小绝对差

```
给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。

差值是一个正数，其数值等于两值之差的绝对值。

 

示例 1：


输入：root = [4,2,6,1,3]
输出：1
```

题解：

利用一个指针记录上一个结点，同时用一个min记录最小差值

```
int min_c=INT_MAX;
    TreeNode* pre=nullptr;
    int getMinimumDifference(TreeNode* root) {
        if(!root) return 0;
        getMinimumDifference(root->left);
        
        if(pre) min_c = min((root->val - pre->val) , min_c);
        
        pre =root;
        getMinimumDifference(root->right);
        return min_c;
    }
```

### 17、力扣 501  二叉搜索树中的众数

```
给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。
如果树中有不止一个众数，可以按 任意顺序 返回。
假定 BST 满足如下定义：
结点左子树中所含节点的值 小于等于 当前节点的值
结点右子树中所含节点的值 大于等于 当前节点的值
左子树和右子树都是二叉搜索树
 
示例 1：
输入：root = [1,null,2,2]
输出：[2]
```

题解：

这边要引入用指针求数组中的最大众数集合方法

```
首先将数组排序，确保一样的数会连续在一起

然后用一个指针向前移动，相等于上一个元素（nums[i] == nums[i-1]）那就计数++（count++)

直到不等于当前元素。我们把count置一。同时记录下来最大的出现频率（maxcount）

先假设当前元素为出现频率最大，放入结果集

当下一个元素出现频率统计出来后，和maxcount进行对比

<  maxcount 舍弃不管

== maxcount	加入结果集合

>  maxcoutnt	将结果集合清空，并且maxcount == count
```

同理

二叉搜索树的中序本身就是一个递增的顺序结构，照着改就行了

```
class Solution {
public:
    
    int count = 0;
    int maxCount = 0;
    TreeNode* pre = nullptr;	//指向上一个结点
    vector<int> ans;

    void getZS(TreeNode* root) {
        if (!root) return;
       	//遍历左子树
        getZS(root->left);
		//处理中间结点
        if (pre && (root->val != pre->val)) {
            count = 1; // 重置 count
        } else { 
            count++;
        }
        if (count > maxCount) { // 更新众数
            maxCount = count;
            ans.clear();
            ans.push_back(root->val);
        } else if (count == maxCount) {
            ans.push_back(root->val);
        }
        pre = root;
        //处理右子树
        getZS(root->right);
    }

    vector<int> findMode(TreeNode* root) {
        getZS(root);
        return ans;
    }
};
```

### 18、 力扣 236 二叉树的最近公共祖先

```
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

题解：

首先本题我们需要先找到子树再反过头找根

所以使用**后序遍历**



分类讨论

后序遍历树（左右根）

当我左右子树都找不到结点了，那就返回root（此时root为 nullptr）

当我找到的结点等于q或者p，意味着找到了目标结点，那就返回q，p；

左子树找完了，去右子树找

右子树找完了，去左子树找

如果都找到了就返回结点

```
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return root;
        if(root == q) return q;
        if(root == p) return p;

        TreeNode* L = lowestCommonAncestor(root->left,p,q);
        TreeNode* R = lowestCommonAncestor(root->right,p,q);

        if(!L) return R;
        if(!R) return L;

        return root;
    }
```

### 19、力扣 235 二叉搜索树的最近公共祖先

```
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

题解：

因为二叉搜索树是有序的，所以从头开始遍历，如果当前结点大于两个值，那说明在当前结点的左子树中，反之在右子树中

当结点值在两个数之间的时候，那他必然是最小公共祖先

迭代法

```
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        while(root){
            if(root->val >p->val && root->val >q->val) 
            	root = root->left;
            else if (root->val < p->val && root->val < q->val) 
            	root = root ->right;
            else break;
        }
        
        return root;
    }
```

递归法

```
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
       if(!root) return root;
       if(root == p) return p;
       if(root == q) return q;

        if(root->val > p->val && root->val > q->val)
           return lowestCommonAncestor(root->left,p,q);
        if(root->val < p->val && root->val < q->val)
            return lowestCommonAncestor(root->right,p,q);

        return root;
    }
```

### 20、 力扣 701 二叉搜索树中的插入操作

```
给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

示例 1：
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
```

题解：

按顺序插就行，顺着大小顺序寻找结点

迭代法

```
TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* node = new TreeNode(val);
        if(!root) return node;
        
        TreeNode* pre = root; 
        TreeNode* cur =pre;//指向上一个结点
        while(pre) {
            cur = pre;
            pre = pre ->val > val ? pre->left : pre->right;
            if(!pre){
                cur->val > val ? cur->left = node : cur->right = node;
                break;
            }
        }
        return root;
    }
```

递归法

```
TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* node = new TreeNode(val);
        if(!root) return node;
        if(root -> val > val) 
        	root ->left = insertIntoBST(root->left,val);
        else 
        	root->right = insertIntoBST(root->right,val);
        
        return root;
    }
```

### 21、 力扣 450 删除二叉搜索树中的结点

```
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。
```

题解：

要想明白可能的情况

第一种：找不到要删除的结点 -> return root

第二种：当前结点为叶子结点 ->直接删除

第三种 ：当前结点只有右孩子，没有左孩子，让当前结点变成右孩子

第四种 ：当前结点只有左孩子，没有右孩子，让当前结点变成左孩子

第五种：两个子树均不为空，选择让其左子树全连到右子树的左下角中，或者右子树连接到左子树的右下角中



```
TreeNode* deleteNode(TreeNode* root, int key) {
       if (!root) return root;//第一种情况：没有找到要删除的结点
       if(root->val == key){
            if(!root->left && !root->right) {
                delete root; //第二种情况: 要删除的结点为叶子节点
                return nullptr;
            }
            if(!root->left && root->right){//第三种情况，左子树为空，右子树不为空， 让当前节点变成他的右孩子
                TreeNode* node = root->right;
                delete root;
                return node;
            }
            if(root->left && !root->right){//第四种情况，右子树为空，左子树不为空， 让当前节点变成他的左孩子
                TreeNode* node = root->left;
                delete root;
                return node;
            }
            if(root->left && root->right){//第五种情况，两个子树均不为空，选择让其左子树全连到右子树的左下角中，或者右子树连接到左子树的右下角中
                TreeNode* pre = root->right;
                while(pre->left) pre = pre->left;
                pre->left = root->left;
                TreeNode* node = root->right;
                delete root;
                return node;
            }
       }

       if(root->val > key) root->left = deleteNode(root->left,key);
       if(root->val < key) root->right =deleteNode(root->right,key);
       return root;
    }
```

### 22、力扣 669 修剪二叉搜索树

```
给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
示例 1：
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]

示例 2：
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
```

题解：

​	如果根节点为空，那就返回空

​	如果结点值小于low，跳过它，连接他的右子树

​	如果节点值大于high，跳过它，连接他的左子树

```
TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (!root) return nullptr;
        
        // 如果根节点的值小于范围最小值，则修剪右子树
        if (root->val < low) {
            return trimBST(root->right, low, high);
        }
        // 如果根节点的值大于范围最大值，则修剪左子树
        if (root->val > high) {
            return trimBST(root->left, low, high);
        }
        
        // 递归修剪左右子树
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
```

ps：

```
在递归方法中，通常情况下不需要手动释放节点的内存，因为递归函数会在递归的过程中动态地创建和销毁节点。当递归函数返回时，栈上的局部变量会自动被销毁，包括每次递归创建的节点，因此不会造成内存泄漏问题
```

### 23、 力扣 108 将有序数组转换成二叉搜索树

```
108. 将有序数组转换为二叉搜索树
简单
相关标签
相关企业
给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 
平衡
 二叉搜索树。
示例 1：
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：

示例 2：
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

题解

每次的根节点是中间的那个数

左右子树是左边界到数

```
TreeNode* createTree(vector<int>&nums,int left,int right){
        if(left > right) return nullptr;

        int mid = (left+right)/2;
        TreeNode* node = new TreeNode(nums[mid]);

        node->left = createTree(nums,left,mid-1);
        node->right = createTree(nums,mid+1,right);
        
        return node;
    }
    
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return createTree(nums,0,nums.size()-1);
    }
```

### 24、力扣 538 把二叉搜索树转为累加树

```
给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
提醒一下，二叉搜索树满足下列约束条件：
节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。
注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

示例 1：
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

示例 2：
输入：root = [0,null,1]
输出：[1,null,1]

示例 3：
输入：root = [1,0,2]
输出：[3,3,2]

示例 4：
输入：root = [3,2,4,1]
输出：[7,9,4,10]
```

题解

用一个指针记录上一个结点的值

通过右中左的方式遍历，每次根结点加上指针值就可以了

递归法

```
TreeNode* pre = nullptr;
    TreeNode* convertBST(TreeNode* root) {
        if(!root) return root;
        if(root->right) convertBST(root->right);
        
        if(pre)
            root->val += pre->val;
            pre = root;
        if(root->left) convertBST(root->left);

        return root;
    }
```

迭代法

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    TreeNode* convertBST(TreeNode* root) {
        stack<TreeNode*>st;
        TreeNode* node = root;
        int pre=0;
        while(node || !st.empty()){
            while(node){
                st.push(node);
                node = node->right;
            }

            node = st.top();
            st.pop();
            node->val +=pre;
            pre = node->val;

            node = node->left;
        }
        return root;
    }
};
```

