---
title: 数组&&双指针
categories: 力扣
date: 2024-03-12 16:28:45
tags: 力扣


---

# 数组&&双指针

<!--more-->

## 例题

### 1、力扣	704 二分查找

```
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

解法：没啥好说的，记就完事了

注意开闭的区别

开区间的left和right就直接等于mid

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int right = nums.size()-1;
        int left =0;
        int mid = (right+left) /2;
        
        while(nums[mid] != target){
            if(nums[mid] < target) left = mid+1;
            else if(nums[mid] > target) right =  mid -1;
            mid = (right+left) / 2;
            if(left > right) return -1;
        }
        return mid;
    }
};
```

### 2、力扣 27 移除元素

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1：

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

解法：双指针

定义一个快指针用来遍历，一个慢指针用来存放结果

如果快指针指到的元素是我们需要的，慢指针就存放快指针当前存放的元素，并且向前进一步

```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow =0;
        for(int fast=0;fast<nums.size();fast++)
            if(nums[fast]!=val) 
                nums[slow++] = nums[fast];
        return slow;
    }
};
```

### 3、力扣 977 有序数组的平方

```
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
示例 2：

输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

解法：

定义头尾双指针，还需要一个存放用的指针

因为在本题中是已经有序的带负数的数组，那么它平方后的趋势就是头尾大，中间小

所以我们可以用两个指针一头一尾，判定，将大的存放到ans后面，存放过的指针就--，小的不动

```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0, j = n - 1, pos = n - 1; i <= j;) {
            if (nums[i] * nums[i] > nums[j] * nums[j]) {
                ans[pos] = nums[i] * nums[i];
                ++i;
            }
            else {
                ans[pos] = nums[j] * nums[j];
                --j;
            }
            --pos;
        }
        return ans;
    }
};
```

### 4、 力扣 209 长度最小的子数组

```
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 连续
子数组
 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

解法：

这题可以用到一个滑动窗口的思想

从第一个元素开始累加，一直到满足条件为止是第一个长度大小。

此时先将下标定在这里。从开头开始减去元素，看看是否还满足条件。

期间每次操作后都记录长度大小的最小值

如此反复一直到数组末尾即可

```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left=0;
        int ans = INT_MAX;
        int sum=0;
        for(int right=0;right<nums.size();right++){
            sum+=nums[right];
            while(sum >= target){
                ans = min(ans,right-left+1);
                sum-=nums[left];
                left++;
            }
        }
        if (ans == INT_MAX) return 0;
        return ans;
    }
};
```

### 5、力扣 54 螺旋矩阵

```
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：


输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

解法：模拟它行走的路程

每次走完后可以理解为缩圈

走完第一行就把第一行剪掉就是了（top++）；

走完最后一列就把最后一列剪掉（right--）；

走完最后一行就把底端剪切（down--）；

走完第一列再把第一列剪除（left++）；

直到上边界遇到下边界，或者左边界碰上右边界

```
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int top = 0; //赋值上下左右边界
        int down = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;
        while(true)
        {
            for(int i = left; i <= right; ++i) ans.push_back(matrix[top][i]); //向右移动直到最右
            if(++ top > down) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = top; i <= down; ++i) ans.push_back(matrix[i][right]); //向下
            if(-- right < left) break; //重新设定右边界
            for(int i = right; i >= left; --i) ans.push_back(matrix[down][i]); //向左
            if(-- down < top) break; //重新设定下边界
            for(int i = down; i >= top; --i) ans.push_back(matrix[i][left]); //向上
            if(++ left > right) break; //重新设定左边界
        }
        return ans;
    }
};

```

