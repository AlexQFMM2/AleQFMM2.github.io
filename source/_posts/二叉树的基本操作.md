---
title: 二叉树的基本操作
categories: C-数据结构
date: 2023-11-9 17:11:45
tags: 数据结构-程序


---

# 二叉树的基本操作

## 一、头文件和全局变量

```
#include<stdio.h>
#include<stdlib.h>

char str_pre[]  = "ABDGCEFH\0";
char str_in[]   = "DGBAECFH\0";
char str_post[] = "GDBEHFCA\0";
```

<!--more-->

## 二、结构体

```
typedef struct BITNode{
	char data;
	struct BITNode *lchild,*rchild;
}BITNode,*BITree;
```

###### 求数组长度

```
int Str_len(char s[]){
	int i=0;
	while(s[i++]);
	return i-1;
}
```

## 三、根据两个序列创建

###### 先中创建 

```
BITree BITree_Create_pre_and_in(char str_pre[], char str_in[], int n) {//
	if (n == 0){
		return NULL;
	}
	int k = 0;
	while (str_pre[0] != str_in[k]){//遍历寻找到根结点
		k++;
	}
	BITNode *newnode = (BITNode*)malloc(sizeof(BITNode));
	

	newnode->data = str_in[k];
	//参数应该是先序序列的下一个结点，中序序列，中序序列到根节点的长度
	newnode->lchild = BITree_Create_pre_and_in(str_pre + 1, str_in, k);
	//参数为先序序列的右子树开始位置，中序序列的根节点后面的序列，树的总长度减去左子树长度再减一
	newnode->rchild = BITree_Create_pre_and_in(str_pre + k + 1, str_in + k + 1, n - k - 1);
	
	return newnode;

}
```

###### 中后创建 

```
BITree BITree_Create_post_and_in(char str_post[],char str_in[], int n){//
	if (n == 0){
	    return NULL;
	}
	int k = 0;
	while (str_post[n-1] != str_in[k]){//遍历寻找到根结点
		k++;
	}

	BITNode *newnode = (BITNode*)malloc(sizeof(BITNode));
	newnode->data = str_in[k];
	//参数应该是后序序列的当前结点，中序序列，中序序列到根节点的长度
	newnode->lchild = BITree_Create_post_and_in(str_post,str_in,k);
	//参数为后序序列的右子树开始位置，中序序列的根节点后面的序列，树的总长度减去左子树长度再减一
	newnode->rchild = BITree_Create_post_and_in(str_post+k,str_in+1+k,n-k-1);
	return newnode;

}
```

## 四、遍历

```
void PreOrder(BITree T1){//先序遍历 
	if(T1!=NULL){
		printf("%c",T1->data);//访问根结点 
		PreOrder(T1->lchild);//遍历左子树 
		PreOrder(T1->rchild);//遍历右子树 
	}
}

void InOrder(BITree T1){//中序遍历 
	if(T1!=NULL){
		InOrder(T1->lchild);//遍历左子树
		printf("%c",T1->data);//访问根结点  
		InOrder(T1->rchild);//遍历右子树 
	}
}

void PostOrder(BITree T1){//后续遍历 
	if(T1!=NULL){
		PostOrder(T1->lchild);//遍历左子树
		PostOrder(T1->rchild);//遍历右子树 
		printf("%c",T1->data);//访问根结点  
	}
}
```

## 五、求深度（从1开始）

```
int BITree_deep(BITree T1){//求二叉树的深度 
	if(T1 == NULL){
		return 0;
	}
	else{
		int l = BITree_deep(T1->lchild);
		int r = BITree_deep(T1->rchild);
		return l>r ? l+1 : r+1;
	}
} 
```

## 六、求总结点个数

```
int BIT_count(BITree T1){//求结点个数 
	if(T1 == NULL) return 0;
	return BIT_count(T1->lchild) + BIT_count(T1->rchild) + 1;
} 
```

## 七、求叶子结点个数（无子节点的结点）

```
int BIT_left_count(BITree T1){//求叶子结点个数 
	if(T1 == NULL) return 0;
	if(T1->lchild == NULL && T1->rchild == NULL) return 1;
	return BIT_left_count(T1->lchild)+BIT_left_count(T1->rchild);
} 
```

## 八、交换左右子树

```
void BIT_Exchange(BITree T1){//交换每个结点的左右子树 
	BITNode *p;
	if(T1 == NULL) return;
	if(T1->lchild == NULL && T1->rchild == NULL) return;
	

	else{
		BIT_Exchange(T1->lchild);
		BIT_Exchange(T1->rchild);
		p = T1->lchild;
		T1->lchild = T1->rchild;
		T1->rchild = p;
	}

}
```

## 九、输出和清除（后序清除）

```
void BITree_print(BITree T1){
	printf("先序遍历为:");
	PreOrder(T1);
	printf("\n中序遍历为:");
	InOrder(T1);
	printf("\n后序遍历为:");
	PostOrder(T1);
	printf("\n二叉树深度为:%d\n",BITree_deep(T1));
	printf("二叉树结点个数为:%d\n",BIT_count(T1));
	printf("二叉树叶子结点个数为:%d\n",BIT_left_count(T1));
}
```

```
void BITree_clear(BITree T1){
	if(T1!=NULL){
		BITree_clear(T1->lchild);//遍历左子树
		BITree_clear(T1->rchild);//遍历右子树 
		free(T1);//访问根结点  
	}
}
```

## 十、主函数

```
int main(){

	printf("由先序遍历%s和中序遍历%s得出二叉树:\n",str_pre,str_in);
	BITree T1 =BITree_Create_pre_and_in(str_pre,str_in,Str_len(str_pre));
	BITree_print(T1);
	
	printf("由后序遍历%s和中序遍历%s得出二叉树:\n",str_post,str_in);
	BITree T2 =BITree_Create_post_and_in(str_post,str_in,Str_len(str_post));
	BITree_print(T2);

	printf("交换每个结点的左右子树为:\n");
	BIT_Exchange(T1);
	BITree_print(T1);
	
	BITree_clear(T1);
	printf("T1已消除\n");

	BITree_clear(T2);
	printf("T2已消除\n");

}
```

