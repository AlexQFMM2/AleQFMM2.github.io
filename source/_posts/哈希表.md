---
title: 哈希表
categories: 力扣
date: 2024-03-14 16:20:45
tags: 力扣


---

# 哈希表

```
有序表：map

无序表： unordered_map

定义 :unordered_map<int,int>hash

赋值 :hash[i] = i;

查找.find()

计数.count()
```

<!--more-->

# 一、例题

## 1、力扣 242 有效的字母异位词

```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
 
```

题解：

因为本题范围只有26个字母，所以可以采用数组代替hash表，用下标代表a-z的字母

判断异位词，换句话说就是判断他们两个之间的字符是否完全相同

遍历第一个字符串，将每个元素出现次数记录下来。

再遍历第二个字符串，将每个元素出现一次减少一次

如果最后数组中有非0元素，那说明有元素没有出现（多出现了）

```
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.size()!=t.size()) return false;
        int check[27] = {0};
        for(int i=0;i<s.length();i++){
            check[s[i]-'a']++;
            check[t[i]-'a']--;
        }
        
        for(int i : check){
            if(i != 0 )return false;
        }
         return true;
    }
};
```



## 2、力扣 349 两个数组的交集

```
给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
 
```

题解：

先将两个数组都排序，定义两个下标分别指向两个数组首地址

因为不允许重复，所以可以判定当index不为头元素的时候，前一个元素和当前元素相同，那就直接下标++后continue

当遇到两个数组中相等的元素时把他加入ans

并且因为答案的不可重复，可以直接全部++

如果数组1的元素大于数组二的元素，因为数组是排序过的，所以只要让数组二的下标++就行

小于同理

```
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<int> ans;
        if(nums1.size() == 0 || nums2.size() == 0) return ans;
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        int index1=0,index2=0;
        
        while(index1<nums1.size() && index2<nums2.size()){
            if(index1!=0&&nums1[index1] == nums1[index1-1]) {
                index1++;
                continue;
            }
            if(index2!=0&&nums2[index2] == nums2[index2-1]) {
                index2++;
                continue;
            }
            
            if(nums1[index1] == nums2[index2]) {
                ans.push_back(nums1[index1]);
                index1++;
                index2++;
            }
            else if(nums1[index1] < nums2[index2]) index1++;
            else   index2++;
        }
        
        
        return ans;
    }
};
```



## 3、力扣 1 两数之和

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
```

题解：

很简单，将数据都存入hashmap中后，将指针指向第一个元素

我们需要找的目标就是target-第一个元素

向hashmap中找有没有这个元素，有就返回，没有继续

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> check_map;
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            // 记录每个数字的索引
            check_map[nums[i]] = i;
        }
        for (int i = 0; i < nums.size(); i++) {
            int temp = target - nums[i];
            // 检查是否存在配对
            if (check_map.count(temp) && check_map[temp] != i) {
                return {i, check_map[temp]};
            }
        }
        return ans;
    }
};

```

## 4、力扣 15三数之和

```
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
示例 2：

输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
示例 3：

输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
 
```

题解：

其实这题可以用回溯做，但是会超时，剪枝剪不了一点

首先我们将数组排序

需要一个指针i从头到倒数第三个元素遍历（三元组，保证有两个元素空余）

因为数组是有序的 那么 i和后两个元素相加如果已经大于target了的话，那说明已经不存在符合条件的组合了，直接break

如果i和数组末尾的两个元素相加还小于target的话，那说明当前的i不可能符合条件，向后寻找更大的i，continue

我们假设（i）和末尾的元素（right）就是我们需要的元素之一，

那么我们需要的第三个元素就是0-i-right

我们设一个left，他从i的后一个元素开始遍历

那么right就是决定sum的最大值，left就是决定sum的最小值

那我们只需要移动left就可以找到目标的元素

当left>right的时候，组合就不存在了，可以继续下一个循环了

当sum比traget小的时候，left就得++

当sum大于traget的时候，right就得--

当sum等于traget的时候，我们就可以存放一个组合了。

注意题目要求不重复，那么如果left右边的元素/right左边的元素和当前的left/right相同，那就继续移动。



```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());
        int n = nums.size();

        for (int i = 0; i < n - 2; i++) {//三元组i最多到倒数第3个元素
            if (nums[i] > 0) break;
            if (i > 0 && nums[i] == nums[i - 1]) continue; 

            int traget = 0 - nums[i];
            if(nums[i+1] + nums[i+2] > traget) break;//剪枝
            if(nums[n-1] + nums[n-2] < traget) continue;
            int left = i + 1;
            int right = n - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    ans.push_back({nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) left++; //注意重复
                    while (left < right && nums[right] == nums[right - 1]) right--; 
                    left++;
                    right--;
                } else if (sum < 0) {//小于0left就右移，也不用担心相同元素，因为就算相同也是小于
                    left++;
                } else {//right同理
                    right--;
                }
            }
        }
        return ans;
    }
};

```

## 5、力扣 18四数之和

```
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

 

示例 1：

输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
示例 2：

输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

题解：这题和三数之和相比就是多嵌套了一层

```
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for(int i = 0; i < n - 3; i++)
        {
            if (i > 0 && nums[i] == nums[i-1]) continue;

            if ((long)nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;//前4个元素就是最小的了，如果4个最小加起来还大于目标值，那就没必要看了

            if ((long)nums[i] + nums[n-1] + nums[n-2] + nums[n-3] < target) continue;//最后三个一定是最大的，如果当前元素加上最后三个还是小于目标值，那就直接continue

            for(int j = i + 1; j < n - 2; j++)
            {
                if (j > i + 1 && nums[j] == nums[j-1]) continue; //去除重复
                
                int newTarget = target - nums[i] - nums[j]; //目标值是减去i,j后的元素
                if (nums[j+1] + nums[j+2] > newTarget) break;//前两个元素就是最小的了，如果两个最小加起来还大于目标值，那就没必要看了
                if (nums[n-2] + nums[n-1] < newTarget) continue;//最后两个一定是最大的，如果当前元素加上最后两个还是小于目标值，那就直接continue
                
                int left = j + 1, right = n - 1;//下面和仨数之和一样
                while (left < right)
                {
                    long value = (long)nums[i] + nums[j] + nums[left] + nums[right];
                    if(value == target)
                    {
                        res.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while(left < right && nums[left] == nums[left+1]) left++;
                        while(left < right && nums[right] == nums[right-1]) right--;
                        left ++ ;
                        right -- ;
                    }
                    else if (value < target ) left++;
                    else right -- ;
                }     
            }
        }
        return res;
    }
};
```

## 6、力扣 454四数相加

```
给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
 

示例 1：

输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
示例 2：

输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

题解：

这题我们要将问题换过来思考

abcd四个数相加，可以看成是 (a+b) + (c+d)

分开归纳

用两层循环遍历a，b相加的和的所有可能，存入哈希表中

同样用两层循环遍历c，d相加的和的所有可能，和哈希表中的数值对比

因为target是0，所以看看有没有相反数

有的话就ans++

```
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
            int ans=0;
            unordered_map<int,int> A_B_Sum;
            //将nums1和nums2数组中的所有和可能，计数存入哈希表中
            for(int i:nums1){
                for(int j :nums2){
                    ++A_B_Sum[i+j];
                }
            }
            //将所有nums3nums4和的可能的相反数，去哈希表中找，即可找到所有和为0的可能
            for(int i:nums3){
                for(int j:nums4){
                    if(A_B_Sum.count(-i-j)){
                        ans+=A_B_Sum[-i-j];
                    }
                }
            }
            return ans;
    }
};
```

## 7、力扣 202快乐数

```
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

示例 1：

输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：

输入：n = 2
输出：false
```

题解：

这题的关键在于重复

当sum的重复为1时，就为真

当sum的重复为其他时，就为假

用一个哈希记录所有sum可能

如果在哈希中遇到一样的，就看时什么

如果没遇到过就加入到哈希中

```
class Solution {
public:
    // 取数值各个位上的单数之和
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    
    bool isHappy(int n) {
        unordered_map<int,int> check_map;
        while(1) {
            int sum = getSum(n);
            if (sum == 1) {
                return true;
            }
            // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
            if (check_map.count(sum) > 0) {
                return false;
            } else {
                check_map[sum] = sum;
            }
            n = sum;
        }
    }
};
```



## 8、力扣 383赎金信

```
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

示例 1：

输入：ransomNote = "a", magazine = "b"
输出：false
示例 2：

输入：ransomNote = "aa", magazine = "ab"
输出：false
示例 3：

输入：ransomNote = "aa", magazine = "aab"
输出：true
```

题解：因为有个条件：magazine 中的每个字符只能在 ransomNote 中使用一次。

所以这题就变成了，ransomNote 中出现的字符，是不是都在magazine中出现的过

和异位词有异曲同工之处。先记录magazine 中每个字符出现的次数

然后遍历ransomNote，开始进行删减

如果哈希数组中出现了负数值，那么说明ransomNote中有magazine没有的字符

return false

```
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int cheak[27] = {0};
        for(char ch:magazine){
            cheak[ch-'a']++;
        }
        for(char ch : ransomNote){
            cheak[ch-'a']--;
        }
        for(int i: cheak){
            if(i < 0) return false;
        }
        return true;
    }
};
```

