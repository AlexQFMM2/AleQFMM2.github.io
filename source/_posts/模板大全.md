---
title: 模板大全
categories: 算法专项
date: 2024-05-27 13:18:45
tags: 算法基础




---

# 模板大全

# 二分模板

```
本文档绝大多数程序都是洛谷模板题
```



## 基础二分（寻找x在有序数列中的下标，不存在返回-1）

```
int search(int x){
	int l=0,r=N-1;
	while(l<=r){
		int mid = l+r >> 1;
		if(a[mid] > x) r = mid-1;
		else if(a[mid] < x) l=mid+1;
		else return mid;
	}
	return -1'
}
```

## 区间二分（寻找重复值的左端点）

```
bool check(int mid,int x){
	return nums[mid] >= x
}

int searchL(int x){
	int l=0,r=N-1;
	while(l<r){
		int mid = l+r >> 1;
		if(check(mid,x)) r=mid;
		else l=mid+1;
	}
	return l;
}
```

## 区间二分（寻找重复值的右端点）

```
bool check(int mid,int x){
	return nums[mid] <= x
}

int searchR(int x){
	int l=0,r=N-1;
	while(l<r){
		int mid = l+r+1 >> 1;//不加1会死循环
		if(check(mid,x)) l=mid;
		else r=mid-1;
	}
	return r;
}
```

ps:根据实际情况修改check就是了

# 前缀和模板

```
适用于简单的单点修改和查询、区间和查询、区间最值查询等，是最简单的数据结构之一，但不支持区间修改
```



## 一维数组

```
#include<iostream>
using namespace std;
using ll = long long;
const int N = 1e5+10;
ll a[N],b[N],n,m;

int main(){
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    for(int i=1;i<=n;i++){
        a[i] += a[i-1];
    }
    cin >> m;
    while(m--){
        int l,r;
        cin >>  l >> r;
		cout << a[r] - a[l-1] << endl;
    }
    
    return 0;
}
```

利用前缀和找无序数组分割线，让他两边差值最小（未验证）

```
#include<iostream>
#include<vector>
using namespace std;
using ll = long long;

const int N = 10;

int nums[N] = {0,1,3,5,7,9,2,4,6,8};//1-9
int sum[N] = {0};

int getSum(int l,int r){
	return sum[r] - sum[l-1];
}

int main(){
	sum[1] = nums[1];
	for(int i=2;i<N;i++){
		sum[i] = sum[i-1] + nums[i];
	}
	
	for(int i=1;i<N;i++)  cout << sum[i] << " ";
	cout << endl;
	
	int ans = 2;//分割线在2前面 
	int minDiff = getSum(2,N-1) - getSum(1,1); 

	
	for(int i = 3;i<N;i++){
		int diff = abs(getSum(i,N-1) - getSum(1,i));

		if(diff < minDiff){
			minDiff = diff;
			ans = i;
		}
	}
	cout << ans << ":" << getSum(1,ans) << "-" << getSum(ans+1,N-1) << "=" << minDiff <<  endl;
	
	return 0;
}

```

## 二维数组

```
#include<iostream>
using namespace std;
const int N = 1e3+10;
int metriax[N][N],row,col,q;

int main(){
    
    cin >> row >> col >> q;
    for(int i = 1; i <= row; i++){
        for(int j = 1; j <= col; j++){
            cin >> metriax[i][j];
            metriax[i][j] = metriax[i][j] + metriax[i-1][j] + metriax[i][j-1] - metriax[i-1][j-1]; 
        }
    }
    while(q--){
        int sum = 0;
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;

        cout << metriax[x2][y2] - metriax[x1-1][y2] - metriax[x2][y1-1] + metriax[x1-1][y1-1] << endl;
    }
    
    return 0;
}
```

# 差分模板

```
适用于高效实现区间修改和查询，构建和维护成本稍高，但是不支持复杂的区间操作
```

## 一维数组

```
#include<iostream>
using namespace std;
const int N=5;
int nums[N+1]={0,1,3,5,7,9};//原数组 
int sub[N+1];//差分数组 

int main(){
	for(int i=1;i<=N;i++)
		sub[i] = nums[i] - nums[i-1];//差分预处理
		 
	int l=2,r=4,x=3;//[l,r]+x;
	sub[l] += x;
	sub[r+1] -= x;
	
	for(int i=1;i<=N;i++){//还原数组 
		nums[i] = nums[i-1] + sub[i];
	}
	return 0;
}
```

## 二维矩阵

```
#include <iostream>
using namespace std;
const int N = 1e3+10;
int nums[N][N],diff[N][N],row,col,q;

int main() {
    cin >> row >> col >> q;
    
    for (int i = 1; i <= row; i++) {// 读入原始矩阵
        for (int j = 1; j <= col; j++) {
            cin >> nums[i][j];
        }
    }
    
    for (int i = 1; i <= row; i++) {// 构建差分矩阵
        for (int j = 1; j <= col; j++) {
            diff[i][j] = nums[i][j] - nums[i - 1][j] - nums[i][j - 1] + nums[i - 1][j - 1];
        }
    }
    
    while (q--) {// 区间修改
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        
        diff[x1][y1] += c;
        diff[x2 + 1][y1] -= c;
        diff[x1][y2 + 1] -= c;
        diff[x2 + 1][y2 + 1] += c;
    }
    
    for (int i = 1; i <= row; i++) {// 构建最终的矩阵
        for (int j = 1; j <= col; j++) {
            nums[i][j] = diff[i][j] + nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1];
        }
    }
    
    for (int i = 1; i <= row; i++) {// 输出最终矩阵
        for (int j = 1; j <= col; j++) {
            cout << nums[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

# 快速幂模板

```
#include<iostream>
using namespace std;
using ll = long long;

ll power(ll a,ll b,ll p){
	int ans=1;
	while(b){
		if(b&1) ans = (ans*a)%p;
		a = (a*(ll)a)%p;
		b >>=1;
	}
	return ans;
}

int main(){
	ll a,b,p;
	cin >> a >> b >> p;
	printf("%ld^%ld mod %ld=%ld",a,b,p,power(a,b,p));
	return 0;	
}
```

扩展：

```
求a*x 同余 1 (mod p)

可以用费马小定理，快速幂解决
即power(a,p-2,p);
```



# 筛选素数模板

```
#include<iostream>
#include<vector>
using namespace std;
using ll = long long;
const ll N = 1e8 + 10;

vector<bool> isPrime(N, true);
vector<ll> prime;

void init(ll n) {
    isPrime[0] = isPrime[1] = false;
    for (ll i = 2; i <= n; i++) {
        if (isPrime[i]) {
            prime.push_back(i);
            for (ll j = i * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }
}

int main() {
    ll n, q;
    cin >> n >> q;
    init(n);
    while (q--) {
        ll k;
        cin >> k;
        cout << prime[k - 1] << endl;
    }
    return 0;
}
```

# 字符串hash模板

原理：将字符串映射成p进制数

```
#include<iostream>
#include<vector>
using namespace std;
using ll = long long;
const int MOD = 1e9+7;//防止溢出
const int P =131;//错误率最低
const int N = 1010;
ll checkhash(const string& s){//计算hash值 
	ll sum;
	int n = s.size();
	for(int i=1;i<=n;i++){
		sum = (sum*P+s[i])%MOD;
	}
	return sum;
}

bool isIn(vector<ll>ans,ll x){
	for(ll i:ans) if(i==x) return false;
	return true;
}

int main(){
	ll n;
	cin >> n;
	vector<ll>ans;
	while(n--){
		string s;
		cin >> s;			
		ll sv = checkhash(s);//计算hash值，如果已经存在那就不存了
		if(isIn(ans,sv)) ans.push_back(sv);d
	}

	cout << ans.size() << endl;
	return 0;
}
```

# Floyd模板

```
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
const int N = 1e4;
const int INF = 0x3f3f3f3f;
int grid[N][N],n,m;

int main() {
	cin >> n >> m;
	memset(grid,INF,sizeof(grid));
	
	for(int i=1;i<=n;i++) grid[i][i] = 0;//到自己的距离为0 
	
	for(int i=1; i<=m; i++) {//输入边 
		int x,y,v;
		cin >> x >> y >> v;
		grid[x][y] = min(grid[x][y],v);
		grid[y][x] = min(grid[y][x],v);
		
	}

	for(int k=1; k<=n; k++) {//核心代码 
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n; j++) {
				if(grid[i][k]!=INF&&grid[k][j]!=INF) {
					grid[i][j] = min(grid[i][j],grid[i][k]+grid[k][j]);
				}
			}
		}
	}

	for(int i=1; i<=n; i++) {//输出处理后的矩阵 
		for(int j=1; j<=n; j++) {
			cout << grid[i][j]<< " ";
		}
		cout << endl;
	}

	return 0;
}
```

扩展：

他也可以用来传递闭包-》也就是检查图的联通性

```
#include <iostream>
using namespace std;

const int N = 110;
int n;
int a[N][N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> a[i][j];

    for (int k = 1; k <= n; k++)//Floyd 
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                a[i][j] |= (a[i][k] & a[k][j]); // 用逻辑与操作更新传递闭包

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            cout << a[i][j] << " ";
        cout << endl;
    }

    return 0;
}

```



# 拓扑排序模板

```
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
const int N=110;
int degree[N];
vector<int>grid[N];
int main(){
	int n;
	cin >> n;
	for(int i=1;i<=n;i++){
		while(1){
			int x;
			cin >> x;
			if(x==0) break;
			grid[i].push_back(x);
			++degree[x];
		}
	}
	queue<int>q1;
	for(int i=1;i<=n;i++)
		if(degree[i] == 0) q1.push(i); 
	vector<int>ans;
	
	while(!q1.empty()){
		int u = q1.front();
		q1.pop();
		ans.push_back(u);
		for(int v:grid[u]){
			if(--degree[v] == 0){
				q1.push(v);
			}
		}
	}
	for(int i:ans) cout << i << " ";
	
	return 0;
} 
```

# 滑动窗口模板

```
#include<iostream>
#include<queue>
using namespace std;
using ll = long long;
const int N = 1e5+10;
ll nums[N];
deque<int>dq;
int n,k;

bool op(ll x,ll y,bool flag){//true:找最大值，false：找最小值
	if (flag)
		return x > y;
	else
		return x < y;
}

vector<ll> FindInWindows(bool flag){
 	vector<ll>ans;
 	
 	for(int i=0;i<n;i++){
 		if(!dq.empty() && dq.front() == i-k){//队首下标超出范围了
 			dq.pop_front();	
		}
		while(!dq.empty() && op(nums[i],nums[dq.back()],flag)){//从队尾开始，不符合条件的都干掉
 			dq.pop_back();	
		}
		
		dq.push_back(i);
		
		if(i >= k+1){
			ans.push_back(nums[dq.front()]);
		}
	}

	return ans;	
}

int main(){
	
	cin >> n >> k;
	for(int i=0;i<n;i++) cin >> nums[i];

	vector<ll>ans1 = FindInWindows(false);
	dq.clear();
	vector<ll>ans2 = FindInWindows(true);
	
	for(ll i:ans1) cout << i << " ";
	cout << endl;
	for(ll i:ans2) cout << i << " ";
	cout << endl;
	
	return 0;
}
```

## 优先队列解法

```
#include<iostream>
#include<queue>
using namespace std;
using PILL = pair<int,int>;

priority_queue<PILL>pq1;
priority_queue<PILL,vector<PILL>,greater<PILL>>pq2;
int main(){
	int n,k;
	cin >> n >> k;
	vector<int>ans1,ans2;
	for(int i=1;i<=n;i++){
		int x;
		cin >> x;
		pq1.push({x,i}),pq2.push({x,i});
		if(i>=k){
			while(i - pq1.top().second >= k) pq1.pop();
			ans2.push_back(pq1.top().first);
			while(i - pq2.top().second >= k) pq2.pop();
			ans1.push_back(pq2.top().first);
		}
	}
	for(int i:ans1) cout << i << " ";
	cout << endl;
	for(int i:ans2) cout << i << " ";
	cout << endl;
	return 0;
}
```



# 裴蜀定理

## 题目描述

给定一个包含 $n$ 个元素的**整数**序列 $A$，记作 $A_1,A_2,A_3,...,A_n$。

求另一个包含 $n$ 个元素的待定**整数**序列 $X$，记 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

## 输入格式

第一行一个整数 $n$，表示序列元素个数。  

第二行 $n$ 个整数，表示序列 $A$。

## 输出格式

一行一个整数，表示 $S>0$ 的前提下 $S$ 的最小值。

## 样例 #1

### 样例输入 #1

```
2
4059 -1782
```

### 样例输出 #1

```
99
```

## 提示

对于 $100\%$ 的数据，$1 \le n \le 20$，$|A_i| \le 10^5$，且 $A$ 序列不全为 $0$。

```
对于任意给定的整数a和b，存在整数x和y，使得它们满足方程ax + by = gcd(a, b)
```



```
#include<iostream>
using namespace std;
int n;

int gcd(int x,int y){
	if(y==0) return x;
	return gcd(y,x%y);
}

int main(){	
	cin >> n;
	int ans=0;
	for(int i=1;i<=n;i++){
		int tmp;
		cin >> tmp;
		if(tmp <0) tmp =-tmp;
		ans = gcd(ans,tmp);
	}
	cout << ans;
	return 0;
}
```

# 单调栈模板

```
#include<iostream>
#include<stack>
using namespace std;
using ll = long long;
const int N = 3e6+10;
ll nums[N],ans[N];

int main(){	
	ll n;
	cin >> n;
	for(int i=0;i<n;i++) cin >> nums[i];
	stack<ll>st1;
	st1.push(0);
	for(int i=1;i<n;i++){
		while(!st1.empty() && nums[i] > nums[st1.top()]){
			ans[st1.top()] = i+1;
			st1.pop();
		}
		st1.push(i);
	}
	
	for(int i=0;i<n;i++) cout << ans[i] << " ";
	return 0;
}
```

# 并查集模板

```
#include<iostream>
using namespace std;
using ll = long long;
const int N = 1e4+10;

int fa[N];

int find(int x){
	if(x!=fa[x]){
		fa[x] = find(fa[x]);
	}
	return fa[x];
}

int main(){
	int n,m;
	cin >> n >> m;
	for(int i=1;i<=n;i++) fa[i] = i;
	
	while(m--){
		int op,x,y;
		cin >> op >> x >> y;
		int px =find(x),py=find(y);
		if(op == 2){
			if(px == py) cout <<"Y"<<endl;
			else cout << "N" << endl;
		}else{
			fa[py] = px;
		}
	}
	
	return 0;
}
```

# 倍增法LCA模板

```
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
const int N=5e5+10;

vector<int>tree[N];
int depth[N];
int fa[N][20];
bool visited[N]={false};

void bfs(int root){
	queue<int>q1;
	q1.push(root);
	depth[root] = 1;
	fa[root][0] = root;
	
	while(!q1.empty()){
		int par = q1.front();
		q1.pop();
		visited[par] = true;
		for(int v:tree[par]){
			if(!visited[v]){
				depth[v] = depth[par]+1;
				fa[v][0] = par;
				for(int j=1;j<20;j++){
					fa[v][j] = fa[fa[v][j-1]][j-1];
				}
				q1.push(v);
			}
		}
	}
}

int lca(int x,int y){
	if(depth[x] > depth[y]) swap(x,y);
	for(int i=19;i>=0;i--){
		if(depth[fa[y][i]] >= depth[x]){
			y = fa[y][i];
		}
	}
	if(x == y) return x;
	for(int i=19;i>=0;i--){
		if(fa[y][i]!=fa[x][i]){
			y = fa[y][i];
			x = fa[x][i];
		}
	}
	return fa[x][0];
}

int main(){
	ios_base::sync_with_stdio(false);//洛谷上的原题，不加会有一个点超时
    cin.tie(nullptr);
	int n,m,root;
	cin >> n >> m >> root;
	for(int i=1;i<=n-1;i++){
		int x,y;
		cin >> x >>y;
		tree[x].push_back(y);
		tree[y].push_back(x);
	}
	bfs(root);
	
	while(m--){
		int x,y;
		cin >> x >> y;
		cout << lca(x,y) << endl;
	}
	
	return 0;
}
```

# 【模板】三分 | 函数

## 题目描述

给定 $n$ 个二次函数 $f_1(x),f_2(x),\dots,f_n(x)$（均形如 $ax^2+bx+c$），设 $F(x)=\max\{f_1(x),f_2(x),...,f_n(x)\}$，求 $F(x)$ 在区间 $[0,1000]$ 上的最小值。

## 输入格式

输入第一行为正整数 $T$，表示有 $T$ 组数据。

每组数据第一行一个正整数 $n$，接着 $n$ 行，每行 $3$ 个整数 $a,b,c$，用来表示每个二次函数的 $3$ 个系数，注意二次函数有可能退化成一次。

## 输出格式

每组数据输出一行，表示 $F(x)$ 的在区间 $[0,1000]$ 上的最小值。答案精确到小数点后四位，四舍五入。

## 样例 #1

### 样例输入 #1

```
2
1
2 0 0
2
2 0 0
2 -4 2
```

### 样例输出 #1

```
0.0000
0.5000
```

## 提示

对于 $50\%$ 的数据，$n\le 100$。

对于 $100\%$ 的数据，$T<10$，$\ n\le 10^4$，$0\le a\le 100$，$|b| \le 5\times 10^3$，$|c| \le 5\times 10^3$。



```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int N=10010;
const double INF=-2e9;
const double EPS = 1e-10;
int T,n;
double a[N],b[N],c[N];

inline double f(double x) {
	double ret=INF;
	for(int i=0; i<n; i++)
		ret=max(ret,a[i]*x*x+b[i]*x+c[i]);
	return ret;
}//内置的计算F(x)函数的值的函数


void slove() {
	cin >> n;
	for(int i=0; i<n; i++) cin >> a[i] >> b[i] >> c[i]; //读入
	double l=0,r=1000;
	while(r-l > EPS) {
		double mid1=(l+l+r)/3,mid2=(l+r+r)/3;
		double v1=f(l),v2=f(mid1),v3=f(mid2),v4=f(r);
		
		if(v1<v2)r=mid1;
		else if(v4<v3)l=mid2;
		else if(v1>v2&&v2<v3)r=mid2;
		else if(v4>v3&&v3<v2)l=mid1;
		else l=mid1,r=mid2;
	}
	printf("%.4lf\n",f(l));
}

int main() {
	cin >> T;
	while(T--) {
		slove();
	}
	return 0;
}
```

# Trie模板

核心部分

```
int cnt[N], Trie[N][65], nodeCnt;

int getNum(char ch) {
	if(ch >='A' && ch<='Z') return (ch-'A');
	else if(ch>='a' && ch<='z') return (ch-'a'+26);
	else return (ch-'0'+52);
}

void insert(const string& s) {
	int d = 0;
	for(char ch : s) {
		int idx = getNum(ch);
		if(Trie[d][idx] == 0) Trie[d][idx] = ++nodeCnt;
		d = Trie[d][idx];
		++cnt[d];//前缀
	}
	//++cnt[d] //完整
}

int getCnt(const string& s) {
	int d = 0;
	for(char ch : s) {
		int idx = getNum(ch);
		if(Trie[d][idx] == 0) return 0;
		d = Trie[d][idx];
	}
	return cnt[d];
}
```

## 扩展 ： AC自动机

```
#include<iostream>
#include<queue>
using namespace std;
const int N = 2e5+10;
const int M = 26;
//flag: 记录以当前字符为结尾的字符串编号,ID,排序前的编号
//vis:	记录了字符串编号为 u 的字符串在查询过程中出现的次数
//cnt:	记录了以节点 u 结尾的字符串的数量
//fail: 在 AC 自动机中与当前节点匹配失败时应跳转到的节点
int trie[N][M],flag[N],fail[N],ID[N],in[N],cnt[N],vis[N],node;
queue<int>q1;
string strs[N];

void insert(const string& s,int id) {
	int u = 1;//根从1开始 
	for(char ch:s) {
		int v = ch-'a';//只有小写
		if(!trie[u][v]) trie[u][v] = ++node;
		u = trie[u][v];
	}
	if(!flag[u]) flag[u] = id;
	ID[id] = flag[u];
}

void bfs() {
	for (int i=0;i<26;++i) trie[0][i] = 1;
	q1.push(1);

	while (!q1.empty()) {
		int u = q1.front();
		q1.pop();

		for (int i=0;i<26;++i) {//遍历所有孩子 
			int v = trie[u][i];//孩子 
			if (v) {//存在 
				fail[v] = trie[fail[u]][i]; // 设置失败指针
				++in[fail[v]];
				q1.push(v); // 将子节点压入队列
			} else {//不存在 
				trie[u][i] = trie[fail[u]][i]; // 设置失配转移
			}
		}
	}
}

void topu(){
	
	for(int i=1;i<=node;i++){
		if(in[i] == 0) q1.push(i);
	}
	
	while(!q1.empty()){
		int u = q1.front();q1.pop();
		
		vis[flag[u]] = cnt[u];//原数组下边对应值 
		
		int v = fail[u]; 
		--in[v];
		cnt[v] += cnt[u];//次数累加 
		
		if(in[v] == 0) q1.push(v);
	}
}

void query(const string& s) {
    int u=1;//根从1开始 
    for(char ch:s){
    	int idx = ch-'a';
		u = trie[u][idx];
		++cnt[u];
	}
}

int main() {
	int n;
	cin >> n;
	node = 1;
	for(int i=1; i<=n; i++) {
		cin >> strs[i];
		insert(strs[i],i);
	}
	
	bfs();
	
	string s2;
	cin >> s2;
	query(s2);
	topu();
	
	for(int i=1;i<=n;i++)
		cout << vis[ID[i]] << endl;
	return 0;
}
```



# 树状数组模板

```
适用于单点修改和查询、区间和查询等简单操作，代码量小，操作高效，但不支持区间修改
```

前缀和

```
#include<iostream>
using namespace std;
const int N = 5e5+10;
int tree[N],n,m;

int lowbit(int x){//找最低位 
	return x&-x;
}

void add(int x,int k){//单点修改 
	while(x<=n){
		tree[x]+=k;
		x+=lowbit(x);
	}
}

int getSum(int x){//求单点的前缀和 
	int ans =0;
	while(x!=0){
		ans+=tree[x];
		x-=lowbit(x);
	}
	return ans;
}

void rangeAdd(int l, int r, int k) {//差分
    add(l, k);
    add(r + 1, -k);
}

int main(){
	cin >> n >> m;
	for(int i=1;i<=n;i++){
		int x;
		cin >> x;
		add(i,x);//第i个数加上x 
		//rangeAdd(i, i, x);// 差分
	}
	
	for(int i=1;i<=m;i++){
		int op,x,y;
		cin >> op >> x >> y;
		if(op == 2) cout << (getSum(y) - getSum(x-1)) <<endl;
		else add(x,y);//第x个数加上y 
	}
	
	return 0;
}
```

# 单源最短路径模板

```
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
using ll = long long;
using PILL = pair<ll,ll>;

const int N = 1e6+5;
const int INF = 0x3f3f3f3f;
ll n,m,dist[N],st;
vector<PILL>grid[N];
bool visited[N] = {false};

class MYCMP{
	public:
		bool operator()(const PILL& x,const PILL& y){
			return x.second > y.second;
		}
};

void minway(){
	priority_queue<PILL,vector<PILL>,MYCMP>pq;
	pq.push({st,0});
	dist[st] = 0;
	
	while(!pq.empty()){
		PILL u = pq.top();
		pq.pop();
		if(visited[u.first]) continue;
			visited[u.first] = true;
			
		for(PILL v:grid[u.first]){	
			if(dist[v.first] > dist[u.first]+v.second){
				dist[v.first] = dist[u.first]+v.second;
				pq.push({v.first,dist[v.first]});
			}
		}
		
	}
}


int main(){
	cin >> n >> m >> st;
	for(int i=1;i<=m;i++){
		ll x,y,z;
		cin >> x >> y >> z;
		grid[x].push_back({y,z});
		dist[i] = INF;
	}
	minway();
	
	for(int i=1;i<=n;i++) {
		if(dist[i] == INF) cout << 2147483647 << " ";//看题目要求
		else cout << dist[i] << " ";
	}
	
	return 0;
}
```

# 最小生成树模板

```
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 2e5+5;
struct way{
	int a,b,d;
}ways[N];

bool mycmp(way x,way y){
	return x.d  < y.d;
}

int fa[N];
int cnt;//集合数量 

int find(int x){
	if(x!=fa[x]){
		fa[x] = find(fa[x]);
	}
	return fa[x];
}

int main(){
	int n,m;
	cin >> n >> m;
	cnt = n;
    for(int i=1;i<=n;i++) fa[i] = i;
	
	for(int i=1;i<=m;i++){
		cin >> ways[i].a >> ways[i].b >> ways[i].d;
	} 
	sort(ways+1,ways+1+m,mycmp);
	int ans =0;
	
	for(int i=1;i<=m;i++){
		int x = ways[i].a,y=ways[i].b;
		int px = find(x),py=find(y);
		if(px!=py){
			fa[py] = px;
			--cnt;
			ans += ways[i].d;
		}
	}
	
	if(cnt > 1) cout << "orz" << endl;
	else cout << ans << endl;
	return 0;
}
```

# ST表模板

```
利用倍增思想来缩短时间，快速求区间的状态,本题是求最大值
范围
[1,i+2^j-1]
```



```
#include<iostream>
using namespace std;
const int N = 1e5+10;

int n,m,x,y,lg[N],st[N][20];//倍增思想，本题中记录 i到i+2^j次方-1范围中的最大值 

int main(){
	ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
	cin >> n >> m;
	lg[1]=0;//i小于等于2的lg[i]次方 
	for(int i=2;i<=n;i++) lg[i] = lg[i>>1]+1;
	
	for(int i=1;i<=n;i++) cin >> st[i][0];
	
	for(int j=1;j<=lg[n];j++){
		for(int i=1;i<=n-(1<<j)+1;i++){//边界范围：[1,n-2^j+1] 
			st[i][j] = max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
	}
	
	for(int i=1;i<=m;i++){
		cin >> x >> y;
		int l = lg[y-x+1];
		cout << max(st[x][l],st[y-(1<<l)+1][l]) << endl;
	}
	
}
```

# SPFA模板

```
判断负环用
```

```
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
using PILL = pair<int,int>;
const int INF = 0x3f3f3f3f;
const int N = 2e4;
vector<PILL>grid[N];


bool spfa(int start,int n){
	queue<int>q1;
	vector<bool>visited(n+1,false);
	vector<int>dist(n+1,INF),cnt(n+1,0);//cnt:入队次数 
	
	q1.push(start);
	dist[start] = 0;
	++cnt[start];
	visited[start] = true;
	
	while(!q1.empty()){
		int u = q1.front();
		q1.pop();
		visited[u] = false;
		for(auto v:grid[u]){
			if(dist[u]+v.second < dist[v.first]){
				dist[v.first] = dist[u]+v.second;
				
				if(!visited[v.first]){
					q1.push(v.first);
					visited[v.first] = true;
					if(++cnt[v.first] >= n) return true;
				}
				
			}
		}	
	}
	return false;
}


void solve(){
	int n,m;
	cin >> n >> m;
	for(int i=1;i<=m;i++){
		int u,v,t;
		cin >> u >> v >> t;
		if(t >= 0) grid[v].push_back({u,t});//看题目具体要求 
		grid[u].push_back({v,t});
	}
	if(spfa(1,n)) cout << "YES" << endl;
	else cout << "NO" << endl;
	
	for(int i=1;i<=n;i++) 
		grid[i].clear();//结束后清零 
}

int main(){
	int t;
	cin >> t;
	while(t--){
		solve();
	}
	return 0;
}
```

# KMP模板



```
#include<iostream>
using namespace std;
const int N =  1e6+5;
int Next[N];

void initNext(const string& s){
	int len = s.size(),j=0;
	for(int i=1;i<len;i++){
		while(j>0 && s[i]!=s[j]){
			j=Next[j-1];
		}
		if(s[i]==s[j]) j++;
		Next[i] = j;
	}
}

void KMP(const string& s1,const string& s2){
	int len1 = s1.size();
	int len2 = s2.size();
	int j=0;
	for(int i=0;i<len1;i++){
		while(j>0&&s1[i]!=s2[j]){
			j=Next[j-1];
		}
		if(s1[i] == s2[j]) j++;
		if(j==len2){
			cout << i-j+1+1 << endl;//下标从1开始 
			j = Next[j-1];
		}
	}
	for(int i=0;i<len2;i++) cout << Next[i] << " ";
}


int main(){
	string s1,s2;
	cin >> s1 >> s2;
	initNext(s2);
	KMP(s1,s2);
	return 0;
}

```

# 线段树模板

区间和版本

```
#include<iostream>
using namespace std;
using ll = long long;
const int N = 1e6+1;

ll tree[N<<1],lazy[N<<1],nums[N];

ll lc(ll x) {//左孩子(x*2) 
	return x<<1;
}

ll rc(ll x) {//右孩子(x*2+1) 
	return x<<1|1;
}

void fun(ll p ,ll l,ll r,ll k){//每次更新时的操作 
	tree[p] += k*(r-l+1);//k*区间里的元素个数
	//tree[p] += k;//最大值 
	lazy[p] += k; 
}

void push_up(ll p){//区间状态等于左孩子的状态（op）右孩子的状态 
	tree[p] = tree[lc(p)] + tree[rc(p)];
	//tree[p] = max(tree[lc(p)] , tree[rc(p)]);
}

void build(ll p,ll l,ll r){//后序遍历建树 
	lazy[p] = 0;
	
	if(l == r){
		tree[p] = nums[l];
		return ;
	}
	
	ll mid = (l+r) >> 1;
	build(lc(p),l,mid);
	build(rc(p),mid+1,r);
	push_up(p);
}

void push_down(ll p,ll l,ll r){//后序遍历传递lazy 
	ll mid = (l+r) >> 1;
	fun(lc(p),l,mid,lazy[p]);
	fun(rc(p),mid+1,r,lazy[p]);
	lazy[p] = 0;
}

ll find(ll x,ll y,ll l,ll r,ll p){//后序查询，先序更新 
	ll res = 0;
	if(x<=l&&r<=y) return tree[p];
	
	push_down(p,l,r);//查询时先序遍历 更新lazy
	ll mid = (l+r) >>1;
	
	//根据实际情况选择 
	if(x<=mid) res += find(x,y,l,mid,lc(p));//max(res,find(x,y,l,mid,lc(p)));
	if(y > mid) res += find(x,y,mid+1,r,rc(p));
	return res;
}

void update(ll x,ll y, ll l,ll r,ll p, ll k){//更新 
	if(x<=l&&r<=y){
		fun(p,l,r,k);
		return;
	}
	
	push_down(p,l,r);//先序更新
	ll mid = (l+r) >> 1;
	if(x <= mid) update(x,y,l,mid,lc(p),k);
	if(y > mid) update(x,y,mid+1,r,rc(p),k);
	push_up(p);//维护更新后的树 
}

int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	ll n,m;
	cin >> n >> m;
	for(int i=1;i<=n;i++) cin >> nums[i];
	build(1,1,n);
	
	while(m--){
		ll op,x,y,k;
		cin >> op >> x >> y;
		if(op == 1){//修改 
			cin >> k;
			update(x,y,1,n,1,k);
		}else{//查询 
			cout << find(x,y,1,n,1) << endl;
		}
	}
	
	//for(int i =1;i<=(n<<1);i++) cout << tree[i] << " ";
	
	return 0;
} 
```

###### 多状态维护

（既有加法，又有乘法-》双lazy维护）

```
#include<iostream>
using namespace std;
using ll = long long;
const int N =1e6+1;

ll n,m,mod,tree[N<<1],add_lazy[N<<1],mul_lazy[N<<1],nums[N];

ll lc(int x) {
	return x<<1;
}

ll rc(int x) {
	return x<<1|1;
}

void push_up(ll p) {
	tree[p] = (tree[lc(p)] + tree[rc(p)])%mod;
}

void build(ll p ,ll l, ll r) {
	add_lazy[p] = 0;
	mul_lazy[p] = 1;

	if(l==r) {
		tree[p] = nums[l];
		return;
	}

	ll mid = (l+r) >> 1;
	build(lc(p),l,mid);
	build(rc(p),mid+1,r);
	push_up(p);
}

void add_fun(ll p,ll l,ll r,ll k) { //加法
	tree[p] = (tree[p] + k*(r-l+1))%mod;
	add_lazy[p] = (add_lazy[p]+k)%mod;
}

void mul_fun(ll p,ll x,ll y,ll k) { //乘法
	tree[p] = (tree[p] * k)%mod;
	add_lazy[p] = (add_lazy[p] * k) % mod;
	mul_lazy[p] = (mul_lazy[p] * k)%mod;
}

void push_down(ll p, ll l, ll r) { //传递lazy
	if(mul_lazy[p]!=1) {
		ll mid = (l+r) >> 1;
		mul_fun(lc(p),l,mid,mul_lazy[p]);
		mul_fun(rc(p),mid+1,r,mul_lazy[p]);
		mul_lazy[p] = 1;
	}

	if(add_lazy[p]!=0) {
		ll mid = (l+r) >> 1;
		add_fun(lc(p),l,mid,add_lazy[p]);
		add_fun(rc(p),mid+1,r,add_lazy[p]);
		add_lazy[p] = 0;
	}
}

ll find(ll x,ll y,ll l, ll r,ll p) {
	ll res=0;
	if(x<=l&&r<=y) return tree[p];

	push_down(p,l,r);//更新p
	ll mid = (l+r) >> 1;
	if(x<=mid) res = (res+find(x,y,l,mid,lc(p)))%mod;
	if(y>mid) res = (res+find(x,y,mid+1,r,rc(p)))%mod;
	return res;
}

void update(ll x,ll y,ll l,ll r,ll p,ll k,bool flag) { //true:加法,flase：乘法
	if(x<=l&&r<=y) {
		flag ? add_fun(p,l,r,k):mul_fun(p,l,r,k);
		return;
	}
	push_down(p,l,r);
	ll mid = (l+r) >> 1;
	if(x<=mid) update(x,y,l,mid,lc(p),k,flag);
	if(y>mid) update(x,y,mid+1,r,rc(p),k,flag);
	push_up(p);
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n >> m >> mod;
	for(int i=1; i<=n; i++) cin >> nums[i];
	build(1,1,n);

	while(m--) {
		ll op,x,y,k;
		cin >> op;
		if(op == 3) {
			cin >> x >> y;
			cout << find(x,y,1,n,1) << endl;
		} else {
			cin >> x >> y >> k;
			if(op == 2) {
				update(x,y,1,n,1,k,true);
			} else {
				update(x,y,1,n,1,k,false);
			}
		}

	}

	return 0;
}
```

# Tarjan相关

## 1、缩点

```
求一张有向图的最大权值，边点可重复利用，但不可重复计数
```



```
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
const int N = 1e5+1;

vector<int>grid[N],scGrid[N],RScGrid[N];//测试图，强连通图
int weight[N],degree[N],tp[N],tp_cnt,n,m;//权重，度，拓扑排序数组

//dfn:记录每个节点的搜索序号
//low:记录每个节点或其子树中能够追溯到的最早的栈中节点的次序号
//scc:记录每个节点所属的强连通分量的编号
//sc_dist:记录每个强连通分量中节点的权值总和
//times:记录当前的搜索序号
//scc_idx:记录当前的强连通分量的编号
int dfn[N],low[N],scc[N],scc_wt[N],times,scc_idx;
int st[N],top;//栈
bool visited[N] = {false};

int dp[N];//动态规划求最大权值

void tarjan(int u) {//标记强连通分量 

	low[u] = dfn[u] = ++times;
	st[++top] = u;
	visited[u] = true;

	for(int v:grid[u]) {
		if(dfn[v] == 0) {
			tarjan(v);
			low[u] = min(low[u],low[v]);
		} else if(visited[v]) {
			low[u] = min(low[u],dfn[v]);
		}
	}

	if(low[u]==dfn[u]) {
		++scc_idx;
		while(true) {
			scc[st[top]] = scc_idx;
			visited[st[top]] = false;
			scc_wt[scc_idx] += weight[st[top]];
			--top;
			if(u==st[top+1]) break;
		}
	}

}

void tpsort() {//拓扑排序 

	queue<int>q1;
	for(int i=1; i<=scc_idx; i++) {
		if(degree[i] == 0)
			q1.push(i);
	}

	while(!q1.empty()) {
		int u = q1.front();
		q1.pop();
		tp[++tp_cnt] = u;
		for(int v:scGrid[u]) {
			if(--degree[v]==0)
				q1.push(v);
		}
	}
}

int findMaxWeight() { //动态规划
	
	for(int i = 1; i <= scc_idx; i++) { 
		int u = tp[i];
		dp[u] = scc_wt[u];
		for(int v:RScGrid[u]) {
			dp[u] = max(dp[u], dp[v] + scc_wt[u]);
		}
	}
	
	int ans = 0;	
	for(int i = 1; i <= scc_idx; i++) ans = max(ans, dp[i]);
	return ans;
}

void buildScc() { //构造强连通图
	for(int i=1; i<=n; i++)
		if(!dfn[i]) tarjan(i);

	for(int u=1; u<=n; u++) { //强连通图
		for(int v:grid[u]) {
			if(scc[u]!=scc[v]) {
				int x = scc[u],y=scc[v];
				scGrid[x].push_back(y);//正连接表，用来拓扑排序 
				RScGrid[y].push_back(x);//逆邻接表，用来动态规划求最大权值 
				++degree[y];
			}
		}
	}
}

void read() {
	cin >> n >> m;
	for(int i=1; i<=n; i++) cin >> weight[i];
	for(int i=1; i<=m; i++) {
		int x,y;
		cin >> x >> y;
		grid[x].push_back(y);//有向图
	}
}

int main() {
	read();//读数据
	buildScc();//构建强连通图
	tpsort();//拓扑排序
	cout << findMaxWeight() <<endl;//动态规划求最大值
	return 0;
}

```



为什么用逆邻接表？

```
逆邻接表记录了每个强连通分量的前驱节点，使得我们可以在动态规划的过程中方便地找到所有能到达当前节点的强连通分量。这样，在更新当前节点的最大权值时，可以同时考虑所有能到达该节点的强连通分量的权值，从而得到正确的最大权值。
```

## 2、割点

什么是割点？

```
移除后图变成两个了
```

怎么判断割点

```
一：其为根，有至少两个子树，那就是割点

二：其不为根，但是他的在栈中的low值大于等于他父亲的访问顺序dfn
```



```
#include<iostream>
#include<vector>
using namespace std;
const int N = 1e6+1;
vector<int>grid[N];
int dfn[N],low[N],times;
//dfn:记录每个节点的搜索序号
//low:某点可通过回溯到达的最早的点的时间戳
bool isCut[N]={false};
 
void tarjan(int u,int fa){//求割点 
	dfn[u] = low[u] = ++times;
	int child = 0;
	for(int v:grid[u]){
		if(!dfn[v]){
			tarjan(v,u);
			low[u] = min(low[u],low[v]);
			//若u不为根但是low[v] ≥dfn[u]则其为割点。
			if(low[v]>=dfn[u] && u!=fa) isCut[u] = true;
			if(u==fa) ++child;
		}else {
			low[u] = min(low[u],dfn[v]);
		}
	}
	if(child>=2&&u==fa) isCut[u] = true;//若其为根，有至少两个子树，则其为割点 
}


int main(){
	int n,m;
	cin >> n >> m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin >> x >> y;
		grid[x].push_back(y);
		grid[y].push_back(x);
	}
	
	for(int i=1;i<=n;i++){
		if(!dfn[i])
			tarjan(i,i);
	}
	
	int ans=0;
	for(int i=1;i<=n;i++){
		if(isCut[i])
			++ans;
	}
	cout << ans << endl;
	for(int i=1;i<=n;i++){
		if(isCut[i])
			cout << i << " ";
	}
	
	return 0;
}
```

## 3、桥(未试过)

```
被删除后变成两个图的 边
```



```
#include <iostream>
#include <vector>
#include <map>
using namespace std;
using PILL = pair<int,int>;
const int N = 1e6 + 1;
vector<int> grid[N];
int dfn[N], low[N], times;
map<PILL,int>cnt;

void tarjan(int u, int fa) {
    dfn[u] = low[u] = ++times;

    for (int v : grid[u]) {
        if (!dfn[v]) { // v 未被访问，是树边
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            // 如果 v 的 low 值大于 u 的 dfn 值，说明 (u, v) 是桥
            if (low[v] > dfn[u]&&cnt[{u,v}] == 1) 
                cout << "Bridge: " << u << " " << v << endl;
        } else if (v != fa) { // v 已经被访问过，不是父节点，是后向边
            low[u] = min(low[u], dfn[v]);
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        ++cnt[{x,y}];
        ++cnt[{y,x}];
        grid[x].push_back(y);
        grid[y].push_back(x);
    }
	
    for (int i = 1; i <= n; i++) {
        if (!dfn[i])
            tarjan(i, i);
    }
	
	return 0;
}
/*
4 4
1 2
2 1
2 3
4 3
*/
```

# 双指针模板（求和/求乘积）

## [蓝桥杯 2023 国 B]  双子数

若一个正整数 $x$ 可以被表示为 $p^2 * q^2$，其中 $p$、$q$ 为质数且 $p ！=q $，则 $x$ 是
一个 “双子数”。请计算区间 $[2333, 23333333333333]$ 内有多少个 “双子数”？

## 代码实现

```
#include<iostream>
#include<vector>
using namespace std;
using ll = long long;
const int N = 1e7; 
vector<bool>isPrime(N,true);
vector<ll>Prime;

const ll st = 2333;
const ll ed = 23333333333333;

void init(){//快速筛素数 
	
	for(ll i = 2;i<=N;i++){
		if(isPrime[i]){
			Prime.push_back(i);
			for(ll j=i*i;j<=N;j+=i)
				isPrime[j] = false;
		}
	}
	
}

int main(){
	init();
	
	int l =0,r=Prime.size()-1;
	ll ans = 0;
	while(l<r){
		int k = l+1;
		while(Prime[l]*Prime[l]*Prime[k]*Prime[k] < st) k++;//起点 
		while(Prime[r]*Prime[r]*Prime[l]*Prime[l] > ed) r--;//终点 
		if(k<r) ans += (r-k+1);
		l++;
	}
	cout <<ans <<  endl;
	
	return 0;
}

```

# BFS遍历图

## [蓝桥杯 2023 国 B] AB 路线

## 题目描述

有一个由 $N \times M$ 个方格组成的迷宫，每个方格写有一个字母 `A` 或者 `B`。小蓝站在迷宫左上角的方格，目标是走到右下角的方格。他每一步可以移动到上下左右相邻的方格去。

由于特殊的原因，小蓝的路线必须先走 $K$ 个 `A` 格子、再走 $K$ 个 `B` 格子、再走 $K$ 个 `A` 格子、再走 $K$ 个 `B` 格子……如此反复交替。

请你计算小蓝最少需要走多少步，才能到达右下角方格？

注意路线经过的格子数不必一定是 $K$ 的倍数，即最后一段 `A` 或 `B` 的格子可以不满 $K$ 个。起点保证是 `A` 格子。

例如 $K = 3$ 时，以下 $3$ 种路线是合法的：

```plain
AA
AAAB
AAABBBAAABBB
```

以下 $3$ 种路线不合法：

```plain
ABABAB
ABBBAAABBB
AAABBBBBBAAA
```

### 评测用例规模与约定

 - 对于 $20\%$ 的数据，$1 \le N, M \le 4$。
 - 对于另 $20\%$ 的数据，$K = 1$。
 - 对于 $100\%$ 的数据，$1 \le N, M \le 1000$，$1 \le K \le 10$。

第十四届蓝桥杯大赛软件赛决赛 C/C++ 大学 B 组 G 题

## 代码实现

```
#include<iostream>
#include<queue>
using namespace std;
const int N = 1e3+3;
const int K = 31;
char grid[N][N];
char tmp[N];
bool visited[N][N][K];
int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};
int row,col,k;

void read(){
	cin >> row >> col >> k;
	for(int i=1;i<=row;i++){
		for(int j=1;j<=col;j++){
			cin >> grid[i][j];
		}
	}
	for(int i=0;i<k;i++)tmp[i]='A',tmp[i+k]='B';
}


int bfs(){
	queue<int>q1;
	q1.push(1);
	q1.push(1);
	q1.push(0);//a/b的个数 
	q1.push(0);//层数
	
	while(!q1.empty()){
		int x=q1.front();q1.pop();
		int y=q1.front();q1.pop();
		int cnt = q1.front();q1.pop();
		int d = q1.front();q1.pop();
		if(x==row&&y==col) return d;
		
		for(int i=0;i<4;i++){
			int nx = x + dir[i][0],ny= y + dir[i][1],ncnt=(cnt+1)%(2*k);
			if(nx <1||ny<1||nx>row||ny>col) continue;
			if(visited[nx][ny][ncnt]) continue;
			if(grid[nx][ny]!=tmp[ncnt]) continue;
			visited[nx][ny][ncnt] = true;
			q1.push(nx);
			q1.push(ny);
			q1.push(ncnt);
			q1.push(d+1);
		}
	}
	return -1;
}

int main(){
	read();
	cout << bfs() << endl;
	return 0;
}
```

# DFS遍历

## 排列

```
#include<iostream>
#include<vector>
using namespace std;

void dfs(vector<int>& nums,vector<int>& path,vector<bool>& used){
	if(path.size() == nums.size()){
		for(int i:path){
			cout << i << " ";
		}
		cout << endl;
		return;
	}
	
	for(int i=0;i<nums.size();i++){
		if(!used[i]){
			path.push_back(nums[i]);
			used[i] = true;
			dfs(nums,path,used);
			used[i] = false;
			path.pop_back();
		}
	}
	return;
}


int main(){
	int n;
	cin >> n;
	vector<int>nums(n);
	vector<int>path;
	vector<bool>used(n,false);
	for(int i=0;i<n;i++) nums[i] = i+1;
	dfs(nums,path,used);
	return 0;
}
```

## 组合

```
#include<iostream>
#include<vector>
using namespace std;

void dfs(vector<int>& nums,vector<int>& path,int k,int startIdx){
	if(path.size() == k){
		for(int i:path){
			cout << i << " ";
		}
		cout << endl;
		return;
	}
	
	for(int i=startIdx;i<nums.size();i++){
		path.push_back(nums[i]);
		dfs(nums,path,k,i+1);
		path.pop_back();
	}
	return;
}


int main(){
	int n;
	cin >> n;
	vector<int>nums(n);
	vector<int>path;
	for(int i=0;i<n;i++) nums[i] = i+1;
	dfs(nums,path,3,0);
	return 0;
}
```

# 动态规划

## 背包

| 背包问题类型 | 物品选择次数 | 物品遍历顺序 | 背包容量遍历方向 | 次数遍历方向 | 外层循环遍历 | 内层循环遍历 | 循环顺序是否可交换 |
| ------------ | ------------ | ------------ | ---------------- | ------------ | ------------ | ------------ | ------------------ |
| 0-1 背包     | 0 或 1       | 正序         | 逆序             | -            | 物品         | 背包容量     | 是                 |
| 完全背包     | 0 到 无限次  | 正序         | 正序             | -            | 物品         | 背包容量     | 是                 |
| 多重背包     | 0 到 k 次    | 正序         | 正序             | 逆序         | 物品         | 背包         | 否                 |

最大价值

```
dp[i][w]=max(dp[i−1][w],dp[i−1][w−wi]+vi)
```

可能性

```
dp[i][j]+=dp[i−1][j]+dp[i−1][j−num[i]]
```

### 01背包

#### [蓝桥杯 2022 国 B] 搬砖

##### 题目描述

这天，小明在搬砖。

他一共有 $n$ 块砖，他发现第 $i$ 砖的重量为 $w_{i}$，价值为 $v_{i}$。他突然想从这些砖中选一些出来从下到上堆成一座塔，并且对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值。

他想知道这样堆成的塔的总价值（即塔中所有砖块的价值和）最大是多少。

##### 输入格式

输入共 $n+1$ 行, 第一行为一个正整数 $n$, 表示砖块的数量。

后面 $n$ 行, 每行两个正整数 $w_{i}, v_{i}$ 分别表示每块砖的重量和价值。

##### 输出格式

一行，一个整数表示答案。

##### 样例 #1

##### 样例输入 #1

```
5
4 4
1 1
5 2
5 5
4 3
```

##### 样例输出 #1

```
10
```

##### 提示

**【样例说明】**

选择第 $1$、$2$、$4$ 块砖，从上到下按照 $2$、$1$、$4$ 的顺序堆成一座塔，总价值为 $4+1+5=10$。

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，保证 $n \leq 10$;

对于 $100 \%$ 的数据，保证 $n \leq 1000 ; w_{i} \leq 20 ; v_{i} \leq 20000$ 。

蓝桥杯 2022 国赛 B 组 J 题。



```
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1e6;
int dp[N];//容量未i的背包最大价值为dp[i] 

struct node{
	int w,v,size;
}item[N];

bool mycmp(node x,node y){//按物品的重量＋价值排序
	return x.size <= y.size;
}

int main(){
	int n;
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> item[i].w >> item[i].v;
		item[i].size = item[i].w+ item[i].v;
	}
	sort(item+1,item+1+n,mycmp);
	
	for(int i=1;i<=n;i++){//正序遍历物品 
		for(int j=item[i].size;j>=item[i].w;j--){//逆序背包 
			dp[j] = max(dp[j],dp[j-item[i].w]+item[i].v);
		}
	}
	int ans = 0;
	for(int i:dp) ans = max(ans,i);
	cout << ans << endl;
	return 0;
}
```

#### [蓝桥杯 2022 国 B]2022

```
问取不同的十个正整数，有多少中和为2022的可能性
```



```
#include<iostream>
using namespace std;
using ll = long long;
const int N = 2023;// >目标 
const int CNT = 11; // >拿取的个数
ll dp[N][CNT]; 

int main(){
	int n=2022,nums=10;
	dp[0][0] = 1;
	for(int i=1;i<=n;i++){//  正序物品 
		for(int k=nums;k>=1;k--){//逆序拿取数量，最少得拿一个 
			for(int j=i;j<=n;j++){//正序背包 
				dp[j][k] += dp[j-i][k-1];
			}
		}
	}
	
	cout << dp[n][nums] << endl;
	return 0;
}
```

#### 多数01背包

现在不止有一个背包了，有两个，要求两个背包的最大价值

```
#include<iostream>
#include<algorithm>
using namespace std;
int item[210];
int f[1010][1010];
int main(){
	int n,wa,wb;
	cin >> n >> wa >> wb;
	for(int i=1;i<=n;i++) cin >> item[i];
	
	
	for(int i=1;i<=n;i++){
		for(int j=wa;j>=0;j--){//因为有第二维度的可能性，所以他可以为0，第二个背包全装完就是了
			for(int k=wb;k>=0;k--){
				if(j>=item[i]){
					f[j][k] = max(f[j][k],f[j-item[i]][k]+item[i]);
				}
				if(k>=item[i]){
					f[j][k] = max(f[j][k],f[j][k-item[i]]+item[i]);
				}
			}
		}
	}
	
	cout << f[wa][wb] << endl;
}
```



### 完全背包

#### 给定一个n，求有多少种素数之和等于他

```
#include<iostream>
#include<vector>
using namespace std;
using ll = long long;
const int N = 1e4;

ll dp[N];
vector<int>Prime;
vector<bool>isPrime(N,true);


void init(){
	for(int i=2;i<=N;i++){
		if(isPrime[i]){
			Prime.push_back(i);
			for(int j=i*i;j<=N;j+=i)
				isPrime[j] = false;
		}
	}
}


int main(){
	init();
	int n;
	cin >> n;
	dp[0] = 1;
	for(int i=0;i<Prime.size();i++){//正序遍历物品 
		for(int j=Prime[i];j<=n;j++){//正序遍历背包 
			dp[j] += dp[j-Prime[i]];
		}
	}
	cout << dp[n] << endl;
	return 0;
}
```

#### 硬币问题

##### 题目描述

今有面值为 1、5、11 元的硬币各无限枚。

想要凑出 $n$ 元，问需要的最少硬币数量。

##### 输入格式

仅一行，一个正整数 $n$。

##### 输出格式

仅一行，一个正整数，表示需要的硬币个数。

##### 样例 #1

##### 样例输入 #1

```
15
```

##### 样例输出 #1

```
3
```

##### 样例 #2

##### 样例输入 #2

```
12
```

##### 样例输出 #2

```
2
```



```
#include<iostream>
#include<algorithm>
using namespace std;
using ll = long long;
const int N = 1e6+10;
ll dp[N];

int main(){
	ll n ;
	cin >> n;
	int nums[3] = {1,5,11};
	fill(dp,dp+N,n+1);//数组的开头(dp)到结尾(dp+N)填充 value(n+1)
	dp[0] = 0;
	for(int i=0;i<3;i++){
		for(int j=nums[i];j<=n;j++){
			dp[j] = min(dp[j],dp[j-nums[i]]+1);
		}
	}
	
	cout << dp[n] << endl;
	return 0;
}
```

## 子序列

### 最长递增子序列

```
#include<iostream>
#include<algorithm>
using namespace std;
using ll = long long;
const int N = 1e4+10;
ll dp[N];//1~i中有dp[i]长度的递增子序列 
ll nums[N];
int main(){
	ll n ;
	cin >> n;
	for(int i=0;i<n;i++) cin >> nums[i];
	fill(dp,dp+N,1); 
	for(int i=1;i<=n;i++){
		for(int j=0;j<i;j++){
			if(nums[j] < nums[i]){
				dp[i] = max(dp[i],dp[j]+1);
			}
		}
	}
	ll ans =0;
	for(int i=0;i<n;i++) ans = max(ans,dp[i]);
	cout << ans << endl;
	return 0;
}
```

### 子序列数量

```
#include<iostream>
using namespace std;
using ll = long long;

const int N = 1e4+5;
ll dp[N][5];//s1的0~i中共有子序列0~j,dp[i][j]个 

ll count (const string& s1,const string& s2){
	int len1 = s1.size(),len2=s2.size();
	dp[0][0];
	for(int i=1;i<=len1;i++){
		dp[i][0] = 1;
		for(int j=1;j<=len2;j++){
			if(s1[i-1] == s2[j-1]){
				dp[i][j] = dp[i-1][j-1]+dp[i-1][j];
			}else{
				dp[i][j] = dp[i-1][j];
			}
		}
	}
	
	return dp[len1][len2];
}

int main(){
	string s1="",s2="2023";
	for(int i=1;i<=2023;i++) s1 += to_string(i);

	cout << count(s1,s2) << endl;
	
	return 0;
}
```

### 最长公共子序列

```
#include<iostream>
using namespace std;

const int N = 1e3+5;

int dp [N][N];//s1(1~i)和s2(1~j)有长度为dp[i][j]的子序列,其中对于空字符串来说，没有和他匹配的
int main(){
	string s1,s2;
	int n,m;
	cin >> n >> m >> s1 >> s2;
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s1[i-1] == s2[j-1]){
				dp[i][j] = dp[i-1][j-1]+1;
			}else{
				dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
			}
		}
	}
	
	cout << dp[n][m] << endl;
	return 0;
}
```

### 编辑距离

```
#include<iostream>
#include<vector>
using namespace std;

const int N = 11;

int dp [N][N];//s1(1~i)变成s2(1~j)需要操作dp[i][j]次 


bool canChange(const string& s1,const string& s2,int times){
	int len1 = s1.size(),len2=s2.size();
	
	for(int i=0;i<=len1;i++) dp[i][0] = i;//初始化 
	for(int j=0;j<=len2;j++) dp[0][j] = j;
	
	for(int i=1;i<=len1;i++){
		for(int j=1;j<=len2;j++){
			if(s1[i-1] == s2[j-1]){
				dp[i][j] = dp[i-1][j-1];
			}else{
				dp[i][j] = min(dp[i-1][j]+1,min(dp[i-1][j-1]+1,dp[i][j-1]+1));//增删改中寻找操作次数最小的
			}
		}
	}
	if(dp[len1][len2] <= times) return true;
	else return false;
	
}

int main(){

	int n,m;
	cin >> n >> m;
	vector<string>tmp;
	for(int i=1;i<=n;i++){
		string s1;
		cin >> s1;
		tmp.push_back(s1);
	}
	
	for(int i=1;i<=m;i++){
		int cnt = 0;
		string s2;
		int k;
		cin >> s2 >> k;
		for(string s:tmp){
			if(canChange(s,s2,k)) ++cnt;
		}
		cout << cnt << endl;
	}
	return 0;
}
```

## 树形dp

#### 没有上司的舞会

```
Ural大学有N名职员，编号为1~N.
他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上
司。
每个职员有一个快乐指数，用整数H:给出，其中1≤i≤N.
现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参
会。
在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所
有参会职员的快乐指数总和最大，求这个最大值。
```



```
#include<iostream>
#include<vector>
using namespace std;

const int N = 6e3+3;

vector<int>tree[N];
int H[N];
int dp[N][2];//左子树快乐值最大为dp[i][0],右子树为dp[i][1]

void dfs(int u,int fa){
	dp[u][1] = H[u];
	
	for(int v:tree[u]){
		if(v==fa) continue;
		dfs(v,u);
		dp[u][1] += dp[v][0];
		dp[u][0] += max(dp[v][0],dp[v][1]);
	}
}

int main(){
	int n;
	cin >>n;
	for(int i=1;i<=n;i++) cin >> H[i];
	
	for(int i=1;i<=n-1;i++){
		int x,y;
		cin >> x >> y;
		tree[x].push_back(y);
		tree[y].push_back(x);
	}
	
	dfs(1,0);
	
	cout << max(dp[1][0],dp[1][1]) << endl;
	
	return 0;
}
```

# 期望值

```
在概率论和统计学中，是指随机变量在理论上可能出现的所有结果的加权平均值。期望值反映了随机变量在大量试验中的平均结果，是随机变量的一个重要特征
```

例：

```
已有两个数组P，Q，元素数量都为len，P-Q的期望值为

(sum(P)-sum(Q))/len

```

