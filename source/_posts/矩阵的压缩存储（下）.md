---
title: 矩阵的压缩存储（下）
categories: C-数据结构
date: 2023-11-1 17:11:45
tags: 数据结构-程序


---

# 矩阵的压缩存储（下）（十字链表法）

## 一、优缺点

**三元组存储法**：

- 优点：
  1. 简单直观：三元组存储法是一种直观的数据结构，易于理解和实现。
  2. 紧凑性：三元组存储法仅存储非零元素的值以及它们的行、列信息，因此通常占用较少的内存。
  3. 适用于密度较低的稀疏矩阵。
- 缺点：
  1. 不适用于高效的矩阵运算：对于稀疏矩阵的一些矩阵运算（例如矩阵乘法），三元组存储法可能不够高效，需要额外的转换步骤。
  2. 插入和删除元素较慢：由于元素的插入和删除可能需要移动其他元素，这可能会导致性能下降。

<!--more-->

**十字链表法**：

- 优点：
  1. 高效的矩阵运算：十字链表法在高效执行稀疏矩阵运算方面具有优势，如矩阵乘法、矩阵加法等。
  2. 插入和删除元素较快：由于十字链表法使用链表结构，插入和删除元素的操作通常较快，不需要大量数据移动。
  3. 更多元数据：它允许存储更多元数据，如每一行的非零元素数量、每一列的非零元素数量等。
- 缺点：
  1. 相对复杂：十字链表法的实现相对复杂，需要额外的链表结构来存储行和列的关系。
  2. 占用更多内存：由于存储了额外的元数据和链表结构，十字链表法通常占用更多内存空间。

## 二、程序部分

### 1、头文件

```
#include<stdio.h>
#include<stdlib.h>
#include <time.h>
```

### 2、十字链表的结构体和初始化

```
typedef struct LNode{//用来压缩的链表结构体 
	int index;//横坐标  
	int data;//值 
	struct  LNode* next;
}LNode,*LinkList;

LinkList LinkList_init(){//链表的初始化 
	LinkList L1 = (LNode*)malloc(sizeof(LNode));
	L1->next=NULL;
	return L1;
}
```

### 3、数组的结构体和初始化

```
typedef struct ANode{//用来存放矩阵的一维/二维数组结构体 
	union{
		int *data_1;//一维数组
		int **data_2;//二维数组
	};
	int row;	//行 
	int col;	//列 
}ANode,*AList; 

AList AList_ONE_init(int row){//一维数组的初始化 
	AList A1 = (ANode*)malloc(sizeof(ANode));
	A1->data_1 = (int*)malloc(sizeof(int)*row);
	A1->row =row;
	A1->col = 1;
	

	for(int i=0;i<row;i++)//初始化赋值0 
		A1->data_1[i] =0;
	return A1;

}

AList AList_TWO_init(int row,int col){//二维数组的初始化 
	AList A1 = (ANode*)malloc(sizeof(ANode));
	A1->data_2 = (int**)malloc(row*sizeof(int*));
	for(int i=0;i< row;i++){
		A1->data_2[i] = (int*)malloc(sizeof(int)*col);
		for(int j=0;j<col;j++){
			A1->data_2[i][j] = 0;
		}
	}
	A1->col =col;
	A1->row =row;
	return A1;
}
```

### 4、数组的输出

```
void AList_Puts(AList A1){//数组的输出 
	if(A1->col == 1){
		for(int i=0;i<A1->row;i++)
			printf("%4d",A1->data_1[i]);
	}
	else{
		for(int i=0;i<A1->row;i++){
			for(int j=0;j<A1->col;j++){
				printf("a%2d,%2d: %-4d",i+1,j+1,A1->data_2[i][j]);
			}
			printf("\n");
		}
	}
	printf("\n\n");
}
```

### 5、生成稀疏矩阵

```
void sparse_matrix_create(AList A1){//随机生成稀疏矩阵
	int count = A1->row * A1->col * 0.05 + 1; 
	

	while(count){
		srand((unsigned)time(NULL));
		int i = rand()%(A1->row +1);
		int j = rand()%(A1->col +1);;
		int num = rand()% 10 +2;
		if(A1->data_2[i][j]!=0) continue;
		A1->data_2[i][j]=num;
		count--;
	}
	printf("稀疏矩阵为：\n");
	AList_Puts(A1);

}
```

### 6、链表的输出与释放

```
LinkList LinkList_printf(LinkList L1){//链表的输出 
	LNode* p =L1->next;
	while(p){
		printf("%d,%d->",p->index+1,p->data);
		p=p->next;
	}
	printf("end\n"); 
}

LinkList LinkList_clear(LinkList L1){//释放链表 
	LinkList p1 = L1;
    while (p1 != NULL) {
        LinkList temp = p1;
        p1 = p1->next;
        free(temp);
    }
    printf("链表已释放\n");
}
```

### 7、链表的查找和插入

```
LNode* LNode_search(LinkList L1,int index){//查找 
	LNode *p;
    p = L1;
    while(p&&index){
        index--;
        p=p->next;
    }
    if(p == NULL) printf("没有该节点\n");
    else return p;
}

void LNode_instert(LinkList L1,int index,int value,int index_LNode){//插入 
	LNode* p = LNode_search(L1,index_LNode);
	LNode* newnode = (LNode*)malloc(sizeof(LNode));
	newnode->data =value;
	newnode->index = index;
	newnode->next = p->next;
	p->next = newnode;
	
}
```

### 8、压缩和转置压缩

```
void sparse_matrix_compression(AList A1,LinkList Li,LinkList Lj){//压缩 
	int index_x=0,index_y=0;//用来记链表元素数 
	for(int i=0;i<A1->row;i++)
		for(int j=0;j<A1->col;j++)
			if(A1->data_2[i][j]!=0){
				LNode_instert(Li,i,A1->data_2[i][j],index_x++);
				LNode_instert(Lj,j,A1->data_2[i][j],index_y++);
		}
}

void sparse_matrix_transposition_compression(AList At,LinkList Li,LinkList Lj){//转置压缩 
	int index_x=0,index_y=0;//用来记链表元素数 
		for(int j=0;j<At->col;j++) 
			for(int i=At->row-1;i>0;i--)
				if(At->data_2[i][j]!=0){
					LNode_instert(Li,j,At->data_2[i][j],index_x++);
					LNode_instert(Lj,i,At->data_2[i][j],index_y++);
				}
			
}
```

### 9、解压

```
void sparse_matrix_decompression(LinkList Li,LinkList Lj,AList A2) {//解压 
    LNode* p1 = Li->next;
    LNode* p2 = Lj->next;
	

	while (p1&&p2) {
	    A2->data_2[p1->index][p2->index] = p1->data;
		p1 = p1->next;
		p2=p2->next;
	}

}
```

### 10、主函数

```
int main(){//主函数 
	printf("请输入稀疏矩阵的行列\n");
	int row,col;//行，列 
	scanf("%d %d",&row,&col); 
	AList A1 = AList_TWO_init(row,col);//原始矩阵 
	sparse_matrix_create(A1);
	

	//压缩 
	LinkList Li = LinkList_init();
	LinkList Lj = LinkList_init();
	sparse_matrix_compression(A1,Li,Lj);//压缩 
	printf("压缩后链表Li,v= ");
    LinkList_printf(Li);
	printf("\n压缩后链表Lj,v= ");
	LinkList_printf(Lj);
	
	//解压放置数组 
	AList A2 = AList_TWO_init(row,col);
	printf("\n矩阵解压:\n");
	sparse_matrix_decompression(Li,Lj,A2);//解压 
	AList_Puts(A2);
	
	//转置
	LinkList Lt_i = LinkList_init();
	LinkList Lt_j = LinkList_init();
	sparse_matrix_transposition_compression(A1,Lt_i,Lt_j);
	printf("压缩后链表Li,v= ");
	LinkList_printf(Lt_i);
	printf("\n压缩后链表Lj,v= ");
	LinkList_printf(Lt_j);
	
	//解压转置
	AList A3 = AList_TWO_init(col,row);//转置后行列转换 
	printf("\n矩阵转置后解压:\n");
	sparse_matrix_decompression(Lt_i,Lt_j,A3);//解压 
	AList_Puts(A3);
	 
	free(A1);
	free(A2);
	LinkList_clear(Li);
	LinkList_clear(Lj);
	LinkList_clear(Lt_i);
	LinkList_clear(Lt_j);

}
```

