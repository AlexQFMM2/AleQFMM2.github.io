---
title: 矩阵的压缩存储（下）
categories: C-数据结构
date: 2023-10-14 17:11:45
tags: 数据结构-程序


---

# 矩阵的压缩存储（下）（十字链表法）

## 一、优缺点

**三元组存储法**：

- 优点：
  1. 简单直观：三元组存储法是一种直观的数据结构，易于理解和实现。
  2. 紧凑性：三元组存储法仅存储非零元素的值以及它们的行、列信息，因此通常占用较少的内存。
  3. 适用于密度较低的稀疏矩阵。
- 缺点：
  1. 不适用于高效的矩阵运算：对于稀疏矩阵的一些矩阵运算（例如矩阵乘法），三元组存储法可能不够高效，需要额外的转换步骤。
  2. 插入和删除元素较慢：由于元素的插入和删除可能需要移动其他元素，这可能会导致性能下降。

<!--more-->

**十字链表法**：

- 优点：
  1. 高效的矩阵运算：十字链表法在高效执行稀疏矩阵运算方面具有优势，如矩阵乘法、矩阵加法等。
  2. 插入和删除元素较快：由于十字链表法使用链表结构，插入和删除元素的操作通常较快，不需要大量数据移动。
  3. 更多元数据：它允许存储更多元数据，如每一行的非零元素数量、每一列的非零元素数量等。
- 缺点：
  1. 相对复杂：十字链表法的实现相对复杂，需要额外的链表结构来存储行和列的关系。
  2. 占用更多内存：由于存储了额外的元数据和链表结构，十字链表法通常占用更多内存空间。

## 二、程序部分

### 1、头文件和初始定义

```
#include<stdio.h>
#include<stdlib.h>
#define N 5 //N是数组的大小，矩阵从1开始，所以其中0不可用，矩阵 大小为-1 
int a[N][N]={0 ,0 ,0 ,0 ,0 ,//初始化一个对称矩阵,数组下标从0开始,矩阵下标从1开始
			 0 ,1 ,0 ,2 ,0 ,
			 0 ,0 ,0 ,6 ,0 ,
			 0 ,0 ,5 ,0 ,0 ,
			 0 ,7 ,0 ,0 ,0};
```

### 2、结构体定义和基本输出，清空

###### 结构体

```
typedef struct LNode{
	int index;//横坐标  
	int data;//值 
	struct  LNode* next;
}LNode,*LinkList;
```

###### 初始化

```
LinkList LinkList_init(){
	LinkList L1 = (LNode*)malloc(sizeof(LNode));
	L1->next=NULL;
	return L1;
}
```

###### 矩阵的输出 

```
void matrix_printf(int a[][N],char c){
	printf("\n------------------------------------------------------\n");
	for(int i=1;i<N;i++){
		for(int j=1;j<N;j++)
			printf("| %c%d%d = %-4d ",c,i,j,a[i][j]);
		printf("|\n");
		printf("------------------------------------------------------\n");
	}
}
```

###### 链表的输出

```
LinkList LinkList_printf(LinkList L1){
	LNode* p =L1->next;
	while(p){
		printf("%d,%d->",p->index,p->data);
		p=p->next;
	}
	printf("end\n"); 
}
```

###### 链表的清除

```
LinkList LinkList_clear(LinkList L1){
	LinkList p1 = L1;
    while (p1 != NULL) {
        LinkList temp = p1;
        p1 = p1->next;
        free(temp);
    }
    printf("链表已释放\n");
}
```

### 3、解压、压缩部分

###### 链表的按位查找

```
LNode* LNode_search(LinkList L1,int index){//查找 
	LNode *p;
    p = L1;
    while(p&&index){
        index--;
        p=p->next;
    }
    if(p == NULL) printf("没有该节点\n");
    else return p;
}
```

###### 链表的按位插入

```
void LNode_instert(LinkList L1,int index,int value,int index_LNode){//插入 
	LNode* p = LNode_search(L1,index_LNode);
	LNode* newnode = (LNode*)malloc(sizeof(LNode));
	newnode->data =value;
	newnode->index = index;
	newnode->next = p->next;
	p->next = newnode;
}
```

###### 压缩

```
void sparse_matrix_compression(LinkList Li,LinkList Lj){//压缩 
	int index_x=0,index_y=0;
	for(int i=0;i<N;i++)
		for(int j=0;j<N;j++)
			if(a[i][j]!=0){
				LNode_instert(Li,i,a[i][j],index_x++);
				LNode_instert(Lj,j,a[i][j],index_y++);
		}
}
```

###### 解压

```
void sparse_matrix_decompression(LinkList Li, LinkList Lj) {//解压 
    LNode* p1 = Li->next;
    LNode* p2 = Lj->next;
	int b[N][N]={0};
    

while (p1) {
    while (p2) {
        if (p1->data == p2->data) {
            b[p1->index][p2->index] = p1->data;
        }
        p2 = p2->next;
    }
    p1 = p1->next;
    p2 = Lj->next; // 重置 p2，以便重新遍历 Lj
}
matrix_printf(b, 'b');

}
```

### 4、主函数

```
int main(){
	printf("原矩阵存储为：\na[i][j] = ");
	matrix_printf(a,'a');
	LinkList Li = LinkList_init();
	LinkList Lj = LinkList_init();
	sparse_matrix_compression(Li,Lj);
	printf("压缩后链表Li,v= ");
	LinkList_printf(Li);
	printf("\n压缩后链表Lj,v= ");
	LinkList_printf(Lj);
	sparse_matrix_decompression(Li,Lj);
	LinkList_clear(Li);
	LinkList_clear(Lj);
} 
```

