---
title: 字符串
categories: 力扣
date: 2024-03-15 16:28:45
tags: 力扣



---

# 字符串例题

<!--more-->

## 1.力扣 344 反转字符串

```
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。


示例 1：

输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

题解：

双指针，一头一尾交换就是了

```
class Solution {
public:
    void reverseString(vector<char>& s) {
        int head = 0;
        int tail = s.size()-1;
        while(head < tail){
            char temp = s[head];
            s[head] = s[tail];
            s[tail] = temp;
            head++;
            tail--;
        }
    }
};
```

## 2.反转字符串Ⅱ

```
给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
 

示例 1：

输入：s = "abcdefg", k = 2
输出："bacdfeg"
示例 2：

输入：s = "abcd", k = 2
输出："bacd"
 
```

题解：

这题需要思维反转一下，不是到2k开始对0-k的元素反转，而是对2k到k的元素进行反转

所以

2*k是下次需要反转时的起始坐标
每次反转的内容就是起始坐标到 i+k的距离
如果i+k大于n，就取n

```
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        //2*k是下次需要反转时的起始坐标
        //每次反转的内容就是起始坐标到 i+k的距离
        //如果i+k大于n，就取n
        for(int i = 0; i < s.size(); i+= (2 * k))
        {
            if(i + k < s.size())
                reverse(s.begin() + i, s.begin() + i + k);
            else
                reverse(s.begin() + i, s.end());
        }
        return s;
    }
};

```

## 3.卡玛 53 替换数字

```
目描述
给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。
输入描述
输入一个字符串 s,s 仅包含小写字母和数字字符。
输出描述
打印一个新的字符串，其中每个数字字符都被替换为了number
输入示例
a1b2c3
输出示例
anumberbnumbercnumber
提示信息
数据范围：
1 <= s.length < 10000。
```

题解：

定义一个字符串，遍历存放，遇到数字换就是了

```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin >> s;
    string ans;
    for(char ch:s){
        if(ch >= '0' && ch <='9'){
            ans+="number";
        }
        else ans+=ch;
    }
    cout << ans;
    return 0;
}
```

## 4.力扣 151 翻转字符串里的单词

```
给你一个字符串 s ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

 

示例 1：

输入：s = "the sky is blue"
输出："blue is sky the"
示例 2：

输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
示例 3：

输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

题解：

其实反转也可以看成先进后出，所以可以用栈的思维来转换

先遍历字符串将单词入栈

随后再挨个弹出就行了，注意加空格

```
class Solution {
public:
    string reverseWords(string s) {//先进后出，用栈
        stack<string> st;
        string ans;

        for(int i=0;i<s.size();i++){//分割单词存入栈中
            if(s[i]!=' '){
                string temp;
                while(s[i]!='\0' && s[i]!=' '){
                    temp +=s[i++];
                }
                st.push(temp);
            }
        } 

        while(!st.empty()){//栈不为空就输出栈
            ans += st.top();
            st.pop();
            if(!st.empty()) ans+=' ';
        }
        return ans;
    }
};
```

## 5.卡玛 55 右旋转字符串

```
字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

输入描述
输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。
输出描述
输出共一行，为进行了右旋转操作后的字符串。
输入示例
2
abcdefg
输出示例
fgabcde
提示信息
数据范围：
1 <= k < 10000,
1 <= s.length < 10000;
```

题解：利用栈很简单

```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
 
int main(){
    int n;
    string s;
    string ans;
    cin >> n >> s;
    stack<char> st;
    int len = s.size();
    int i;
    for(i = len-1;i>len-n-1;i--){
        st.push(s[i]);
    }
    while(!st.empty()){
        ans+=st.top();
        st.pop();
    }
    for(i=0;i<len-n;i++){
        ans+=s[i];
    }
    cout << ans;
    return 0;
}
```

## 6.力扣 28  找出字符串中第一个匹配项的下标

```
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。

 

示例 1：

输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
示例 2：

输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
 
```

题解：

KMP算法，熟读且背诵就完事了

```
class Solution {
public:
    void getNext(const string& needle,vector<int>& next){
        int i=0,j=-1;
        int len = needle.size()-1;
        while(i<len){
            if(j==-1||needle[i] == needle[j]){
                i++;
                j++;
                next[i] =j;
            }
            else j= next[j];
        }
    }

    int strStr(string haystack, string needle) {
        int m = haystack.size();
        int n = needle.size();
        if(n == 0) return -1;
        if(m < n) return -1;
        vector<int> next(n,-1);
        getNext(needle,next);
        
        int i=0,j=0;
        while(haystack[i]!='\0'){
            if(j==-1 || haystack[i] == needle[j]){
                i++;
                j++;
                if(j == n) return i-j;
            }
            else j = next[j];
        }   
        return -1;
    }
};
```

next的另一种方法（这种方法生成的 `next` 数组被称为“优化过的”）

```
int KMP(const string&s1,const string& s2,vector<int>& next){
	int i=0,j=0;
	while(i<s1.size()){
		if(j==-1||s1[i]==s2[j]){
			i++;
			j++;
			if(j == s2.size()) return i-j;
		}
		else j = next[j];
	}
	return -1;
}

void getNext(vector<int>& next, const string& s, int n) {
    for (int i = 1; i < n; ++i) {
        int j = next[i - 1];
        while (j != -1 && s[j + 1] != s[i]) {
            j = next[j];
        }
        if (s[j + 1] == s[i]) {
            next[i] = j + 1;
        } else {
            next[i] = -1;
        }
    }
}
```

区别

```
abcabcabcd
next1:-1  0  0 0 1 2 3 4 5  6

next2:-1 -1 -1 0 1 2 3 4 5 -1
```



## 7.重复的子字符串

```
给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

 

示例 1:

输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
示例 2:

输入: s = "aba"
输出: false
示例 3:

输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

题解：巧用next数组求最大重复的前缀长度

再用n除以前缀长度，看看能否整除；

一定要用优化next的算法，这样末尾如果不同才会是-1

```
class Solution {
public:

    void getNext(vector<int>& next,const string& s,int n){
         for (int i = 1; i < n; ++i) {
            int j = next[i - 1];
            while (j != -1 && s[j + 1] != s[i]) {
                j = next[j];
            }
            if (s[j + 1] == s[i]) {
                next[i] = j + 1;
            }
        }
    }

    bool repeatedSubstringPattern(string s) {
        int n = s.size();
        vector<int> next(n, -1);
        getNext(next,s,n);
        return next[n - 1] != -1 && n % (n - next[n - 1] - 1) == 0;
    }
};

```

