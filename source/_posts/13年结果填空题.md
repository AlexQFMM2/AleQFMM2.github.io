---
title: 13年结果填空题
categories: 蓝桥杯
date: 2024-1-25	08:21:45
tags: 蓝桥杯


---

# 13年结果填空题



## 1.  空瓶换汽水

```
浪费可耻，节约光荣。饮料店节日搞活动：不用付费，用3个某饮料的空瓶就可以换一瓶该饮料。刚好小明前两天买了2瓶该饮料喝完了，瓶子还在。他耍了个小聪明，向老板借了一个空瓶，凑成3个，换了一瓶该饮料，喝完还瓶！！

饮料店老板一统计，已经售出该饮料且未还瓶的有12345瓶，那么如果这些饮料的买主都如小明一样聪明，老板最多还需要送出多少瓶饮料呢？

显然答案是个正整数。

参考答案：
```



```
12345 / 2 = 6172
```

 <!--more-->

## 2.  三人年龄

```
三个神秘蒙面人来访F博士。

博士询问他们年龄时，他们说：我们中年龄最小的不超过19岁。我们3人年龄总和为70岁。且我们三人年龄的乘积是所有可能情况中最大的。

请帮助F博士计算他们的年龄，从小到大排列，用逗号分开。

 

参考答案：

19,25,26
```

```
int main() {
  int i,j,k,a[4]={0};
  for (i = 1; i <= 19; i++)
	for (j = 1; j < 70; j++)
		for (k = 1; k < 70; k++)
			 if (i + j + k == 70 ){
				 if(i*j*k>a[3]&&i<=j&&i<=k) {
					a[0]=i;a[1]=j;a[2]=k;a[3]=i*j*k;
				 }
			}
		 printf("%d,%d,%d,%d\n",a[0],a[1],a[2],a[3]);
		 return 0;
}
```

## 3.  考察团组成

```
某饭店招待国外考察团。按照标准，对领导是400元/人，随团职员200元/人，对司机50元/人。

考察团共36人，招待费结算为3600元，请问领导、职员、司机各几人。

答案是三个整数，用逗号分隔。

 

参考答案：

3,5,28
```

```
int main() {
    int i,j,k;
       for(i=1;i<36;i++)
           for(j=1;j<36;j++)
              for(k=1;k<36;k++)
                 if( i+j+k ==36 && 400*i+200*j+50*k == 3600) 
                     printf("%d,%d,%d",i,j,k);
  return 0;
}
```

## 4.  微生物增殖

```
假设有两种微生物 X 和 Y

X出生后每隔3分钟分裂一次（数目加倍），Y出生后每隔2分钟分裂一次（数目加倍）。

**一个新出生的X****，半分钟之后吃掉1****个Y****，**并且，从此开始，每隔1分钟吃1个Y。

现在已知有新出生的 X=10, Y=89，求60分钟后Y的数目。

如果X=10，Y=90 呢？

本题的要求就是写出这两种初始条件下，60分钟后Y的数目。

题目的结果令你震惊吗？这不是简单的数字游戏！真实的生物圈有着同样脆弱的性质！也许因为你消灭的那只 Y 就是最终导致 Y 种群灭绝的最后一根稻草！

 

请忍住悲伤，把答案写在“解答.txt”中，不要写在这里！

两个整数，每个1行。

参考答案：

0    

94371840 
```

```
#include<stdio.h>

int main()

{
    int x=10,y=90;
    int new_x=0; 
    for(int i=1;i<=120;i++) //将时间的单位往后延顺到120个单位 
    {
       if(i%2==1)//从此开始，每隔1分钟吃1个Y 
       y=y-x;
       if(i%4==0)//Y出生后每隔2分钟分裂一次
       y=y*2;
       if(i%6==0){  //X出生后每隔3分钟分裂一次
       new_x=x;//新生X 
       x+=new_x;
       //y-=new_x;//一个新出生的X，半分钟之后吃掉1个Y 
       //i++;
       }
    }
    printf("%d",y);
    return 0;

}
```

## 5.  除去次方数

```
自然数的平方数是：1 4 9 16 25 …

自然数的立方数是：1 8 27 64 125 …

自然数的4次方数是：1 16 81 256 …

…

这些数字都可以称为次方数。

1~10000中，去掉所有的次方数，还剩下多少个数字？

参考答案：

9875
```

```
#include<stdio.h>
int main()
{
    int a[10000]={0},num;
    a[1]=1;
    for(int i=2;i<100;i++){
       num=i;
       while(num<10000){
           num*=i;
           if(num>10000) break;
           a[num] = 1;
           printf("%d\n",num);
       }
    }
    int count=0;
    for(int i=1;i<10000;i++)
       if(a[i]==0)   count++;
    printf("\n%d",count);

}
```

## 6.  正六面体染色

```
正六面体用4种颜色染色。

共有多少种不同的染色样式？

要考虑六面体可以任意旋转、翻转。

参考答案：

240
```



```
Burnside引理，正方体涂色问题

(n^6 + 3*n^4 + 12*n^3 + 8*n^2)/24 
```

 

## 7.  古堡算式

```
 福尔摩斯到某古堡探险，看到门上写着一个奇怪的算式：

  ABCDE * ? = EDCBA

  他对华生说：“ABCDE应该代表不同的数字，问号也代表某个数字！”

  华生：“我猜也是！”

  于是，两人沉默了好久，还是没有算出合适的结果来。

  请你利用计算机的优势，找到破解的答案。

  把 ABCDE 所代表的数字写出来。

 

  答案写在“解答.txt”中，不要写在这里！

 

参考答案：

21978
```

```
#include<stdio.h>
```

```
void is_hui(int num1[],int num2[]){
   if(num1[0]==num2[4] && num1[1]==num2[3] && num1[2]==num2[2] && num1[3]==num2[1] && num1[4]==num2[0]){
   printf("%d%d%d%d%d\n",num1[0],num1[1],num1[2],num1[3],num1[4]);
   }  
}
```



```
int is_same(int num[]){
   for(int i=0;i<5;i++){
   for(int j=i+1;j<5;j++)
     if(num[i] == num[j]) {
       return 0;
     }
   }
   return 1;
}
```

 

```
int main()
{
   int num1[5]={0},num2[5]={0};
   for(int i=10234;i<98766;i++){
   num1[4] = i%10;
   num1[3] = i/10%10;
   num1[2] = i/100%10;
   num1[1] = i/1000%10;
   num1[0] = i/10000;
   int flag=is_same(num1);
   if(!flag) continue;
   for(int j=2;j<5;j++){
     int num = i*j;
     if(num>98765) break;
     num2[4] = num%10;
     num2[3] = num/10%10;
     num2[2] = num/100%10;
     num2[1] = num/1000%10;
     num2[0] = num/10000;
   }
   is_hui(num1,num2); 
   }
}
```

## 8.  海盗比酒量

```
有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复...... 直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。
等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“......昨天，我正好喝了一瓶.......奉劝大家，开船不喝酒，喝酒别开船......”
请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人没倒下。
如果有多个可能的答案，请列出所有答案，每个答案占一行。
格式是：人数,人数,...
例如,有一种可能是：20,5,4,2,0
多个答案排列顺序不重要。
答案写在“解答.txt”中，不要写在这里！
参考答案：
18,9,3,2,0   (1分)
15,10,3,2,0   (2分)
20,5,4,2,0   (0分)
12,6,4,2,0   (2分)
```

 

```
int main(){
  for(int i=20;i>0;i--){
   for(int j =i-1;j>0;j--){
     for(int k = j-1;k>0;k--){
       for(int x = k-1;x>0;x--)
       if(1.0/(double)i+1.0/(double)j+1.0/(double)k+1.0/(double)x == 1) printf("%d,%d,%d,%d,0\n",i,j,k,x);
     }
   }
  }
  return 0;
}
```

## 9. 奇怪的比赛

```
某电视台举办了低碳生活大奖赛。题目的计分规则相当奇怪：
每位选手需要回答10个问题（其编号为1到10），越后面越有难度。答对的，当前分数翻倍；答错了则扣掉与题号相同的分数（选手必须回答问题，不回答按错误处理）。
每位选手都有一个起步的分数为10分。
某获胜选手最终得分刚好是100分，如果不让你看比赛过程，你能推断出他（她）哪个题目答对了，哪个题目答错了吗？
如果把答对的记为1，答错的记为0，则10个题目的回答情况可以用仅含有1和0的串来表示。例如：0010110011 就是可能的情况。
你的任务是算出所有可能情况。每个答案占一行。
多个答案顺序不重要。
答案写在“解答.txt”中，不要写在这里！
参考答案：
0010110011 (0分)
0111010000 (4分)
1011010000 (4分)
```

```
#include<stdio.h>
#include<string.h>
```



```
void change_two(int i, char check[], char temp[]) {
  int k = 0;
  while (i) {
    check[k++] = i % 2 + '0';
    i /= 2;
  }
  while (k < 10) 
    check[k++] = '0';
  check[k] = '\0';
  int len = 0;
  for (int j = k - 1; j >= 0; j--)
    temp[len++] = check[j];
  temp[len] = '\0';
}
```

 

```
int count(char temp[]) {
  int sum = 10;
  for (int i = 0; temp[i]; i++) {
    if (temp[i] == '1') 
      sum *= 2;
    else 
      sum -= (i + 1);
  }
  return sum;
}
```

 

```
int main() {
  char check[11], temp[11];
  for (int i = 3; i < 1024; i++) {
    strcpy(check, "");
    strcpy(temp, ""); 
    change_two(i, check, temp);
    int sum = count(temp);
    if (sum == 100) puts(temp);
  }
  return 0;
}
```

## 11. 欧拉与鸡蛋

```
大数学家欧拉在集市上遇到了本村的两个农妇，每人跨着个空篮子。她们和欧拉打招呼说两人刚刚卖完了所有的鸡蛋。
欧拉随便问：“卖了多少鸡蛋呢？”
不料一个说：“我们两人自己卖自己的，一共卖了150个鸡蛋，虽然我们卖的鸡蛋有多有少，但刚好得了同样的钱数。你猜猜看！”
欧拉猜不出。
另一个补充道：“如果我按她那样的价格卖，可以得到32元；如果她按我的价格卖，可以得到24.5元”。
欧拉想了想，说出了正确答案。
我们不是数学家，懒得列出公式来分析。但计算机可以“暴力破解”，就是把所有可能情况都试验一遍，撞上为止！
请写出每人鸡蛋的数目（顺序不限），用逗号隔开。
答案写在“解答.txt”中，不要写在这里！  
参考答案：
70,80 或 80,70
```

```
int main() {
  int i,j;
  int p_i,p_j;
  for(p_i=1;p_i<3200;p_i++)
      for(p_j=1;p_j<2450;p_j++){
         for(i=1;i<150;i++){
             j =150-i; 
             if((double)i*p_j == 3200 && (double)j*p_i == 2450 && p_i*i == p_j*j) printf("%d:%d = %d,%d:%d = %d \n",i,p_j,i*p_j,j,p_i,j*p_i);
           }
       }
    return 0;
}
```

## 12. 巧排扑克牌

```
小明刚上小学，学会了第一个扑克牌“魔术”，到处给人表演。魔术的内容是这样的：
他手里握着一叠扑克牌：A，2，....J，Q，K 一共13张。他先自己精心设计它们的顺序，然后正面朝下拿着，开始表演。
只见他先从最下面拿一张放到最上面，再从最下面拿一张翻开放桌子上，是A；然后再从最下面拿一张放到最上面，再从最下面拿一张翻开放桌子上，是2；......如此循环直到手中只有一张牌，翻开放桌子上，刚好是K。
这时，桌上牌的顺序是：A,2,3,4,5,6,7,8,9,10,J,Q,K
请你计算一下，小明最开始的时候手里牌的顺序是怎样的。
把结果写出来，逗号分割，小明“魔术”开始时，最下面的那张牌输出为第一个数据。
考场不提供扑克牌，你只能用计算机模拟了，撕碎草稿纸模拟扑克属于作弊行为！另外，你有没有把录像倒着放过？很有趣的！回去试试！
参考答案：
7, A, Q, 2, 8, 3, J, 4, 9, 5, K, 6, 10
/*
小明刚上小学，学会了第一个扑克牌“魔术”，到处给人表演。魔术的内容是这样的：
  他手里握着一叠扑克牌：A，2，....J，Q，K 一共13张。他先自己精心设计它们的顺序，然后正面朝下拿着，开始表演。
  只见他先从最下面拿一张放到最上面，再从最下面拿一张翻开放桌子上，是A；然后再从最下面拿一张放到最上面，再从最下面拿一张翻开放桌子上，是2；
    ......如此循环直到手中只有一张牌，翻开放桌子上，刚好是K。
  这时，桌上牌的顺序是：A,2,3,4,5,6,7,8,9,10,J,Q,K
  请你计算一下，小明最开始的时候手里牌的顺序是怎样的。
  把结果写出来，逗号分割，小明“魔术”开始时，最下面的那张牌输出为第一个数据。
*/
```

```
#include"stdio.h"
#include"string.h"
int main()
{
    int i,index,temp;
    int a[13];
    memset(a,0,sizeof(a));  //初始化数组为 0   
    for(i=1,index=1;i<14;i++){
       while(1){
           if(a[index]==0){
              a[index]=i;break;
           }else index++;
       }   
       temp=0;  
       while(1){//每搁两个空位放置，如果有数字往后顺移 
           index++;
           index=index%13;
           if(a[index]==0)   temp++;
           if(temp==2 || i==13) break;        
       }
    }
    for(i=0;i<13;i++)
    {   if(a[i]<=10) printf("%d ",a[i]);
       else if(a[i]==11) printf("J ");
       else if(a[i]==12) printf("Q ");
       else printf("K ");
    }
    printf("\n");
    return 0;
}
```

## 13. 排座位

```
要安排：3个A国人，3个B国人，3个C国人坐成一排。
要求不能使连续的3个人是同一个国籍。
求所有不同方案的总数？
参考答案：
283824
```

```
#include<stdio.h>
#include<string.h>
char people[10]="AAABBBCCC";
int count=0;
```

 

```
int is_same(char ch[]){
    for(int i=0;i<7;i++){
        if(ch[i]==ch[i+1] && ch[i] == ch[i+2]) return 0;   
    }
    if(strlen(ch)<9) return 0;
    return 1;
}
```

 

```
void permute(char people[], int start, int end) {//全排列 
  if (start == end) {
    if(is_same(people)) {
           count++;
       }
  } else {
    for (int i = start; i <= end; i++) {
      {
         char temp = people[start];
         people[start] = people[i];
         people[i] = temp;
           }
      permute(people, start + 1, end);
      {
         char temp = people[start];
         people[start] = people[i];
         people[i] = temp;
           }
    }
  }
}
```

 

```
int main() {
   permute(people, 0, 9);
   printf("%d",count);
}
```

 

## 14. 黄金队列

```
黄金分割数0.618与美学有重要的关系。舞台上报幕员所站的位置大约就是舞台宽度的0.618处，墙上的画像一般也挂在房间高度的0.618处，甚至股票的波动据说也能找到0.618的影子....
黄金分割数是个无理数，也就是无法表示为两个整数的比值。0.618只是它的近似值，其真值可以通过对5开方减去1再除以2来获得，我们取它的一个较精确的近似值：0.618034
有趣的是，一些简单的数列中也会包含这个无理数，这很令数学家震惊！
1 3 4 7 11 18 29 47 .... 称为“鲁卡斯队列”。它后面的每一个项都是前边两项的和。
如果观察前后两项的比值，即：1/3,3/4,4/7,7/11,11/18 ... 会发现它越来越接近于黄金分割数！
你的任务就是计算出从哪一项开始，这个比值四舍五入后已经达到了与0.618034一致的精度。
请写出该比值。格式是：分子/分母。比如：29/47
答案写在“解答.txt”中，不要写在这里！
参考答案：
1364/2207  
```

```
#include<stdio.h>
int main(){
   double a[30][2],x=0,temp;
   a[0][0]=1;a[0][1]=3;
   int i=1;
   int test;
   while(i<50){
       a[i][0] = a[i-1][1];
       a[i][1] = a[i-1][0]+a[i-1][1];
       x= a[i][0]/a[i][1]*1000000;
       test = (int) x;
       temp = (x - test) * 10;
       if((int)temp >= 5) x+=1; 
       if((int)x == 618034) break;
       i++; 
    }
    printf("%lf/%lf\n",a[i][0],a[i][1]);
 }
```

## 15. 汉诺塔计数

 

```
汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。
大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上(可以借助第三根柱子做缓冲)。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
据说完成大梵天的命令需要太多的移动次数，以至被认为完成之时就是世界末日！
你的任务是精确计算出到底需要移动多少次。
很明显，如果只有2个圆盘，需要移动3次。
圆盘数为3，则需要移动7次。
那么64个呢？
答案写在“解答.txt”中，不要写在这里！
参考答案：
18446744073709551615
```

```
如果有n个圆盘，最小步数为2^n - 1。
```

```
#include <stdio.h>
```

```
// 汉诺塔递归函数
int count =0;
void hanoi(int n, char from_rod, char to_rod, char aux_rod) {
  if (n == 1) {
      count++;
    printf("移动圆盘 1 从柱子 %c 到柱子 %c\n", from_rod, to_rod);
    return;
  }
  // 将n-1个圆盘从起始柱移动到辅助柱
  hanoi(n-1, from_rod, aux_rod, to_rod);
  // 移动最大的圆盘从起始柱到目标柱
  count++;
    printf("移动圆盘 %d 从柱子 %c 到柱子 %c\n", n, from_rod, to_rod);
  // 将n-1个圆盘从辅助柱移动到目标柱
  hanoi(n-1, aux_rod, to_rod, from_rod);
}
```



```
int main() {
  int n;
  // 输入圆盘数量
  printf("输入圆盘数量: ");
  scanf("%d", &n);
  // 调用hanoi函数解决问题
  hanoi(n, 'A', 'C', 'B');
  printf("%d",count);
  return 0;
}
```

## 16. 猜生日

```
今年的植树节（2012年3月12日），小明和他的叔叔还有小伙伴们一起去植树。休息的时候，小明的同学问他叔叔多大年纪，他叔叔说：“我说个题目，看你们谁先猜出来！”
“把我出生的年月日连起来拼成一个8位数（月、日不足两位前补0）正好可以被今天的年、月、日整除！”
他想了想，又补充到：“再给个提示，我是6月出生的。”
根据这些信息，请你帮小明算一下，他叔叔的出生年月日。
答案写在“解答.txt”中，不要写在这里！
格式是年月日连成的8位数。
例如，如果是1948年6月12日，就写：19480612
参考答案：
19550604
```

```
#include <stdio.h>
int main() {
    long x = 19000101;
    while(x<20120312){
      int a = x/100%10;
      int b = x/1000%10;
      int c = x%10;
      int d = x/10%10;
      int num = d*10+c;
       if(x%2012 ==0 && x%12==0 && a == 6 && b == 0 )
           if(num > 0 && num<31)
       printf("%ld\n",x); 
       x++;
    }
}
```

## 17. 棋盘上的麦子

```
你一定听说过这个故事。国王对发明国际象棋的大臣很佩服，问他要什么报酬，大臣说：请在第1个棋盘格放1粒麦子，在第2个棋盘格放2粒麦子，在第3个棋盘格放4粒麦子，在第4个棋盘格放8粒麦子，......后一格的数字是前一格的两倍，直到放完所有棋盘格（国际象棋共有64格）。

国王以为他只是想要一袋麦子而已，哈哈大笑。

当时的条件下无法准确计算，但估算结果令人吃惊：即使全世界都铺满麦子也不够用！

请你借助计算机准确地计算，到底需要多少粒麦子。

 

答案写在“解答.txt”中，不要写在这里！

 

参考答案：

18446744073709551615
```

```
2的64次方-1
```

```
#include<stdio.h>

#include<stdlib.h>

//计算2的n次方，创建数组赋予足够大的空间，使用for循环执行n次，如果a[i]>9则a[i]取%10,a[i+1]++，计算n次循环，计算完毕由高到低输出数组
```

```
int main()
{
    int i,j,n=64,a[40]={0};
    a[0] = 1;
    for(i = 0; i < n ;i++)
    {
       for(j = 0;j < 40;j++)
       {//数组的每一个数都乘2
           a[j] *= 2; 
       }
       for(j = 0;j < 40;j++)
       {//逢10进1
           if(a[j] > 9)
           {
              a[j+1]++;
              a[j] = a[j] % 10;
           }
       }
    }
    for(i = 39;i >= 0;i--)
    {
       printf("%d",a[i]);
    }
}
```

## 18. 国庆星期日

```
1949年的国庆节（10月1日）是星期六。 
今年（2012）的国庆节是星期一。
那么，从建国到现在，有几次国庆节正好是星期日呢？
只要答案，不限手段！
可以用windows日历，windows计算器，Excel公式，。。。。。
当然，也可以编程！
不要求写出具体是哪些年，只要一个数目！
千万不要提交源代码！
答案不要写在这里，写在“解答.txt”中
参考答案：
9
```

```
#include<stdio.h>
int data[7] = {7,1,2,3,4,5,6};
int is_leap_year(int year){
    if((year%400 == 0 )||(year%4 ==0 && year%100!=0))
       return 1;
    else return 0;
}
```

 

```
int main()
{
    int day;
    int k=6,count=0;
    for(int i=1950;i<=2012;i++){
       if(is_leap_year(i)) day=366;
       else day =365;
       int add = day % 7;
       k = (k+add)%7;
       if(data[k] == 7) {
           count++;
       }
    }
    printf("%d",count);
}
```

## 19. 找素数

```
素数就是不能再进行等分的整数。比如：7，11。而9不是素数，因为它可以平分为3等份。一般认为最小的素数是2，接着是3，5，... 
请问，第100002(十万零二)个素数是多少？
请注意：“2” 是第一素数，“3” 是第二个素数，依此类推。
不需要提交源代码，只要写出准确的结果即可！
答案写在：“解答.txt”中，不要写在这里。
参考答案：
1299743
```

```
#include<stdio.h>
#include<stdlib.h>
int main() {
   int *num =(int*)malloc(sizeof(int)*100000000);
    for(int i=0;i<100000000;i++) num[i]=0;
    for(int i=2;i<10000;i++){
       for(int j=i*2;j<100000000;j+=i){
           num[j]=1;
       }
    }
    int count =0;
    for(int i=2;i<100000000;i++){
       if(num[i] == 0) {
           count++;
           if(count == 100003) break;
           printf("%d:%d\n",count,i);
       }
    }
  free(num);
  return 0;
}
```

## 20. 填写算式

```
看这个算式：
☆☆☆ + ☆☆☆ = ☆☆☆
如果每个五角星代表 1 ~ 9 的不同的数字。
这个算式有多少种可能的正确填写方法？
173 + 286 = 459
295 + 173 = 468
173 + 295 = 468
183 + 492 = 675
以上都是正确的填写法！
注意：
111 + 222 = 333 是错误的填写法！
因为每个数字必须是不同的！ 
也就是说：1~9中的所有数字，每个必须出现且仅出现一次！
注意：
不包括数字“0”！
注意：
满足加法交换率的式子算两种不同的答案。
所以答案肯定是个偶数
注意：
只要求计算不同的填法的数目
不要求列出所有填写法
更不要求填写源代码！
答案不要写在这里，请写在“解答.txt”中！
参考答案：
336
```

```
#include<stdio.h>
```

```
void swap(int *a, int *b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}
```

```
int count=0;
void permute(int *num, int start, int end) {
  if (start == end) {
    // 打印当前排列
    if(num[0]*100+num[1]*10+num[2]+num[3]*100+num[4]*10+num[5] == (num[6]*100+num[7]*10+num[8])){
        count++;
           for (int i = 0; i < end; i++) 
      printf("%d ", num[i]);
      printf("\n");
       }
  } else {
    // 递归生成排列
    for (int i = start; i < end; i++) {
      swap(&num[start], &num[i]);
      permute(num, start + 1, end);
      swap(&num[start], &num[i]); // 恢复数组状态
    }
  }
}
```

 

```
int main() {
  int num[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
  permute(num, 0, 9);
  printf("%d",count);
  return 0;
}
```

## 21. 取字母组成串

```
A B C D中取5次，每个字母都可以重复取出，形成一个串。
现在要求，串中A出现的次数必须为偶数（0次也算偶数）。
求可以形成多少种可能的串。
参考答案：
528
```

```
#include <stdio.h>
```

```
int A_is(char ch[]){
    int count=0;
    for(int i=0;i<5;i++){
       if(ch[i] == 'A') count++;
    }
    switch(count){
       case 0:
       case 2:
       case 4: return 1;
       default: return 0;
    }
}
```

 

```
int count=0;
void generateCombinations(char set[], int n, int k, char result[], int index) {
  if (index == k) {
    for (int i = 0; i < k; i++) {
      printf("%c ", result[i]);
    }
    int flag = A_is(result);
    if(flag == 1) count++;
    printf("\n");
    return;
  }
  for (int i = 0; i < n; i++) {
    result[index] = set[i];
    generateCombinations(set, n, k, result, index + 1);
  }
}
```

 

```
int main() {
  char set[] = {'A', 'B', 'C', 'D'};
  int n = sizeof(set) / sizeof(set[0]);
  int k = 5;
  char result[k];
  generateCombinations(set, n, k, result, 0);
  printf("%d",count);
  return 0;
}
```

