---
title: 行为型模式（下）
categories: 阅读
date: 2024-10-04 10:20:45
tags: 设计模式


---

# **行为型模式**（下）

<!--more-->

## 观察者模式

**观察者模式（Observer Pattern）**是一种软件设计模式，在这种模式中，一个对象被称为*主体（Subject）*，它维护一系列依赖于它的*观察者（Observer）*。当主体的状态发生改变时，它会通知所有的观察者，使得它们能够自动更新。这种模式用于建立对象之间的一对多关系，支持基于事件的机制，实现了对象之间的松耦合。

**观察者模式**更强调的是主体（服务器）的状态变化会主动通知所有的观察者（客户端），不论这些观察者是否请求或者触发了这种变化。例如：

- **系统公告**：服务器主动发布公告，所有已注册的客户端都会收到通知。
- **实时推送**：服务器推送天气预报、股票行情等实时更新，所有订阅的客户端都会接收到最新信息。

在这样的场景中，客户端是被动接收通知的，而不是主动触发消息的发送

### 代码实现

```
#include <iostream>  
#include <string>  
#include <list>  
#include <memory>  

// 抽象观察者  
class Observer {
public:
    virtual ~Observer() {}
    virtual void update(const std::string& message_from_subject) = 0;
};

// 抽象主体  
class Subject {
public:
    virtual ~Subject() {}
    virtual void attach(std::shared_ptr<Observer> observer) = 0;
    virtual void detach(std::shared_ptr<Observer> observer) = 0;
    virtual void notify() = 0;
};

// 具体主体类：天气站  
class WeatherStation : public Subject {
private:
    std::list<std::weak_ptr<Observer>> observers_;
    std::string message_;

public:
    virtual ~WeatherStation() {
        std::cout << "WeatherStation被销毁了。\n";
    }

    void attach(std::shared_ptr<Observer> observer) override {
        observers_.push_back(observer);
    }

    void detach(std::shared_ptr<Observer> observer) override {
        observers_.remove_if(
            [&](const std::weak_ptr<Observer>& wp) {
                return wp.lock() == observer;
            });
    }

    void notify() override {
        for (auto it = observers_.begin(); it != observers_.end(); ) {
            if (auto obs = it->lock()) {
                obs->update(message_);
                ++it;
            }
            else {
                // 移除已销毁的观察者  
                it = observers_.erase(it);
            }
        }
    }

    void createMessage(const std::string& message = "空消息") {
        this->message_ = message;
        notify();
    }
};

// 具体观察者类：客户端  
class Client : public Observer, public std::enable_shared_from_this<Client> {
private:
    std::string name_;
    WeatherStation& subject_;

public:
    Client(const std::string& name, WeatherStation& subject)
        : name_(name), subject_(subject) {
        // 在构造函数中不能直接调用 shared_from_this()  
        std::cout << "客户端 " << name_ << " 已创建。\n";
    }

    void registerToSubject() {
        subject_.attach(shared_from_this());
        std::cout << "客户端 " << name_ << " 已订阅天气通知。\n";
    }

    virtual ~Client() {
        std::cout << "客户端 " << name_ << " 已取消订阅天气通知。\n";
    }

    void update(const std::string& message_from_subject) override {
        std::cout << "客户端 " << name_ << " 收到天气通知： "
            << message_from_subject << "\n";
    }

    void removeMeFromTheList() {
        subject_.detach(shared_from_this());
        std::cout << "客户端 " << name_ << " 已从通知列表中移除。\n";
    }
};

int main() {
    WeatherStation weather_station;

    // 创建客户端对象，使用std::shared_ptr管理  
    auto client1 = std::make_shared<Client>("Alice", weather_station);
    auto client2 = std::make_shared<Client>("Bob", weather_station);
    auto client3 = std::make_shared<Client>("Charlie", weather_station);

    // 在创建对象后注册到WeatherStation  
    client1->registerToSubject();
    client2->registerToSubject();
    client3->registerToSubject();

    std::cout << "\n天气预报员：发送“即将下雨”的通知。\n";
    weather_station.createMessage("即将下雨，请带好雨具！");

    std::cout << "\nBob 取消订阅天气通知。\n";
    client2->removeMeFromTheList();

    std::cout << "\n天气预报员：发送“天气转晴”的通知。\n";
    weather_station.createMessage("天气转晴，祝您有美好的一天！");

    return 0;
}
```

### 具体分析

#### 特点

- **主体与观察者分离**：主体和观察者之间通过抽象耦合，主体不需要知道观察者的具体实现，反之亦然。
- **动态联动**：可以在运行时动态添加和删除观察者，灵活应对变化。
- **广播机制**：主体状态改变时，会自动通知所有的观察者，实现广播通信。

#### 优缺点

**优点：**

- **解耦合**：主体与观察者之间的依赖是抽象的，减少了耦合度。
- **灵活性**：可以在运行时添加或移除观察者，无需修改主体的代码。
- **可扩展性**：新增观察者时，无需修改主体代码，符合开闭原则。

**缺点：**

- **可能的性能问题**：当观察者数量较多时，通知所有观察者可能会消耗较多时间。
- **复杂性增加**：涉及多个对象，增加了系统的复杂性。
- **内存泄漏风险**：观察者未正确解除订阅，可能导致内存泄漏。

#### 适用场景

- **当一个对象的改变需要同时改变其他对象**，且对象数量不确定时。
- **事件驱动的系统**，如GUI应用程序中的事件监听机制。
- **需要将一个对象的变化通知给其他对象**，而又希望系统具有低耦合、高扩展性。

## 状态模式

**状态模式**允许一个对象在其内部状态发生改变时，改变它的行为。这种模式涉及到一个对象的状态转换，这些状态封装在独立的类中，对象的行为随着状态的改变而改变。

**适用场景**：

- 一个对象的行为取决于其状态，并且它必须在运行时根据状态改变其行为。
- 消除庞大的条件语句，将与状态相关的行为分布到独立的状态类中。

这个不太适合用一个cpp做，大概看看结构

```
/OrderStatePattern  
├── Order.h  
├── Order.cpp  
├── OrderState.h  
├── NewOrderState.h  
├── NewOrderState.cpp  
├── PaidOrderState.h  
├── PaidOrderState.cpp  
├── ShippedOrderState.h  
├── ShippedOrderState.cpp  
├── DeliveredOrderState.h  
├── DeliveredOrderState.cpp  
├── CanceledOrderState.h  
├── CanceledOrderState.cpp  
├── main.cpp  
└── Makefile
```

```
 OrderState.h
作用：定义了订单状态的抽象基类 OrderState，包含了订单状态需要实现的所有接口方法。
主要内容：
声明了纯虚函数（pay、ship、deliver、cancel 和 getName），供具体状态类重写。
2. Order.h 和 Order.cpp
作用：定义了 Order 类，表示订单对象，维护订单的当前状态，并提供操作订单的方法。
主要内容：
Order.h：声明了订单类，包含订单 ID 和当前状态。
Order.cpp：实现了订单的构造函数和操作方法（pay、ship、deliver、cancel），以及设置状态和获取状态名称的方法。
3. NewOrderState.h 和 NewOrderState.cpp
作用：定义了新建状态 NewOrderState 类，表示订单处于“新建”状态时的行为。
主要内容：
NewOrderState.h：声明了新建状态类，继承自 OrderState。
NewOrderState.cpp：实现了在新建状态下的各个操作方法，如支付、发货、取消等。
4. PaidOrderState.h 和 PaidOrderState.cpp
作用：定义了已支付状态 PaidOrderState 类，表示订单处于“已支付”状态时的行为。
主要内容：
PaidOrderState.h：声明了已支付状态类，继承自 OrderState。
PaidOrderState.cpp：实现了在已支付状态下的各个操作方法，如发货、取消等。
5. ShippedOrderState.h 和 ShippedOrderState.cpp
作用：定义了已发货状态 ShippedOrderState 类表示订单处于“已发货”状态时的行为。
主要内容：
ShippedOrderState.h：声明了已发货状态类，继承自 OrderState。
ShippedOrderState.cpp：实现了在已发货状态下的各个操作方法，如确认收货、取消等。
6. DeliveredOrderState.h 和 DeliveredOrderState.cpp
作用：定义了已完成状态 DeliveredOrderState 类，表示订单处于“已完成”状态时的行为。
主要内容：
DeliveredOrderState.h：声明了已完成状态类，继承自 OrderState。
DeliveredOrderState.cpp：实现了在已完成状态下的各个操作方法，通常这些操作都无法进行（如再次支付、发货等）。
7. CanceledOrderState.h 和 CanceledOrderState.cpp
作用：定义了取消状态 CanceledOrderState 类，表示订单处于“取消”状态时的行为。
主要内容：
CanceledOrderState.h：声明了取消状态类，继承自 OrderState。
CanceledOrderState.cpp：实现了在取消状态下的各个操作方法，通常这些操作都无法进行。
```

### 优点与适用性

**优点：**

- **将与特定状态相关的行为局部化**，并且将不同状态的行为分割开，遵循了单一职责原则。
- **消除了庞大的条件分支语句**，状态的转换被封装在状态类中，增加新的状态非常容易。
- **增加了系统的灵活性和可扩展性**，可以方便地增加新的状态和行为，而不影响其他状态的实现。

**适用性：**

- 当一个对象的行为取决于它的状态，并且必须在运行时根据状态改变其行为时。
- 当一个操作中含有大量与对象状态有关的条件分支语句时，可以考虑使用状态模式将这些条件语句的每个分支移到相应的状态类中。

## 策略模式

**策略模式**是一种行为设计模式，允许在运行时选择算法或行为。通过将一系列算法封装到独立的类中，使它们可以相互替换，从而使算法的变化不会影响到使用算法的客户端。

### **意图**

- **定义一系列算法**，把它们一个个封装起来，并且使它们可以相互替换。
- 策略模式使得算法可以独立于使用它的客户端（Context）而变化。



策略模式主要包含以下几个角色：

1. **策略接口（Strategy）**：定义了算法的公共接口。
2. **具体策略（ConcreteStrategy）**：实现了策略接口的具体算法。
3. **上下文（Context）**：持有一个策略对象的引用，调用策略的方法来完成相关工作。



将不同的排序算法封装在各自的类中，并在 `main` 函数中根据需要选择不同的排序类，这正是**策略模式（Strategy Pattern）**的典型应用。



### **策略模式的优缺点**

#### **优点**

1. **算法可以自由切换**：通过策略模式，可以在运行时动态地更改对象的行为。
2. **扩展性好**：添加新的策略非常方便，符合开闭原则。
3. **避免使用多重条件判断**：策略模式通过多态性消除了条件语句。

#### **缺点**

1. **增加了类的数量**：每个策略都是一个类，会导致类数量增加。
2. **可能导致所有策略暴露**：客户端必须知道所有的策略类，选择合适的策略。

------

### **适用场景**

- **动态地选择算法**：如排序算法、加密算法、压缩算法等，可以根据需求动态选择。
- **多种变体的行为**：对象的行为有多种变体，需要在不同情况下选择不同的行为。
- **避免条件判断**：希望通过策略模式消除冗长的条件判断语句。



## 模板方法

模板方法模式的核心思想是：**在父类中定义算法的框架，而将某些步骤的实现延迟到子类中。这样，子类可以在不改变算法整体结构的情况下，重新定义算法中的某些步骤。**

- **控制模板方法的可重写性**：在一些语言中（如Java），可以将模板方法声明为 `final`，防止子类重写。在C++中，需要通过约定来避免子类重写模板方法。
- **避免反向调用**：在模板方法模式中，通常是父类调用子类的方法，不要让子类反过来调用父类的具体方法，避免增加系统的复杂性。



电脑组装的类比非常贴切：

- **模板方法模式**决定了**组装电脑的整体流程框架**，即首先选择主板，然后依次选择 CPU、内存条、显卡、电源、机箱等。这些步骤的顺序是固定的，由模板方法定义和控制。
- **策略模式**决定了**每个组件的具体选择**，例如使用哪种品牌和型号的 CPU、什么容量和频率的内存条、哪种性能的显卡等。策略模式允许在每个步骤中根据需求和条件灵活地选择具体的实现。

因此，在实际的设计中，可以将**模板方法模式**和**策略模式**相结合：

- **模板方法模式**定义了算法的整体结构和流程，确保了步骤的执行顺序和整体的一致性。
- **策略模式**为每个步骤提供了可替换的实现，使得系统在保持算法结构不变的情况下，具有高度的灵活性和可扩展性。

这种结合使用可以既**保证系统结构的稳定性**，又**提供了灵活的可扩展性**。

------

### **补充说明**

#### **模板方法模式中的钩子方法（Hook Methods）**

在模板方法模式中，除了定义抽象的基本操作外，父类还可以提供**钩子方法**。钩子方法是一种在父类中定义的方法，默认实现为空或默认行为，子类可以根据需要选择性地重写这些方法，从而进一步定制算法的行为。



## 访问者模式

**访问者模式**是一种行为型设计模式。它能将作用于某种对象结构中的各元素的操作分离出来，使得操作可在不改变各元素的类的前提下定义作用于这些元素的新操作。

**简单来说**，访问者模式允许你在不修改现有类的情况下，增加作用于这些类的新功能。

通过在原本的对象（元素）中加入 `accept` 方法（而不是直接加入 `Visitor` 类），我们可以在不修改对象类的情况下，对对象的资源进行操作。

- - 为了让访问者能够作用于元素对象上，我们需要在元素类中加入一个 `accept(Visitor* visitor)` 方法。
  - 这个方法的作用是接受一个访问者对象，然后调用访问者的对应方法，将自身作为参数传递过去。
- **不修改原有对象的其他部分**：
  - 一旦元素类实现了 `accept` 方法，我们就不需要再修改元素类的其他部分了。
  - 以后如果需要对元素对象进行新的操作，只需要新建一个访问者类，实现对应的访问方法即可

|                  |            |                                                              |                                            |                                                    |
| ---------------- | ---------- | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------------------------- |
| **设计模式名称** | **类型**   | **定义**                                                     | **主要特点**                               | **典型应用场景**                                   |
| **单例模式**     | 创建型模式 | 确保一个类只有一个实例，并提供全局访问点。                   | 控制实例数量、全局访问、延迟初始化         | 日志记录器、配置管理器、线程池等需要唯一实例的场景 |
| **工厂方法模式** | 创建型模式 | 定义一个创建对象的接口，让子类决定实例化哪一个类。           | 解耦对象创建与使用、支持扩展               | 框架中创建用户自定义对象的场景                     |
| **抽象工厂模式** | 创建型模式 | 提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。 | 创建产品族、产品间一致性、易于交换产品系列 | 跨平台UI库，需要创建不同风格的控件                 |
| **建造者模式**   | 创建型模式 | 将一个复杂对象的构建与其表示分离，使同样的构建过程可以创建不同的表示。 | 分步骤构建、复杂对象创建、代码复用         | 创建复杂对象，如组装计算机、构建房屋等             |
| **原型模式**     | 创建型模式 | 用原型实例指定创建对象的种类，并通过复制这个原型来创建新的对象。 | 克隆对象、避免大量初始化、动态加载         | 需要大量相似对象、副本的场景，如游戏中的单位复制   |
| **适配器模式**   | 结构型模式 | 将一个类的接口转换成客户端期望的另一个接口，使得原本接口不兼容的类可以合作。 | 接口转换、兼容旧代码、解耦客户端与实现     | 老系统与新系统整合，使用第三方库但接口不兼容       |
| **桥接模式**     | 结构型模式 | 将抽象部分与实现部分分离，使它们都可以独立地变化。           | 抽象与实现分离、多维度变化、组合而非继承   | 图形界面抽象与平台实现分离，支持多种平台和外观风格 |
| **组合模式**     | 结构型模式 | 将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用一致。 | 层次结构、统一处理单个和组合对象、递归组合 | 文件系统目录结构、UI组件树、组织机构图             |
| **装饰者模式**   | 结构型模式 | 动态地给对象增加一些额外的职责，提供了比继承更有弹性的功能扩展方式。 | 动态扩展功能、透明扩展、多次装饰           | 为对象添加额外功能，如输入流的缓冲、日志记录等     |
| **外观模式**     | 结构型模式 | 为子系统中的一组接口提供一个一致的界面，定义一个高层接口，使子系统更易于使用。 | 简化接口、隐藏复杂性、降低耦合             | 提供库的简化接口、简化客户端对复杂系统的调用       |
| **享元模式**     | 结构型模式 | 使用共享对象来减少内存占用，提供大量细粒度对象的高效支持。   | 对象共享、减少内存、内部状态与外部状态分离 | 字处理器中的字符对象、游戏中的粒子系统             |
| **代理模式**     | 结构型模式 | 为其他对象提供一种代理以控制对这个对象的访问。               | 控制访问、延迟加载、远程代理、虚拟代理     | 远程代理、虚拟代理、保护代理、安全代理等           |
| **职责链模式**   | 行为型模式 | 将请求的发送者和接受者解耦，使多个对象都有机会处理这个请求，形成一个链条。 | 解耦请求与处理者、动态组合处理者、按需处理 | 事件处理机制、审批流程、日志记录链                 |
| **命令模式**     | 行为型模式 | 将请求封装为对象，从而使您可用不同的请求对客户进行参数化。   | 请求封装、支持撤销和恢复、队列请求         | GUI按钮操作、事务系统、任务队列                    |
| **解释器模式**   | 行为型模式 | 给定一种语言，定义它的文法表示，并定义一个解释器来处理这个语法。 | 自定义语言、语法解析、抽象语法树           | 正则表达式引擎、数学表达式计算器、脚本语言解释器   |
| **迭代器模式**   | 行为型模式 | 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 | 遍历集合、统一遍历方式、解耦集合与遍历算法 | 遍历数据结构，如列表、树、图等                     |
| **中介者模式**   | 行为型模式 | 用一个中介对象来封装一系列对象交互，使对象不需要显式地相互引用。 | 降低对象耦合、集中控制交互、方便维护       | GUI组件交互、聊天室系统、飞机指挥系统              |
| **备忘录模式**   | 行为型模式 | 在不破坏封装性的前提下，捕获对象的内部状态，并在需要时恢复。 | 状态保存与恢复、封装性、撤销操作           | 文本编辑器的撤销、事务回滚、游戏存档               |
| **观察者模式**   | 行为型模式 | 定义对象间的一种一对多的依赖，当一个对象的状态发生改变时，其依赖者会得到通知并自动更新。 | 发布订阅、松耦合、支持广播通信             | GUI事件机制、消息队列、数据绑定                    |
| **状态模式**     | 行为型模式 | 允许对象在内部状态改变时改变其行为，对象看起来好像修改了其类。 | 封装状态、状态切换、行为随状态改变         | 电梯状态控制、订单状态流转、工作流系统             |
| **策略模式**     | 行为型模式 | 定义一系列算法，将每个算法封装起来，并使它们可以互相替换。   | 算法封装、动态切换、消除条件判断           | 排序策略、路径规划、价格计算策略                   |
| **模板方法模式** | 行为型模式 | 定义算法的框架，将某些步骤的实现延迟到子类。                 | 固定算法骨架、延迟实现、代码复用           | 数据处理流程、游戏AI行为、算法模板                 |
| **访问者模式**   | 行为型模式 | 表示一个作用于某对象结构中的各元素的操作，可在不改变各元素的类的前提下定义新操作。 | 操作与结构分离、添加新操作方便、双分派     | 编译器的语法树遍历、对象结构的统计分析             |
|                  |            |                                                              |                                            |                                                    |

# 扩展：面向对象设计的基本原则

## **开闭原则（Open-Closed Principle）**

**定义**：

开闭原则是面向对象设计的基本原则之一，由Bertrand Meyer在他的著作《面向对象软件构造》中提出。**它的定义是：软件实体（类、模块、函数等）应该对**扩展**开放，对**修改**关闭。**

**含义**：

- **对扩展开放**：意味着软件实体应该能够通过扩展来实现功能的增加和变化，而不需要修改现有的代码。
- **对修改关闭**：意味着在增加新功能或需求变化时，不应该修改已经存在的代码，以防止对系统造成影响，降低引入新bug的风险。

**目的**：

- **提高代码的可维护性和可扩展性**：通过遵循开闭原则，可以在不修改已有代码的情况下，添加新功能，减少代码的耦合性。

**实现开闭原则的方式**：

1. **使用抽象层**：通过面向抽象编程，定义抽象类或接口，具体的实现由子类或实现类来完成。
2. **使用多态性**：利用继承和多态机制，新的功能通过继承基类并重写其方法来实现。