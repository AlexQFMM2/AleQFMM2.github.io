<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="网络是如何连接的（TCP&#x2F;IP编程）一、网络连接的大致概括1、dns解析DNS 查询通过递归查询和迭代查询的方式来逐级获取 IP 地址。当你输入一个域名时，首先查询的是本地的 DNS 缓存，若未命中则通过本地 DNS 服务器向根 DNS 服务器发送查询请求。根 DNS 服务器会指向顶级域名服务器（如 .com、.org），然后逐步找到权威 DNS 服务器，最终返回对应的 IP 地址。 2">
<meta property="og:type" content="article">
<meta property="og:title" content="网络是如何连接的">
<meta property="og:url" content="http://example.com/2024/09/21/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/index.html">
<meta property="og:site_name" content="AlexHome">
<meta property="og:description" content="网络是如何连接的（TCP&#x2F;IP编程）一、网络连接的大致概括1、dns解析DNS 查询通过递归查询和迭代查询的方式来逐级获取 IP 地址。当你输入一个域名时，首先查询的是本地的 DNS 缓存，若未命中则通过本地 DNS 服务器向根 DNS 服务器发送查询请求。根 DNS 服务器会指向顶级域名服务器（如 .com、.org），然后逐步找到权威 DNS 服务器，最终返回对应的 IP 地址。 2">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-21T16:28:45.000Z">
<meta property="article:modified_time" content="2024-12-01T13:58:43.022Z">
<meta property="article:author" content="AlexQFMM">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/09/21/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>网络是如何连接的 | AlexHome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">AlexHome</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
        <li class="menu-item menu-item-mypage">

    <a href="/MYHTML/test/index.html" rel="section"><i class="fas fa-file-user fa-fw"></i>myPage</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/21/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.jpg">
      <meta itemprop="name" content="AlexQFMM">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AlexHome">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          网络是如何连接的
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-21 16:28:45" itemprop="dateCreated datePublished" datetime="2024-09-21T16:28:45+00:00">2024-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-01 13:58:43" itemprop="dateModified" datetime="2024-12-01T13:58:43+00:00">2024-12-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
            </span>

          
            <span id="/2024/09/21/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/" class="post-meta-item leancloud_visitors" data-flag-title="网络是如何连接的" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/09/21/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/09/21/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="网络是如何连接的（TCP-IP编程）"><a href="#网络是如何连接的（TCP-IP编程）" class="headerlink" title="网络是如何连接的（TCP&#x2F;IP编程）"></a>网络是如何连接的（TCP&#x2F;IP编程）</h1><h2 id="一、网络连接的大致概括"><a href="#一、网络连接的大致概括" class="headerlink" title="一、网络连接的大致概括"></a>一、网络连接的大致概括</h2><h6 id="1、dns解析"><a href="#1、dns解析" class="headerlink" title="1、dns解析"></a>1、dns解析</h6><p>DNS 查询通过递归查询和迭代查询的方式来逐级获取 IP 地址。当你输入一个域名时，首先查询的是本地的 DNS 缓存，若未命中则通过本地 DNS 服务器向根 DNS 服务器发送查询请求。根 DNS 服务器会指向顶级域名服务器（如 .com、.org），然后逐步找到权威 DNS 服务器，最终返回对应的 IP 地址。</p>
<h6 id="2、socket（套接字）创建"><a href="#2、socket（套接字）创建" class="headerlink" title="2、socket（套接字）创建"></a>2、socket（套接字）创建</h6><p>使用socket库中的socket组件创立一个套接字，创建成功后会返回一个描述符</p>
<h6 id="3、服务器连接"><a href="#3、服务器连接" class="headerlink" title="3、服务器连接"></a>3、服务器连接</h6><p>使用socket库中的connect组件进行连接（客户端连接服务器）</p>
<h6 id="4、数据的发送与接受"><a href="#4、数据的发送与接受" class="headerlink" title="4、数据的发送与接受"></a>4、数据的发送与接受</h6><p>通过socket库中的write或者send组件进行发送</p>
<p>通过socket库中的read或者recv组件进行接受</p>
<h6 id="5、断开连接"><a href="#5、断开连接" class="headerlink" title="5、断开连接"></a>5、断开连接</h6><p>通过socket库中的close组件进行断开连接</p>
<span id="more"></span>

<h6 id="追加：在ubuntu下的dns解析器的调用"><a href="#追加：在ubuntu下的dns解析器的调用" class="headerlink" title="追加：在ubuntu下的dns解析器的调用"></a>追加：在ubuntu下的dns解析器的调用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">alexqfmm@ubuntu:~/Codes/dns解析$ cat main.cpp </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  if (argc != 2) // 如果输入的参数没有域名则提示</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please input a hostname\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int get_back = -1;        // 定义getaddrinfo函数返回值</span><br><span class="line">  struct addrinfo hints;    // 定义一个结构体</span><br><span class="line">  struct addrinfo *res;     // 定义函数返回的结构体链表的指针</span><br><span class="line">  struct addrinfo *read;    // 定义一个遍历链表的指针</span><br><span class="line">  struct sockaddr_in *addr; // 定义一个存储返回域名IP信息的结构体指针</span><br><span class="line"></span><br><span class="line">  memset(&amp;hints, 0, sizeof(hints)); // 将存放信息的结构体清零</span><br><span class="line">  hints.ai_flags = AI_PASSIVE;      // 写入期望返回的结构体的相关信息</span><br><span class="line">  hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">  hints.ai_family = AF_INET;</span><br><span class="line">  hints.ai_protocol = 0;</span><br><span class="line"></span><br><span class="line">  get_back = getaddrinfo(argv[1], NULL, &amp;hints, &amp;res); // 调用函数</span><br><span class="line"></span><br><span class="line">  if (get_back != 0) // 如果函数调用失败</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Analyze faliure:%s\n&quot;, strerror(errno));</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Analyze successfully\n&quot;); // 调用函数成功</span><br><span class="line"></span><br><span class="line">  for (read = res; read != NULL; read = read-&gt;ai_next) // 遍历链表每一个节点，查询关于存储返回的IP的信息</span><br><span class="line">  &#123;</span><br><span class="line">    addr = (struct sockaddr_in *)read-&gt;ai_addr;            // 将返回的IP信息存储在addr指向的结构体中</span><br><span class="line">    printf(&quot;IP address: %s\n&quot;, inet_ntoa(addr-&gt;sin_addr)); // inet_ntoa函数将字符串类型IP地址转化为点分十进制</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  freeaddrinfo(res); // 释放getaddrinfo函数调用动态获取的空间</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检测正确性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">alexqfmm@ubuntu:~/Codes/dns解析$ ./main.out www.baidu.com</span><br><span class="line">Analyze successfully</span><br><span class="line">IP address: 223.109.82.41</span><br><span class="line">IP address: 223.109.82.6</span><br><span class="line"></span><br><span class="line">alexqfmm@ubuntu:~/Codes/dns解析$ nslookup www.baidu.com</span><br><span class="line">Server:		127.0.0.53</span><br><span class="line">Address:	127.0.0.53#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.baidu.com	canonical name = www.a.shifen.com.</span><br><span class="line">Name:	www.a.shifen.com</span><br><span class="line">Address: 223.109.82.41</span><br><span class="line">Name:	www.a.shifen.com</span><br><span class="line">Address: 223.109.82.6</span><br><span class="line">Name:	www.a.shifen.com</span><br><span class="line">Address: 2409:8c20:6:1d55:0:ff:b09c:7d77</span><br><span class="line">Name:	www.a.shifen.com</span><br><span class="line">Address: 2409:8c20:6:1135:0:ff:b027:210c</span><br></pre></td></tr></table></figure>

<h1 id="TPC-IP编程"><a href="#TPC-IP编程" class="headerlink" title="TPC&#x2F;IP编程"></a>TPC&#x2F;IP编程</h1><h2 id="1、hello（TCP）"><a href="#1、hello（TCP）" class="headerlink" title="1、hello（TCP）"></a>1、hello（TCP）</h2><h3 id="linux版本"><a href="#linux版本" class="headerlink" title="linux版本"></a>linux版本</h3><p>server端（具体客户机和服务器双端的搭建方式查看网络连接的前篇博客）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;     // 提供close()函数，进程控制等Unix系统调用</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;  // 提供IP地址转换函数，如htonl(), htons()等</span><br><span class="line">#include &lt;sys/socket.h&gt; // 提供socket创建、绑定、监听、接受等套接字相关操作</span><br><span class="line">#include &lt;netinet/in.h&gt; // 包含 sockaddr_in 结构体定义，该头文件被#include&lt;sys/socket.h&gt;包括</span><br><span class="line">#include &lt;cerrno&gt;       //perror</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//服务器套节字和客户端套节字，int型</span><br><span class="line">int s_sock, c_sock;</span><br><span class="line"></span><br><span class="line">//sockaddr_in:存储网络地址结构如下</span><br><span class="line">/*</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t    sin_family; // 地址族（通常是 AF_INET）</span><br><span class="line">    uint16_t       sin_port;   // 端口号，以网络字节序（大端）存储</span><br><span class="line">    struct in_addr sin_addr;   // IP 地址             </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 结构体中的内嵌结构体</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t s_addr;           // IP 地址，以网络字节序（大端）存储</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">struct sockaddr_in s_addr, c_addr;</span><br><span class="line"></span><br><span class="line">//socklen_t 是一个无符号整数类型，用于表示套接字地址结构体的长度</span><br><span class="line">//typedef unsigned int socklen_t; 有些平台是 uint32_t</span><br><span class="line">socklen_t c_addr_size;</span><br><span class="line"></span><br><span class="line">//要发送的信息</span><br><span class="line">string MSG = &quot;Hello TCP/IP\n&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//创建服务器套节字</span><br><span class="line">int create_server_socket() &#123;</span><br><span class="line">    //int socket(int domain, int type,int protocol);</span><br><span class="line">    //地址族、套节字类型、协议</span><br><span class="line">    /*</span><br><span class="line">        domain:</span><br><span class="line">            AF_INET: IPv4 地址族，表示该套接字用于 IPv4 网络协议。</span><br><span class="line">            AF_INET6: IPv6 地址族，表示该套接字用于 IPv6 网络协议。</span><br><span class="line">            AF_UNIX（或 AF_LOCAL）: 本地通信地址族，表示用于本地进程间通信（IPC）。</span><br><span class="line">        type:</span><br><span class="line">            SOCK_STREAM: 流式套接字，提供面向连接的、可靠的数据传输，通常用于 TCP。</span><br><span class="line">            SOCK_DGRAM: 数据报套接字，提供无连接的数据传输，通常用于 UDP。</span><br><span class="line">            SOCK_RAW: 原始套接字，提供对底层协议的访问，常用于网络层和链路层的操作。</span><br><span class="line">        protocol:</span><br><span class="line">            对于 SOCK_STREAM（TCP），protocol 通常设置为 0，使用默认的 TCP 协议。</span><br><span class="line">            对于 SOCK_DGRAM（UDP），protocol 通常设置为 0，使用默认的 UDP 协议。</span><br><span class="line">    */</span><br><span class="line">    int sock = socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (sock == -1) &#123;</span><br><span class="line">        perror(&quot;Socket creation failed&quot;);</span><br><span class="line">        throw runtime_error(&quot;Socket creation failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Server socket created successfully.&quot; &lt;&lt; endl;</span><br><span class="line">    return sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//绑定服务器套节字到制定端口</span><br><span class="line">void bind_server_socket(int sock, const string&amp; port) &#123;</span><br><span class="line">    //初始化服务器地址</span><br><span class="line">    memset(&amp;s_addr, 0, sizeof(s_addr));</span><br><span class="line">    //服务器地址族为IPV4</span><br><span class="line">    s_addr.sin_family = AF_INET; </span><br><span class="line">    //允许通过的接口 为 INADDR_ANY(宏:0.0.0.0 -&gt; 代表任何可用的网络接口)</span><br><span class="line">    //htonl(Host TO Network Long) 将32位的主机字节序（小端） 转换成 网络字节序(大端); 一般用于IP</span><br><span class="line">    s_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    //htons(Host TO Network Short) 将16位的主机字节序（小端） 转换成 网络字节序(大端); 一般用于端口</span><br><span class="line">    s_addr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">    //int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">    //套节字描述符，sockaddr指针，结构体的长度</span><br><span class="line">    /*</span><br><span class="line">        struct sockaddr &#123;               //是一个通用的地址结构体，提供了统一的接口。</span><br><span class="line">            unsigned short sa_family;   // 地址族</span><br><span class="line">            char sa_data[14];           // 地址数据(16进制),存放协议簇(两位)、ip地址(4位)、端口号(2位)和填充信息(剩余)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    */</span><br><span class="line">    if (bind(sock, (struct sockaddr*)&amp;s_addr, sizeof(s_addr)) == -1) &#123;</span><br><span class="line">        perror(&quot;Bind failed&quot;);</span><br><span class="line">        close(sock);</span><br><span class="line">        throw runtime_error(&quot;Bind failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Server socket is bound to IP: &quot; </span><br><span class="line">         &lt;&lt; inet_ntoa(s_addr.sin_addr) //将结构体里的地址转换为点分十进制，不安全</span><br><span class="line">         &lt;&lt; &quot; and port: &quot; </span><br><span class="line">         &lt;&lt; ntohs(s_addr.sin_port) </span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//开始监听</span><br><span class="line">void start_listening(int sock) &#123;</span><br><span class="line">    //int listen(int sockfd, int backlog);</span><br><span class="line">    //套节字类型，请求队列的大小(超过大小会连接不上)</span><br><span class="line">    if (listen(sock, 5) == -1) &#123;</span><br><span class="line">        perror(&quot;Listen failed&quot;);</span><br><span class="line">        close(sock);</span><br><span class="line">        throw runtime_error(&quot;Listen failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Listening for connections...&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//接受连接请求</span><br><span class="line">void accept_user_connection(int sock) &#123;</span><br><span class="line">    c_addr_size = sizeof(c_addr);</span><br><span class="line">    //int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">    //服务器的套接字描述符,客户机结构体的指针，客户机结构体的长度</span><br><span class="line">    c_sock = accept(sock, (struct sockaddr*)&amp;c_addr, &amp;c_addr_size);</span><br><span class="line"></span><br><span class="line">    if (c_sock == -1) &#123;</span><br><span class="line">        perror(&quot;Accept failed&quot;);</span><br><span class="line">        close(sock);</span><br><span class="line">        throw runtime_error(&quot;Accept failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Connected user IP: &quot;</span><br><span class="line">         &lt;&lt; inet_ntoa(c_addr.sin_addr)</span><br><span class="line">         &lt;&lt; &quot; and port: &quot;</span><br><span class="line">         &lt;&lt; ntohs(c_addr.sin_port) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//发送消息</span><br><span class="line">void send_message() &#123;</span><br><span class="line">    //ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">    //客户机套节字描述符，待写入数据的缓冲区指针，数据的大小</span><br><span class="line">    if (write(c_sock, MSG.c_str(), MSG.size()) == -1) &#123;</span><br><span class="line">        perror(&quot;Send failed&quot;);</span><br><span class="line">        close(c_sock);</span><br><span class="line">        close(s_sock);</span><br><span class="line">        throw runtime_error(&quot;Send failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Message sent successfully.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//关闭套节字</span><br><span class="line">void close_sockets() &#123;</span><br><span class="line">    close(c_sock);</span><br><span class="line">    close(s_sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (argc != 2) &#123;</span><br><span class="line">            cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;port&gt;&quot; &lt;&lt; endl;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s_sock = create_server_socket();</span><br><span class="line">        bind_server_socket(s_sock, argv[1]);</span><br><span class="line">        start_listening(s_sock);</span><br><span class="line">        accept_user_connection(s_sock);</span><br><span class="line">        send_message();</span><br><span class="line">        close_sockets();</span><br><span class="line"></span><br><span class="line">    &#125; catch (const runtime_error&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;cerrno&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//客户机套节字</span><br><span class="line">int client_sock;</span><br><span class="line">//服务器地址</span><br><span class="line">struct sockaddr_in server_addr;</span><br><span class="line">//接受消息的数组</span><br><span class="line">vector&lt;char&gt; message;</span><br><span class="line">//串长度</span><br><span class="line">int str_len;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建客户端套字节，与服务端相同 </span><br><span class="line">int create_client_socket() &#123;</span><br><span class="line">    int sock = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (sock == -1) &#123;</span><br><span class="line">        perror(&quot;Socket creation failed&quot;);</span><br><span class="line">        throw runtime_error(&quot;Socket creation failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Client socket created successfully.&quot; &lt;&lt; endl;</span><br><span class="line">    return sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//连接服务段</span><br><span class="line">void connect_to_server(const string&amp; ip, const string&amp; port) &#123;</span><br><span class="line">    memset(&amp;server_addr, 0, sizeof(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    //int inet_pton(int af, const char *src, void *dst);</span><br><span class="line">    //地址族、ip地址字符串指针（点分十进制）、转换后的内存地址指针（存到哪里）</span><br><span class="line">    //1: 表示转换成功。0: 表示提供的地址字符串格式不正确（无效的地址）。-1: 表示函数调用失败</span><br><span class="line">    if (inet_pton(AF_INET, ip.c_str(), &amp;server_addr.sin_addr) &lt;= 0) &#123;</span><br><span class="line">        perror(&quot;Invalid address&quot;);</span><br><span class="line">        throw runtime_error(&quot;Invalid address&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server_addr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">    if (connect(client_sock, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) == -1) &#123;</span><br><span class="line">        perror(&quot;Connect failed&quot;);</span><br><span class="line">        throw runtime_error(&quot;Connect failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Connected successfully.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//接受消息</span><br><span class="line">void receive_message() &#123;</span><br><span class="line">    message.resize(1024);</span><br><span class="line"></span><br><span class="line">    //ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">    //message.size() - 1 指定了要读取的最大字节数</span><br><span class="line">    str_len = read(client_sock, message.data(), message.size() - 1);</span><br><span class="line"></span><br><span class="line">    if (str_len == -1) &#123;</span><br><span class="line">        perror(&quot;Read failed&quot;);</span><br><span class="line">        throw runtime_error(&quot;Read failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message[str_len] = &#x27;\0&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//关闭客户端套字节</span><br><span class="line">void close_socket() &#123;</span><br><span class="line">    close(client_sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (argc != 3) &#123;</span><br><span class="line">            cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;IP&gt; &lt;PORT&gt;&quot; &lt;&lt; endl;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        client_sock = create_client_socket();</span><br><span class="line">        connect_to_server(argv[1], argv[2]);</span><br><span class="line"></span><br><span class="line">        receive_message();</span><br><span class="line">        cout &lt;&lt; &quot;Message from server: &quot; &lt;&lt; message.data() &lt;&lt; endl;</span><br><span class="line">        close_socket();</span><br><span class="line"></span><br><span class="line">    &#125; catch (const runtime_error &amp;e) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="win版本"><a href="#win版本" class="headerlink" title="win版本"></a>win版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">win 编译需要链接ws2_32 库，所以命令是</span><br><span class="line">g++ -std=c++17 -o myprogram myprogram.cpp -lws2_32</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;winsock2.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">WSADATA wsaData;</span><br><span class="line"></span><br><span class="line">//s:server c:client</span><br><span class="line">SOCKET sSock, cSock;</span><br><span class="line"></span><br><span class="line">SOCKADDR_IN sAddr, cAddr;</span><br><span class="line"></span><br><span class="line">int cAddr_size;</span><br><span class="line"></span><br><span class="line">string message = &quot;Hello TCP/IP\n&quot;;</span><br><span class="line"></span><br><span class="line">void create_server_socket() &#123;</span><br><span class="line">	sSock = socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line">	if (sSock == INVALID_SOCKET) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;Server Socket Create failed&quot; &lt;&lt; endl;</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Server Socket is Create&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_ip_and_port(const string port) &#123;</span><br><span class="line">	memset(&amp;sAddr, 0, sizeof(sAddr));</span><br><span class="line"></span><br><span class="line">	sAddr.sin_family = PF_INET;</span><br><span class="line">	sAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	sAddr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">	if (bind(sSock, (SOCKADDR*)&amp;sAddr, sizeof(sAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;bind is failed&quot; &lt;&lt; endl;</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		cout &lt;&lt; &quot;bind is success , allow IP :&quot;</span><br><span class="line">			&lt;&lt; inet_ntoa(sAddr.sin_addr)</span><br><span class="line">			&lt;&lt; &quot;and port :&quot;</span><br><span class="line">			&lt;&lt; ntohs(sAddr.sin_port) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void listen_connect() &#123;</span><br><span class="line">	if (listen(sSock, 5) == SOCKET_ERROR) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;listen error&quot; &lt;&lt; endl;</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;listening connect ....&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void accept_client_connect() &#123;</span><br><span class="line">	cAddr_size = sizeof(cAddr);</span><br><span class="line">	cSock = accept(sSock, (SOCKADDR*)&amp;cAddr, &amp;cAddr_size);</span><br><span class="line"></span><br><span class="line">	if (cSock == INVALID_SOCKET) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;accept error&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;accept is success , client IP :&quot;</span><br><span class="line">			&lt;&lt; inet_ntoa(cAddr.sin_addr)</span><br><span class="line">			&lt;&lt; &quot;and port :&quot;</span><br><span class="line">			&lt;&lt; ntohs(cAddr.sin_port) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send_MSG() &#123;</span><br><span class="line">	send(cSock, message.c_str(), message.size(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void close_socket() &#123;</span><br><span class="line">	closesocket(cSock);</span><br><span class="line">	closesocket(sSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[]) &#123;</span><br><span class="line">	</span><br><span class="line">	if (argc != 2) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;Usage :&quot; &lt;&lt; argv[0] &lt;&lt; &quot;&lt;port&gt;&quot; &lt;&lt; endl;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	//比起linux多了一个启动和关闭WSA的步骤</span><br><span class="line">	if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;WSAStartup() error&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;WinSock Start!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	create_server_socket();</span><br><span class="line"></span><br><span class="line">	bind_ip_and_port(argv[1]);</span><br><span class="line"></span><br><span class="line">	listen_connect();</span><br><span class="line"></span><br><span class="line">	accept_client_connect();</span><br><span class="line"></span><br><span class="line">	send_MSG();</span><br><span class="line"></span><br><span class="line">	close_socket();</span><br><span class="line"></span><br><span class="line">	WSACleanup();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接受的和linux一样，就改个别语句即可</span><br></pre></td></tr></table></figure>

<h2 id="2、回声（UDP）"><a href="#2、回声（UDP）" class="headerlink" title="2、回声（UDP）"></a>2、回声（UDP）</h2><p>server端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int sSock; //UDP不需要cSock</span><br><span class="line"></span><br><span class="line">struct sockaddr_in sAddr,cAddr;</span><br><span class="line"></span><br><span class="line">void create_server_sock()&#123;</span><br><span class="line">    sSock = socket(PF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sSock == -1)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;server socket create failed&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;server socket is created&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_socket(const string&amp; port)&#123;</span><br><span class="line">    memset(&amp;sAddr , 0 , sizeof (sAddr));</span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    sAddr.sin_port = htons(stoi(port.c_str()));</span><br><span class="line">	if(bind(sSock,(struct sockaddr*)&amp;sAddr,sizeof(sAddr)) == -1)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;bind error&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;bind success&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_start()&#123;</span><br><span class="line">    string msg(1024,&#x27;\0&#x27;),msg_send;</span><br><span class="line">    socklen_t cAddr_sz;</span><br><span class="line">    int str_len = 0;</span><br><span class="line"></span><br><span class="line">    while(1)&#123;</span><br><span class="line">        cAddr_sz = sizeof(cAddr);</span><br><span class="line">        msg.clear();</span><br><span class="line">        msg.resize(1024);</span><br><span class="line">                recvfrom(sSock,</span><br><span class="line">                &amp;msg[0],//可写数组</span><br><span class="line">                1024,</span><br><span class="line">                0,</span><br><span class="line">                (struct sockaddr*)&amp;cAddr, </span><br><span class="line">                &amp;cAddr_sz);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;message from client: &quot; &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Insert message (q to quite) :&quot; &lt;&lt; endl;</span><br><span class="line">        getline(cin,msg_send);</span><br><span class="line">        if(msg_send == &quot;q&quot;) break;</span><br><span class="line">        sendto(sSock,</span><br><span class="line">               msg_send.c_str(),</span><br><span class="line">               msg_send.size(),</span><br><span class="line">               0,</span><br><span class="line">               (struct sockaddr*)&amp;cAddr, </span><br><span class="line">               cAddr_sz);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void close_socket()&#123;</span><br><span class="line">    close(sSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])&#123;</span><br><span class="line">    if(argc != 2)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;port&gt; &quot; &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    create_server_sock();</span><br><span class="line">    bind_socket(argv[1]);</span><br><span class="line">    </span><br><span class="line">    server_start();</span><br><span class="line">    close_socket();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>client端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int cScok;</span><br><span class="line">struct sockaddr_in sAddr , cAddr;</span><br><span class="line"></span><br><span class="line">void create_client_sock()&#123;</span><br><span class="line">    cScok = socket(PF_INET , SOCK_DGRAM , 0);</span><br><span class="line">    if(cScok == -1)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;cScok error &quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;client socket is create&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_server(const string&amp; ip , const string &amp; port)&#123;</span><br><span class="line">    memset(&amp;sAddr , 0 , sizeof (sAddr));</span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">    sAddr.sin_port = htons(stoi(port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void connect_server()&#123;</span><br><span class="line">    string msg,msg_recv(1024,&#x27;\0&#x27;);</span><br><span class="line">    socklen_t sAddr_sz = sizeof(sAddr);</span><br><span class="line">    int str_len;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while(1)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Insert message (q to quit): &quot;;</span><br><span class="line">        getline(cin,msg);</span><br><span class="line">        if(msg == &quot;q&quot; || msg == &quot;Q&quot;) break;</span><br><span class="line"></span><br><span class="line">        sendto(cScok , msg.c_str() , msg.size() , 0 , (struct sockaddr*)&amp;sAddr,sAddr_sz);</span><br><span class="line">        </span><br><span class="line">        msg_recv.clear();</span><br><span class="line">        msg_recv.resize(1024);</span><br><span class="line"></span><br><span class="line">        str_len = recvfrom(cScok , &amp;msg_recv[0] , msg_recv.size() , 0 , (struct sockaddr*)&amp;sAddr,&amp;sAddr_sz);</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; &quot;message from server :&quot; &lt;&lt; msg_recv &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void close_socket()&#123;</span><br><span class="line">    close(cScok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc , char *argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    if(argc != 3)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Usage : &quot; &lt;&lt; argv[0] &lt;&lt; &quot;&lt;ip&gt; &lt;port&gt;&quot; &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    create_client_sock();</span><br><span class="line">    init_server(argv[1],argv[2]);</span><br><span class="line"></span><br><span class="line">    connect_server();</span><br><span class="line">    close_socket();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据边界</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP：无数据边界，一次write对应多次调用read（recv）来接受同一个数据包</span><br><span class="line">UDP：有数据边界，一次send对应一次recv，一次接受一个数据包，一般缓冲区大小为64KB，比TPC大很多</span><br><span class="line">不过如果数据包过大，udp也会进行分割数据包</span><br></pre></td></tr></table></figure>

<p>已连接UDP套接字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以使用connect让UDP套接字变成已连接套接字</span><br><span class="line">这样不仅可以用sendto和recvfrom，还可以使用write和read</span><br></pre></td></tr></table></figure>

<h2 id="3、DNS解析"><a href="#3、DNS解析" class="headerlink" title="3、DNS解析"></a>3、DNS解析</h2><p>正向解析（域名 -&gt; ip）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct hostent *host;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    if(argc != 2)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Usage :&quot; &lt;&lt; argv[0] &lt;&lt; &quot;&lt;ip addr&gt;&quot; &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    host = gethostbyname(argv[1]);</span><br><span class="line"></span><br><span class="line">    if(!host) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;get host error&quot; &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Official name :&quot; &lt;&lt; host-&gt;h_name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Address type : &quot; &lt;&lt; (host-&gt;h_addrtype == AF_INET ? &quot;IPV4&quot; : &quot;IPV6&quot;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    char **aliases = host-&gt;h_aliases;</span><br><span class="line"></span><br><span class="line">    for(int i = 0 ; aliases[i] ; i ++)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Aliases : &quot; &lt;&lt; aliases[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char **ipaddr = host-&gt;h_addr_list;</span><br><span class="line"></span><br><span class="line">    for(int i = 0 ; ipaddr[i] ; i ++)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;IP Address : &quot; &lt;&lt; inet_ntoa(*(struct in_addr*)ipaddr[i]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反向解析（ip -&gt; 域名）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;ip address&gt;&quot; &lt;&lt; endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = 0;</span><br><span class="line">    inet_pton(AF_INET, argv[1], &amp;addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    struct addrinfo hints, *res, *p;</span><br><span class="line">    memset(&amp;hints, 0, sizeof hints);</span><br><span class="line">    hints.ai_family = AF_INET; // IPv4</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">    int status;</span><br><span class="line">    if ((status = getaddrinfo(argv[1], NULL, &amp;hints, &amp;res)) != 0) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;getaddrinfo error: &quot; &lt;&lt; gai_strerror(status) &lt;&lt; endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (p = res; p != NULL; p = p-&gt;ai_next) &#123;</span><br><span class="line">        char host[NI_MAXHOST];</span><br><span class="line">        int ret = getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, host, sizeof host, NULL, 0, NI_NAMEREQD);</span><br><span class="line">        if (ret != 0) &#123;</span><br><span class="line">            cerr &lt;&lt; &quot;getnameinfo error: &quot; &lt;&lt; gai_strerror(ret) &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Official name: &quot; &lt;&lt; host &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char ipstr[INET_ADDRSTRLEN];</span><br><span class="line">    for (p = res; p != NULL; p = p-&gt;ai_next) &#123;</span><br><span class="line">        void *addr;</span><br><span class="line">        struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-&gt;ai_addr;</span><br><span class="line">        addr = &amp;(ipv4-&gt;sin_addr);</span><br><span class="line"></span><br><span class="line">        inet_ntop(p-&gt;ai_family, addr, ipstr, sizeof ipstr);</span><br><span class="line">        cout &lt;&lt; &quot;IP Address: &quot; &lt;&lt; ipstr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(res);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、并发服务器-多线程-I-O-分割"><a href="#4、并发服务器-多线程-I-O-分割" class="headerlink" title="4、并发服务器(多线程 + I &#x2F;O 分割)"></a>4、并发服务器(多线程 + I &#x2F;O 分割)</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>fork</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int val1 = 10;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    int val2 = 20;</span><br><span class="line"></span><br><span class="line">    val1++,val2 += 5;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;全局变量val1 : &quot; &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;局部变量val2 : &quot; &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    if(pid == 0)&#123; // 如果是子进程</span><br><span class="line">        cout &lt;&lt; &quot;全局变量val1 : &quot; &lt;&lt; val1 &lt;&lt; endl;                                                                                                                                     </span><br><span class="line">        cout &lt;&lt; &quot;局部变量val2 : &quot; &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">        val1 += 2;</span><br><span class="line">        val2 += 2;</span><br><span class="line">        cout &lt;&lt; &quot;val1 += 2 , val2 += 2&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;else&#123;//否则是父进程</span><br><span class="line">        cout &lt;&lt; &quot;全局变量val1 : &quot; &lt;&lt; val1 &lt;&lt; endl;                                                                                                                                     </span><br><span class="line">        cout &lt;&lt; &quot;局部变量val2 : &quot; &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">        val1 -= 2;</span><br><span class="line">        val2 -= 2;</span><br><span class="line">        cout &lt;&lt; &quot;val1 -= 2 , val2 -= 2&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(pid == 0)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;This is Child Proc: &quot; &lt;&lt; val1 &lt;&lt; &quot;,&quot; &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout &lt;&lt; &quot;This is Father Proc&quot; &lt;&lt; val1 &lt;&lt; &quot;,&quot; &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个程序中不难看出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在调用fork（）函数之后，子进程获得了和父进程一模一样的内存空间，并且互相独立，修改变量不会影响对方</span><br></pre></td></tr></table></figure>

<h4 id="zombie进程"><a href="#zombie进程" class="headerlink" title="zombie进程"></a>zombie进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/alexqfmm/Codes/multithreading# cat zombie.cpp                            │alexqfmm@ubuntu:~/Codes$ ps au|grep 5036</span><br><span class="line">#include&lt;iostream&gt;                                                                         │alexqfmm    5036  0.0  0.0      0   </span><br><span class="line">#include&lt;unistd.h&gt;                                                                         │alexqfmm    5038  0.0  0.0  12000   </span><br><span class="line">                                                                                           │alexqfmm@ubuntu:~/Codes$ </span><br><span class="line">using namespace std;                                                                       │</span><br><span class="line">                                                                                           │</span><br><span class="line">int main()&#123;                                                                                │</span><br><span class="line">    pid_t pid = fork();                                                                    │</span><br><span class="line">                                                                                           │</span><br><span class="line">    if(pid == 0)&#123;                                                                          │</span><br><span class="line">        puts(&quot;Hi , I&#x27;m Zombie Process!&quot;);                                                  │</span><br><span class="line">    &#125;else&#123;                                                                                 │</span><br><span class="line">        cout &lt;&lt; &quot;Child Process ID : &quot; &lt;&lt; pid &lt;&lt; endl;                                      │</span><br><span class="line">        sleep(30);                                                                         │</span><br><span class="line">    &#125;                                                                                      │</span><br><span class="line">                                                                                           │</span><br><span class="line">    if(pid == 0)&#123;                                                                          │</span><br><span class="line">        puts(&quot;Child Process is Close&quot;);                                                    │</span><br><span class="line">    &#125;else&#123;                                                                                 │</span><br><span class="line">        puts(&quot;Father Process is close&quot;);                                                   │</span><br><span class="line">    &#125;                                                                                      │</span><br><span class="line">                                                                                           │</span><br><span class="line">    return 0;                                                                              │</span><br><span class="line">&#125;                                                                                          │</span><br></pre></td></tr></table></figure>

<h4 id="使用waitpid防止僵尸进程"><a href="#使用waitpid防止僵尸进程" class="headerlink" title="使用waitpid防止僵尸进程"></a>使用waitpid防止僵尸进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int st;</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">    if(pid == 0)&#123;</span><br><span class="line">        sleep(15);</span><br><span class="line">        return 24;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //WNOHANG 是一个选项，可以作为 waitpid() 的第三个参数传递。它的作用是让 waitpid() 非阻塞地检查子进程的状态</span><br><span class="line">        //Wait No Hang</span><br><span class="line">        while(!waitpid(-1,&amp;st,WNOHANG))&#123;</span><br><span class="line">            sleep(3);</span><br><span class="line">            puts(&quot;sleep 3sec&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //WIFEXITED(status) 是一个宏，用于判断子进程是否正常退出</span><br><span class="line">        //Wait If Exited</span><br><span class="line">        if(WIFEXITED(st))&#123;</span><br><span class="line">            //WEXITSTATUS(status) 用于获取子进程的退出状态，即返回的退出码</span><br><span class="line">            //Wait Exit Status</span><br><span class="line">            cout &lt;&lt; &quot;Child send : &quot; &lt;&lt; WEXITSTATUS(st) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct sigaction SIG;</span><br><span class="line"></span><br><span class="line">void timeout(int sig)&#123;</span><br><span class="line">    if(sig == SIGALRM) puts(&quot;Time Out！&quot;);</span><br><span class="line">    alarm(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_sig( SIG *sig, void (*fun)(int), int type)&#123;</span><br><span class="line">    sig-&gt;sa_handler = fun;		//将timeout绑定到act上</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sig-&gt;sa_mask);	// 清空信号屏蔽字</span><br><span class="line">    </span><br><span class="line">    sig-&gt;sa_flags = 0;			// 设置信号处理标志</span><br><span class="line">    </span><br><span class="line">    sigaction(type , sig , 0);	// 使用sigaction设置SIGALRM信号的处理函数</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    struct sigaction act;</span><br><span class="line">    </span><br><span class="line">    bind_sig(&amp;act , timeout , SIGALRM);</span><br><span class="line"></span><br><span class="line">    alarm(2);</span><br><span class="line"></span><br><span class="line">    for(int i = 0 ; i &lt; 3 ; i ++)&#123;</span><br><span class="line">        puts(&quot;wait..&quot;);</span><br><span class="line">        sleep(30);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​                                                                </p>
<table>
<thead>
<tr>
<th>信号</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SIGALRM</td>
<td>定时器到期信号</td>
<td>由 alarm() 或 setitimer() 设置的定时器到期时发送。通常用于定时任务。</td>
</tr>
<tr>
<td>SIGINT</td>
<td>中断信号</td>
<td>通常由 CTRL + C 触发。默认情况下，SIGINT 会终止进程。</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>终止信号</td>
<td>请求进程终止。可以被捕获、阻塞或忽略。通常用于优雅地终止进程。</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>强制终止信号</td>
<td>强制终止进程，不能被捕获、阻塞或忽略。用于立即停止进程。</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>暂停信号</td>
<td>暂停进程的执行，不能被捕获、阻塞或忽略。通常用于调试工具（如 gdb）中。</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>继续信号</td>
<td>恢复被 SIGSTOP 暂停的进程。</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>退出信号</td>
<td>类似于 SIGINT，但同时会产生核心转储（core dump），用于调试。</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>段错误信号</td>
<td>进程试图访问无效的内存地址时发送。通常是程序的错误。</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>管道破裂信号</td>
<td>进程试图向已经关闭的管道写数据时发送。</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>子进程状态变化信号</td>
<td>子进程终止或停止时，父进程会收到这个信号。常用于处理僵尸进程。</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>用户自定义信号（1）</td>
<td>可供用户自定义用途。</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>用户自定义信号（2）</td>
<td>可供用户自定义用途</td>
</tr>
</tbody></table>
<h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct sigaction act;//信号</span><br><span class="line"></span><br><span class="line">void listen_childproc(int sig)&#123;//信号处理</span><br><span class="line">    int st;</span><br><span class="line">    pid_t id = waitpid(-1,&amp;st,WNOHANG);</span><br><span class="line">    if(WIFEXITED(st))&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Remove proc id : &quot; &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Child send :&quot; &lt;&lt; WEXITSTATUS(st) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_signal()&#123;//绑定信号</span><br><span class="line">    </span><br><span class="line">    act.sa_handler = listen_childproc;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    </span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line">    </span><br><span class="line">    sigaction(SIGCHLD, &amp;act , 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    bind_signal();</span><br><span class="line">    </span><br><span class="line">    pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">    if(pid == 0)&#123;</span><br><span class="line"></span><br><span class="line">        puts(&quot;Hello , I‘m Zombie&quot;);</span><br><span class="line">        sleep(15);</span><br><span class="line">        exit(24);</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; &quot;Child Proc id : &quot; &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line">        pid = fork();//创建新的子进程</span><br><span class="line">        </span><br><span class="line">        if(pid == 0)&#123;</span><br><span class="line">        </span><br><span class="line">            puts(&quot;HI,I&#x27;m Zombie2&quot;);</span><br><span class="line">            sleep(10);</span><br><span class="line">            exit(12);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;Child Proc id : &quot; &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line">            for(int i = 0 ; i &lt; 5 ; i ++)&#123;</span><br><span class="line">                puts(&quot;wait...&quot;);</span><br><span class="line">                sleep(5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="何为I-O分割："><a href="#何为I-O分割：" class="headerlink" title="何为I&#x2F;O分割："></a>何为I&#x2F;O分割：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">客户端 I/O 分割：</span><br><span class="line"></span><br><span class="line">子进程负责发送数据。</span><br><span class="line">父进程负责接收数据。</span><br><span class="line">服务器端 I/O 分割：</span><br><span class="line"></span><br><span class="line">每个客户端连接创建一个子进程，子进程负责处理该客户端的所有读写操作。</span><br><span class="line">父进程继续接收新的客户端连接。</span><br><span class="line">优点</span><br><span class="line">提高并发处理能力：通过分离读写操作或每个客户端连接的处理，系统可以更有效地管理多个并发连接。</span><br><span class="line">简化代码逻辑：将发送和接收操作分开，使代码更清晰，易于维护。</span><br><span class="line">注意事项</span><br><span class="line">进程间通信：在客户端和服务器端之间，需要确保数据的一致性和同步。</span><br><span class="line">资源管理：正确关闭不再使用的文件描述符和套接字，避免资源泄漏。</span><br><span class="line">错误处理：要处理可能出现的各种错误情况，如 fork 失败、读写错误等。</span><br><span class="line">I/O 分割是一种有效的并发处理策略，适用于高负载的应用场景，无论是客户端还是服务器端都可以从中受益。</span><br></pre></td></tr></table></figure>

<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	//fds1[0] 是 fds1 的读端，fds1[1] 是 fds1 的写端</span><br><span class="line">    int fds1[2] , fds2[2];</span><br><span class="line">    pipe(fds1);</span><br><span class="line">    pipe(fds2);</span><br><span class="line"></span><br><span class="line">    string msg1 = &quot;Who are you?&quot;;		// 从子进程发送给父进程的消息</span><br><span class="line">    string msg2 = &quot;I&#x27;m your Father&quot;;	// 从父进程发送给子进程的消息</span><br><span class="line">    string tmp(1024,&#x27;\0&#x27;);				// 用于存储从管道读取的数据</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">    if(pid == 0)&#123;</span><br><span class="line">        write(fds1[1],msg1.c_str(),msg1.size());</span><br><span class="line">        read(fds2[0],&amp;tmp[0],1024);</span><br><span class="line">        cout &lt;&lt; &quot;Child Proc output: &quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        read(fds1[0],&amp;tmp[0],1024);                                                                                                                                                 </span><br><span class="line">        cout &lt;&lt; &quot;Parent Proc output: &quot; &lt;&lt; tmp &lt;&lt; endl; </span><br><span class="line">        write(fds2[1],msg2.c_str(),msg2.size());</span><br><span class="line">        sleep(3);	// 确保子进程有时间读取数据</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用管道在服务端添加日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">在进入连接前：</span><br><span class="line">if(pid == 0)&#123;//记录传输日志</span><br><span class="line">        ofstream file(&quot;log.txt&quot;,ios::app);</span><br><span class="line">        int str_len;</span><br><span class="line">        char msg[1024];</span><br><span class="line">        </span><br><span class="line">        if(file.is_open())&#123;</span><br><span class="line"></span><br><span class="line">            while((str_len = read(fds[0], msg ,sizeof(msg))) &gt; 0)&#123;</span><br><span class="line">                cout &lt;&lt; &quot; log is add &quot; &lt;&lt; msg &lt;&lt; endl; </span><br><span class="line">                file.write(msg , str_len);</span><br><span class="line">                file &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file.close();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">连接后进行传输</span><br><span class="line">void work()&#123;</span><br><span class="line">    close(sSock);//关闭子进程中的服务器监听，此时父进程的服务器监听依旧在执行，对于子进程而言，这个已经没有用了</span><br><span class="line">    int str_len;</span><br><span class="line">    while((str_len = read(cSock , buffer , BUFFERSIZE)) != 0)&#123;</span><br><span class="line">        write(cSock , buffer , str_len);</span><br><span class="line">        write(fds[1], buffer , str_len);//添加管道传输</span><br><span class="line">    &#125;</span><br><span class="line">    close(cSock);</span><br><span class="line">    puts(&quot;client disconnect&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>server端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt; // 用于创建目录</span><br><span class="line"></span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">#define BUFFERSIZE 1024</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct sigaction SIG;</span><br><span class="line"></span><br><span class="line">int sSock, cSock;</span><br><span class="line">struct sockaddr_in sAddr, cAddr;</span><br><span class="line">socklen_t adr_sz;</span><br><span class="line">char buffer[BUFFERSIZE];</span><br><span class="line">int fds[2];</span><br><span class="line"></span><br><span class="line">void listen_child(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t id;</span><br><span class="line">    int st;</span><br><span class="line">    id = waitpid(-1, &amp;st, WNOHANG);</span><br><span class="line">    cout &lt;&lt; &quot;removed child , Porc : &quot; &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_sig(SIG *sig, void (*fun)(int), int type)</span><br><span class="line">&#123;</span><br><span class="line">    sig-&gt;sa_handler = fun;</span><br><span class="line">    sigemptyset(&amp;sig-&gt;sa_mask);</span><br><span class="line">    sig-&gt;sa_flags = 0;</span><br><span class="line">    sigaction(type, sig, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void create_server_socket()</span><br><span class="line">&#123;</span><br><span class="line">    sSock = socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (sSock == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;server socket create failed&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;server socket is create&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_port(const string &amp;port)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    memset(&amp;sAddr, 0, sizeof(sAddr));</span><br><span class="line"></span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    sAddr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">    if (bind(sSock, (struct sockaddr *)&amp;sAddr, sizeof(sAddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;bind error&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot; success bind &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void start_listen()</span><br><span class="line">&#123;</span><br><span class="line">    if (listen(sSock, 5) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;listen error&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;listening......&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool connect_client()</span><br><span class="line">&#123;</span><br><span class="line">    adr_sz = sizeof(cAddr);</span><br><span class="line"></span><br><span class="line">    cSock = accept(sSock, (struct sockaddr *)&amp;cAddr, &amp;adr_sz);</span><br><span class="line"></span><br><span class="line">    return cSock != -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_log(const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">    mkdir(&quot;log&quot;, 0755);</span><br><span class="line"></span><br><span class="line">    string filename = &quot;log/server_log.txt&quot;;</span><br><span class="line">    ofstream file(filename, ios::app);</span><br><span class="line"></span><br><span class="line">    if (!file.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Failed to open log file&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time_t now = time(0);</span><br><span class="line">    char *dt = ctime(&amp;now);</span><br><span class="line">    dt[strlen(dt) - 1] = &#x27;\0&#x27;;</span><br><span class="line">    file &lt;&lt; &quot;[ &quot; &lt;&lt; dt &lt;&lt; &quot; ] : &quot; &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void log_handler()</span><br><span class="line">&#123;</span><br><span class="line">    int str_len;</span><br><span class="line">    char msg[1024];</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        str_len = read(fds[0], msg, sizeof(msg));</span><br><span class="line">        if (str_len &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            msg[str_len] = &#x27;\0&#x27;; // 确保字符串结束</span><br><span class="line">            write_log(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (str_len == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break; // 管道关闭</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; &quot;Error reading from pipe&quot; &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">    close(sSock);//子进程不需要父进程部分</span><br><span class="line">    int str_len;</span><br><span class="line">    char buffer[BUFFERSIZE];</span><br><span class="line"></span><br><span class="line">    while ((str_len = read(cSock, buffer, BUFFERSIZE)) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        write(cSock, buffer, str_len);  // 回传给客户端</span><br><span class="line">        write(fds[1], buffer, str_len); // 写入日志管道</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cSock);//传输完毕，可以关闭子进程了</span><br><span class="line">    puts(&quot;client disconnect&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_start()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建管道</span><br><span class="line">    if (pipe(fds) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Failed to create pipe&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid_t log_pid = fork(); // 创建日志进程</span><br><span class="line">    if (log_pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[1]); // 不需要写端，关闭写端</span><br><span class="line">        log_handler(); // 启动日志处理(服务器日志)</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (log_pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Failed to fork log process&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        if (connect_client())</span><br><span class="line">        &#123;</span><br><span class="line">            puts(&quot;A new Client is connect&quot;);</span><br><span class="line">            pid_t work_pid = fork(); // 处理并发</span><br><span class="line"></span><br><span class="line">            if (work_pid == -1)</span><br><span class="line">            &#123;</span><br><span class="line">                cerr &lt;&lt; &quot;Failed to fork work process&quot; &lt;&lt; endl;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (work_pid == 0) // 子进程处理客户端工作</span><br><span class="line">            &#123;</span><br><span class="line">                work();</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                close(cSock); // 父进程专门监听</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; &quot;Failed to connect client&quot; &lt;&lt; endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (argc != 2)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;port&gt; &quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SIG child_is_live;</span><br><span class="line">    bind_sig(&amp;child_is_live, listen_child, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    create_server_socket();</span><br><span class="line"></span><br><span class="line">    bind_port(argv[1]);</span><br><span class="line"></span><br><span class="line">    start_listen();</span><br><span class="line"></span><br><span class="line">    server_start();</span><br><span class="line"></span><br><span class="line">    close(sSock);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in sAddr , cAddr;</span><br><span class="line">int cSock;</span><br><span class="line">socklen_t adr_sz;</span><br><span class="line"></span><br><span class="line">void create_client_socket()&#123;</span><br><span class="line">    cSock = socket(PF_INET , SOCK_STREAM , 0);</span><br><span class="line">    if(cSock == -1)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;client socket create failed&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;client socket is create&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_sAddr(const string&amp; ip , const string&amp; port)&#123;</span><br><span class="line">    memset(&amp;sAddr , 0 , sizeof (sAddr));</span><br><span class="line"></span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">    sAddr.sin_port = htons(stoi(port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void connect_server()&#123;</span><br><span class="line">    if(connect(cSock , (struct sockaddr *)&amp;sAddr , sizeof(sAddr)) == -1)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;connect error&quot; &lt;&lt;endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;connect success&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_msg()&#123;</span><br><span class="line">    int str_len = 0;                                                                                                                                           </span><br><span class="line">    string msg;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Insert Message(q to quite) : &quot;;</span><br><span class="line">        cout.flush();</span><br><span class="line">        char buffer[1024];</span><br><span class="line">        getline(cin,msg);</span><br><span class="line">        if(msg == &quot;q&quot;)&#123;</span><br><span class="line">            shutdown(cSock , SHUT_WR);</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line">        write(cSock , msg.c_str() , msg.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read_msg()&#123;</span><br><span class="line">    int str_len = 0;</span><br><span class="line">    char buffer[1024];</span><br><span class="line"></span><br><span class="line">    while(1)&#123;</span><br><span class="line">        str_len = read(cSock , buffer , sizeof(buffer) - 1);</span><br><span class="line">        </span><br><span class="line">        if(str_len == 0)&#123;</span><br><span class="line">            cout &lt;&lt; &quot;Server is closed &quot; &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(str_len &lt; 0)&#123;</span><br><span class="line">            cerr &lt;&lt; &quot;read error&quot; &lt;&lt; endl;</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        buffer[str_len] = &#x27;\0&#x27;;</span><br><span class="line">        cout &lt;&lt; &quot;Message from Server :&quot;  &lt;&lt; buffer &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc ,char * argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    if(argc != 3)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Usage : &quot; &lt;&lt; argv[0] &lt;&lt; &quot;&lt;IP Address&gt; &lt;Port&gt;&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    create_client_socket();</span><br><span class="line">    init_sAddr(argv[1],argv[2]);</span><br><span class="line">    connect_server();</span><br><span class="line">    </span><br><span class="line">    pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">    //I/O分割提高效率</span><br><span class="line">    if(pid == 0)&#123;//子进程写</span><br><span class="line">        write_msg();</span><br><span class="line">    &#125;else&#123;//父进程读</span><br><span class="line">        read_msg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(cSock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、并发服务器（多线程-I-O复用）"><a href="#5、并发服务器（多线程-I-O复用）" class="headerlink" title="5、并发服务器（多线程+ I &#x2F;O复用）"></a>5、并发服务器（多线程+ I &#x2F;O复用）</h2><h3 id="何为IO复用？"><a href="#何为IO复用？" class="headerlink" title="何为IO复用？"></a>何为IO复用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器必须确认有无举手客户端，同样，进程需要确认举手的套接字，并通过举手的套接字接受数据</span><br></pre></td></tr></table></figure>

<h3 id="Select监视事件（event）"><a href="#Select监视事件（event）" class="headerlink" title="Select监视事件（event）"></a>Select监视事件（event）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    fd_set reads, tmps; // 定义文件描述符集合</span><br><span class="line">    int res, str_len; // res用于存储select的返回值，str_len用于读取的数据长度</span><br><span class="line"></span><br><span class="line">    char buf[1024]; // 缓存区，存储读取的数据</span><br><span class="line">    struct timeval timeout; // 定义超时时间</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads); // 初始化文件描述符集合</span><br><span class="line">    FD_SET(0, &amp;reads); // 将标准输入（文件描述符0）添加到集合中</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        tmps = reads; // 每次循环重置tmps为reads</span><br><span class="line">        timeout.tv_sec = 5; // 设置超时时间为5秒</span><br><span class="line">        timeout.tv_usec = 0; // 微秒部分为0</span><br><span class="line"></span><br><span class="line">        // 调用select函数，监视文件描述符</span><br><span class="line">        res = select(1, &amp;tmps, 0, 0, &amp;timeout);</span><br><span class="line"></span><br><span class="line">        if (res == -1) &#123;</span><br><span class="line">            puts(&quot;select error&quot;); // 处理select调用的错误</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (res == 0) &#123;</span><br><span class="line">            puts(&quot;Time Out !&quot;); // 超时处理</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (FD_ISSET(0, &amp;tmps)) &#123; // 检查标准输入是否可读</span><br><span class="line">                str_len = read(0, buf, 1024); </span><br><span class="line">                buf[str_len] = &#x27;\0&#x27;; </span><br><span class="line">                puts(&quot;message from console :&quot;);</span><br><span class="line">                cout &lt;&lt; buf &lt;&lt; endl; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nfds: 最大的文件描述符值加1。在该值之下的所有文件描述符都将被监视。</span><br><span class="line">readfds: 指向一个文件描述符集合的指针，表示要监视的可读文件描述符。</span><br><span class="line">writefds: 指向一个文件描述符集合的指针，表示要监视的可写文件描述符。</span><br><span class="line">exceptfds: 指向一个文件描述符集合的指针，表示要监视的异常条件的文件描述符。</span><br><span class="line">timeout: 指向 timeval 结构的指针，表示最大等待时间。如果为 NULL，select 将一直等待，直到有事件发生。</span><br></pre></td></tr></table></figure>

<p>使用步骤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化文件描述符集合: </span><br><span class="line">	使用 FD_ZERO 初始化集合，使用 FD_SET 将文件描述符添加到集合中。</span><br><span class="line">调用 select: </span><br><span class="line">	将文件描述符集合和超时参数传递给 select。</span><br><span class="line"></span><br><span class="line">检查返回值:</span><br><span class="line">	返回 -1: 表示出现错误。</span><br><span class="line">	返回 0: 表示超时。</span><br><span class="line">	返回大于0: 表示有可读、可写或异常事件发生。</span><br><span class="line">	使用 FD_ISSET 检查具体的文件描述符: 使用 FD_ISSET 来检查哪个文件描述符发生了事件。</span><br></pre></td></tr></table></figure>

<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int sSock,cSock;</span><br><span class="line">struct sockaddr_in sAddr , cAddr;</span><br><span class="line">socklen_t addr_sz;</span><br><span class="line"></span><br><span class="line">struct timeval timeout;</span><br><span class="line">fd_set reads, reads_bck;</span><br><span class="line">int fd_max , fd_num;</span><br><span class="line"></span><br><span class="line">void create_server_socket()&#123;</span><br><span class="line">    sSock = socket(PF_INET , SOCK_STREAM , 0);</span><br><span class="line">    if(sSock == -1)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;server socket create is faild&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;server socket is create&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bind_port(const string&amp; port)&#123;</span><br><span class="line">    </span><br><span class="line">    memset(&amp;sAddr , 0 , sizeof(sAddr));</span><br><span class="line"></span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    sAddr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">    if(bind(sSock , (const sockaddr*)&amp;sAddr , sizeof(sAddr)) == -1)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;bind error&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;success bind port&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void start_listen()&#123;</span><br><span class="line">    if(listen(sSock , 5) == -1)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;listen error&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;start listen.......&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void connect_client()&#123;</span><br><span class="line">    addr_sz = sizeof(cAddr);</span><br><span class="line">    cSock = accept(sSock , (struct sockaddr*)&amp;cAddr , &amp;addr_sz);</span><br><span class="line"></span><br><span class="line">    FD_SET(cSock , &amp;reads); //将套接字 cSock 添加到一个文件描述符集合 reads 中</span><br><span class="line">    fd_max = max(fd_max,cSock);//fd_max 必须时刻是最大的</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;connect client : &quot; &lt;&lt; cSock &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work(int client_sock)&#123;</span><br><span class="line">    char buffer[1024];</span><br><span class="line">    int len = read(client_sock ,buffer , sizeof(buffer) - 1);</span><br><span class="line">    </span><br><span class="line">    if(len == 0)&#123;</span><br><span class="line">        FD_CLR(client_sock,&amp;reads);//客户端断开连接，移除集合中的它的套节字</span><br><span class="line">        close(client_sock);</span><br><span class="line">        cout &lt;&lt; &quot;closed Client : &quot; &lt;&lt; client_sock &lt;&lt; endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        buffer[len] = &#x27;\0&#x27;;</span><br><span class="line">        write(client_sock , buffer , len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_start()&#123;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads);//初始化文件描述集合 reads，全部置为0</span><br><span class="line">    FD_SET(sSock , &amp;reads);//将套接字 sSock 添加到一个文件描述符集合 reads 中</span><br><span class="line"></span><br><span class="line">    fd_max = sSock;//fd_max代表所有小于他的都将被监视</span><br><span class="line"></span><br><span class="line">    while(1)&#123;</span><br><span class="line">        reads_bck = reads;</span><br><span class="line">        timeout.tv_sec = 5;</span><br><span class="line">        timeout.tv_usec = 5000;</span><br><span class="line"></span><br><span class="line">        fd_num = select(fd_max + 1 , &amp;reads_bck , 0 , 0 , &amp;timeout);</span><br><span class="line">        </span><br><span class="line">        if(fd_num == -1) break;</span><br><span class="line">        if(fd_num ==  0) continue;</span><br><span class="line"></span><br><span class="line">        for(int i = 0 ; i &lt; fd_max + 1 ; i ++)&#123;//边历所有被监视的套节字</span><br><span class="line">            //这里检查文件描述符 i 是否在文件描述符集合 reads_bck 中，如果存在，意味着该文件描述符有活动（如可读事件）</span><br><span class="line">            if(FD_ISSET(i , &amp;reads_bck))&#123;</span><br><span class="line"></span><br><span class="line">                if(i == sSock)&#123;</span><br><span class="line">                    connect_client();</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    work(i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char * argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    if(argc != 2)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Usage : &quot; &lt;&lt; argv[0] &lt;&lt; &quot;&lt;port&gt;&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    create_server_socket();</span><br><span class="line">    bind_port(argv[1]);</span><br><span class="line">    start_listen();</span><br><span class="line">    server_start();</span><br><span class="line">    close(sSock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多样IO函数"><a href="#多样IO函数" class="headerlink" title="多样IO函数"></a>多样IO函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>主要用途</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>read</code></td>
<td>读取文件或套接字中的数据</td>
<td>通用、简单、适用于文件或网络I&#x2F;O</td>
<td>不专门为网络设计，缺少额外选项</td>
<td>通用I&#x2F;O操作，文件和套接字都可以使用</td>
</tr>
<tr>
<td><code>write</code></td>
<td>向文件或套接字写入数据</td>
<td>通用、简单、适用于文件或网络I&#x2F;O</td>
<td>不专门为网络设计，缺少额外选项</td>
<td>通用I&#x2F;O操作，文件和套接字都可以使用</td>
</tr>
<tr>
<td><code>send</code></td>
<td>发送数据到套接字</td>
<td>网络优化、提供控制标志位</td>
<td>只能用于套接字</td>
<td>网络编程，尤其需要精细控制发送行为时</td>
</tr>
<tr>
<td><code>recv</code></td>
<td>从套接字接收数据</td>
<td>网络优化、提供控制标志位</td>
<td>只能用于套接字</td>
<td>网络编程，尤其需要精细控制接收行为时</td>
</tr>
<tr>
<td><code>readv</code></td>
<td>从套接字或文件分散读取数据</td>
<td>提高效率、减少系统调用、减少内存拷贝</td>
<td>使用多个缓冲区增加代码复杂度</td>
<td>需要读取分散数据，且希望优化性能的场景</td>
</tr>
<tr>
<td><code>writev</code></td>
<td>向套接字或文件聚集写入数据</td>
<td>提高效率、减少系统调用、减少内存拷贝</td>
<td>使用多个缓冲区增加代码复杂度</td>
<td>需要写入多个数据块，且希望优化性能的场景</td>
</tr>
</tbody></table>
<h2 id="MSG-OOB与TCP紧急模式"><a href="#MSG-OOB与TCP紧急模式" class="headerlink" title="MSG_OOB与TCP紧急模式"></a>MSG_OOB与TCP紧急模式</h2><h3 id="1-MSG-OOB-Out-of-Band-Data"><a href="#1-MSG-OOB-Out-of-Band-Data" class="headerlink" title="1. MSG_OOB (Out-of-Band Data)"></a>1. <strong>MSG_OOB (Out-of-Band Data)</strong></h3><ul>
<li><p><strong>概念</strong>：</p>
<ul>
<li><code>MSG_OOB</code> 是用于 <code>send()</code> 和 <code>recv()</code> 函数的一个标志，表示处理“带外数据”（Out-of-Band Data）。</li>
<li>带外数据是指一些特殊的紧急数据，它可以让发送方在已经发送的常规数据流中插入一些紧急信息，接收方可以优先处理这些紧急信息。</li>
</ul>
</li>
<li><p><strong>使用</strong>：</p>
<ul>
<li><p>当使用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send()</span><br></pre></td></tr></table></figure>

<p> 时，可以通过传递 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSG_OOB</span><br></pre></td></tr></table></figure>

<p> 标志来将紧急数据发送给对方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send(sockfd, buffer, length, MSG_OOB);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当使用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recv()</span><br></pre></td></tr></table></figure>

<p> 时，也可以使用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSG_OOB</span><br></pre></td></tr></table></figure>

<p> 标志来读取紧急数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recv(sockfd, buffer, length, MSG_OOB);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>紧急数据并不会破坏正常的 TCP 数据流，它可以和普通数据同时发送，但接收方可以选择优先处理紧急数据。</li>
<li>紧急数据通常只有一个字节，适合传递一些需要快速响应的控制信息。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><code>MSG_OOB</code> 常用于传递需要快速处理的<strong>小型</strong>控制数据，如<strong>信号、中断命令</strong>等。例如，在远程控制软件中，用户按下的某些“紧急”键可以通过 <code>MSG_OOB</code> 来传输，以便接收方能优先处理。</li>
</ul>
</li>
<li><p><strong>限制</strong>：</p>
<ul>
<li><code>MSG_OOB</code> 只能传递非常短的数据（通常只有一个字节），如果传输的紧急数据量较大，不建议使用。</li>
</ul>
</li>
</ul>
<h3 id="2-TCP-紧急模式（TCP-Urgent-Mode）"><a href="#2-TCP-紧急模式（TCP-Urgent-Mode）" class="headerlink" title="2. TCP 紧急模式（TCP Urgent Mode）"></a>2. <strong>TCP 紧急模式（TCP Urgent Mode）</strong></h3><ul>
<li><strong>概念</strong>：<ul>
<li>TCP 紧急模式是 TCP 协议提供的一种机制，用来发送紧急数据。紧急模式依赖于 TCP 标头中的<strong>紧急指针（Urgent Pointer）</strong>。</li>
<li>当 TCP 发送端标记某些数据为紧急数据时，它会设置 TCP 报头中的 URG 标志，并设置一个指针指向紧急数据在流中的位置。</li>
<li>接收端可以通过读取 URG 标志和紧急指针的位置，优先处理紧急数据。</li>
</ul>
</li>
<li><strong>工作机制</strong>：<ul>
<li>紧急数据是在数据流中插入的，属于内联数据（In-line Data），这意味着它与普通数据共享同一个数据流。</li>
<li>紧急指针不会中断数据流，而只是指出流中的哪些字节是紧急的。接收方可以选择立即读取紧急数据或者继续处理普通数据。</li>
<li>发送方和接收方之间的紧急数据处理是“协作式”的，发送方告诉接收方紧急数据的位置，但接收方可以选择何时处理它。</li>
</ul>
</li>
<li><strong>使用紧急指针（Urgent Pointer）</strong>：<ul>
<li>紧急指针告诉接收方，数据流中的某个位置及之后的数据是紧急的。尽管如此，接收方可以选择继续处理非紧急数据，而不是立即响应紧急数据。</li>
<li>通常，接收端的 TCP&#x2F;IP 堆栈会优先处理紧急数据。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>紧急模式主要用于需要在数据流中插入高优先级控制数据的场合，比如<strong>终止会话、流量控制、特殊中断</strong>等。</li>
</ul>
</li>
</ul>
<h3 id="3-MSG-OOB-与-TCP-紧急模式的关系"><a href="#3-MSG-OOB-与-TCP-紧急模式的关系" class="headerlink" title="3. MSG_OOB 与 TCP 紧急模式的关系"></a>3. <strong>MSG_OOB 与 TCP 紧急模式的关系</strong></h3><ul>
<li><strong>MSG_OOB</strong> 实际上是应用层对 TCP 紧急模式的<strong>接口或实现</strong>。TCP 紧急模式由 TCP 层协议提供，而 <code>MSG_OOB</code> 是使用该模式的一种方法。</li>
<li>在发送和接收紧急数据时，<code>MSG_OOB</code> 标志的作用就是标记和处理这些紧急数据，它是对 TCP 紧急数据的抽象和封装。</li>
</ul>
<h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. <strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li><strong>优先级高</strong>：紧急模式和 <code>MSG_OOB</code> 允许发送方传递需要接收方优先处理的高优先级数据，减少延迟。</li>
<li><strong>内联数据传输</strong>：紧急数据不会打断常规数据流，可以在流式数据的基础上同时发送紧急信息。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>紧急数据有限</strong>：由于紧急数据通常只有一个字节，并且<strong>应用层只能通过 <code>MSG_OOB</code> 处理</strong>，数据量有限，不适合传输大量紧急数据。</li>
<li><strong>兼容性问题</strong>：并非所有系统和网络栈都完全支持或使用 TCP 紧急模式，因此在跨平台或复杂网络环境中，依赖紧急模式可能导致兼容性问题。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>MSG_OOB</strong> 是应用层用于发送和接收紧急数据的标志，依赖于 TCP 紧急模式的实现。</li>
<li><strong>TCP 紧急模式</strong> 使用紧急指针标记紧急数据的位置，允许接收方优先处理这些数据。</li>
<li>它们适用于需要传递优先级较高的小型数据的场景，但由于紧急数据量限制和兼容性问题，<strong>不建议用于传输大量或持续的数据</strong>。</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>server端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void work(int client_sock) &#123;</span><br><span class="line">    char buffer[1024];</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    // 尝试接收紧急数据</span><br><span class="line">    len = recv(client_sock, buffer, sizeof(buffer) - 1, MSG_OOB);</span><br><span class="line">    if (len &gt; 0) &#123;</span><br><span class="line">        buffer[len] = &#x27;\0&#x27;;</span><br><span class="line">        cout &lt;&lt; &quot;Received OOB message: &quot; &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        FD_CLR(client_sock, &amp;reads); // 客户端断开连接，移除集合中的它的套接字</span><br><span class="line">        close(client_sock);</span><br><span class="line">        cout &lt;&lt; &quot;Closed Client emergency: &quot; &lt;&lt; client_sock &lt;&lt; endl;</span><br><span class="line">        return; // 处理完紧急数据后返回</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没有紧急数据，再接收常规数据</span><br><span class="line">    len = read(client_sock, buffer, sizeof(buffer) - 1);</span><br><span class="line">    if (len == 0) &#123;</span><br><span class="line">        FD_CLR(client_sock, &amp;reads); // 客户端断开连接，移除集合中的它的套接字</span><br><span class="line">        close(client_sock);</span><br><span class="line">        cout &lt;&lt; &quot;Closed Client: &quot; &lt;&lt; client_sock &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        buffer[len] = &#x27;\0&#x27;;</span><br><span class="line">        cout &lt;&lt; &quot;Message from Server: &quot; &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void write_msg()&#123;</span><br><span class="line">    int str_len = 0;                                                                                                                                           </span><br><span class="line">    string msg;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Insert Message(q to quite),! for OOB message : &quot;;</span><br><span class="line">        cout.flush();</span><br><span class="line">        char buffer[1024];</span><br><span class="line">        getline(cin,msg);</span><br><span class="line">        </span><br><span class="line">        if(msg == &quot;q&quot;)&#123;</span><br><span class="line">            shutdown(cSock , SHUT_WR);</span><br><span class="line">            return;</span><br><span class="line">        &#125;else if(msg == &quot;!&quot;)&#123;</span><br><span class="line">            const char* oob_msg = &quot;!&quot;;</span><br><span class="line"></span><br><span class="line">            if(send(cSock,oob_msg,strlen(oob_msg),MSG_OOB) == -1)&#123;</span><br><span class="line">                cerr &lt;&lt; &quot;send OOB message failed&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cout &lt;&lt; &quot;send OOB message: &quot; &lt;&lt; oob_msg &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cSock , msg.c_str() , msg.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多播与广播"><a href="#多播与广播" class="headerlink" title="多播与广播"></a>多播与广播</h2><p>多播与广播都是通过<strong>UDP</strong>协议传递数据包</p>
<p>都是一次性向多个主机发送数据，但多播可以跨越不同的网络，只要加入<strong>多播组</strong>就能接受数据</p>
<p>但广播<strong>只能向同一网络</strong>中的主机传输数据</p>
<h3 id="多播实现"><a href="#多播实现" class="headerlink" title="多播实现"></a>多播实现</h3><p>sender端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">#define TTL 64</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void error_handler(const string&amp; msg) &#123;</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int send_sock;</span><br><span class="line">struct sockaddr_in mAddr; // 多播组IP地址</span><br><span class="line">int time_live = TTL;</span><br><span class="line"></span><br><span class="line">void create_send_socket() &#123;</span><br><span class="line">    send_sock = socket(PF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if (send_sock == -1) &#123;</span><br><span class="line">        error_handler(&quot;send socket create error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;send socket is created&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_mAddr(const string&amp; ip, const string&amp; port) &#123;</span><br><span class="line">    memset(&amp;mAddr, 0, sizeof(mAddr));</span><br><span class="line">    mAddr.sin_family = PF_INET;</span><br><span class="line">    mAddr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">    mAddr.sin_port = htons(stoi(port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send_file(const string&amp; filename) &#123;</span><br><span class="line">    ifstream file(filename, ios::binary);</span><br><span class="line">    char buffer[1024];</span><br><span class="line"></span><br><span class="line">    if (file.is_open()) &#123;</span><br><span class="line">        while (file.read(buffer, sizeof(buffer))) &#123;</span><br><span class="line">            sendto(send_sock, buffer, file.gcount(), 0, (struct sockaddr*)&amp;mAddr, sizeof(mAddr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 处理文件剩余的部分</span><br><span class="line">        if (file.gcount() &gt; 0) &#123;</span><br><span class="line">            sendto(send_sock, buffer, file.gcount(), 0, (struct sockaddr*)&amp;mAddr, sizeof(mAddr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file.close();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        error_handler(&quot;Failed to open file&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //发送结束标记</span><br><span class="line">    const char* sig= &quot;EOF&quot;;</span><br><span class="line">    sendto(send_sock , sig , strlen(sig) , 0, (struct sockaddr*)&amp;mAddr, sizeof(mAddr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    if (argc != 3) &#123;</span><br><span class="line">        error_handler(&quot;Usage: &quot; + string(argv[0]) + &quot; &lt;Group IP&gt; &lt;port&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    create_send_socket();</span><br><span class="line">    init_mAddr(argv[1], argv[2]);</span><br><span class="line"></span><br><span class="line">    if (setsockopt(send_sock, IPPROTO_IP, IP_MULTICAST_TTL, (void*)&amp;time_live, sizeof(time_live)) &lt; 0) &#123;</span><br><span class="line">        error_handler(&quot;setsockopt error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    send_file(&quot;test.txt&quot;);</span><br><span class="line">    close(send_sock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recv端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void error_handler(const string&amp; msg) &#123;</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int recv_sock;</span><br><span class="line">struct sockaddr_in sAddr;</span><br><span class="line">struct ip_mreq join_addr; // 加入组播网络</span><br><span class="line"></span><br><span class="line">void join_group(const string&amp; ip) &#123;</span><br><span class="line">    join_addr.imr_multiaddr.s_addr = inet_addr(ip.c_str()); // 组播地址</span><br><span class="line">    join_addr.imr_interface.s_addr = htonl(INADDR_ANY); // 使用所有接口</span><br><span class="line"></span><br><span class="line">    if (setsockopt(recv_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void*)&amp;join_addr, sizeof(join_addr)) &lt; 0) &#123;</span><br><span class="line">        error_handler(&quot;setsockopt error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recv_file(const string&amp; filename) &#123;</span><br><span class="line">    ofstream file(filename, ios::binary | ios::app);</span><br><span class="line">    char buffer[1024];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Receiving file...&quot; &lt;&lt; endl;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int str_len = recvfrom(recv_sock, buffer, sizeof(buffer) - 1, 0, nullptr, 0);</span><br><span class="line">        if (str_len &lt; 0) &#123;</span><br><span class="line">            cerr &lt;&lt; &quot;recvfrom error&quot; &lt;&lt; endl;</span><br><span class="line">            break; // 接收错误，退出循环</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; str_len &lt;&lt; endl;</span><br><span class="line">        if (str_len == 0) &#123;</span><br><span class="line">            break; // 没有数据接收，退出循环</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (strncmp(buffer, &quot;EOF&quot;, 3) == 0 &amp;&amp; str_len == 3) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;End of file signal received.&quot; &lt;&lt; endl;</span><br><span class="line">            break; // 收到结束信号，退出循环                                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 写入文件</span><br><span class="line">        file.write(buffer, str_len);</span><br><span class="line">        cout &lt;&lt; &quot;file add cnt :&quot; &lt;&lt; ++cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;File received successfully!&quot; &lt;&lt; endl;</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc != 3) &#123;</span><br><span class="line">        error_handler(&quot;Usage: &quot; + string(argv[0]) + &quot; &lt;Group IP&gt; &lt;port&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    recv_sock = socket(PF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if (recv_sock &lt; 0) &#123;</span><br><span class="line">        error_handler(&quot;socket creation error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memset(&amp;sAddr, 0, sizeof(sAddr));</span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = htonl(INADDR_ANY); // 绑定到所有可用接口</span><br><span class="line">    sAddr.sin_port = htons(stoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    if (bind(recv_sock, (struct sockaddr *)&amp;sAddr, sizeof(sAddr)) == -1) &#123;</span><br><span class="line">        error_handler(&quot;bind error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    join_group(argv[1]);</span><br><span class="line">    recv_file(&quot;test.txt&quot;);</span><br><span class="line">    close(recv_sock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：多播地址 即 D类ip地址，范围是从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code> ， 端口一般用9190（不是一定）</p>
<h3 id="广播实现"><a href="#广播实现" class="headerlink" title="广播实现"></a>广播实现</h3><p>send端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只需要把</span><br><span class="line">int time_live = TTL </span><br><span class="line">改成</span><br><span class="line">int so_brd = 1</span><br></pre></td></tr></table></figure>

<p>recv端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有入组了，且只需要端口号就行</span><br></pre></td></tr></table></figure>

<p>PS ： 广播地址 即 网络号与子网掩码按位与 ， 主机号全置为1的 ip 地址， 端口一般用 9190（不是一定）</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll优化了select的缺陷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无需循环监视所有文件描述符</span><br><span class="line"></span><br><span class="line">调用对应于select函数的epoll_wait函数无需每次都传递监视对象信息</span><br></pre></td></tr></table></figure>

<p>但是select兼容性好，epoll仅在特定环境使用</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>server端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_EVENTS 10   //最大事件数，指一次性可以接受多少事件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int sSock , cSock;</span><br><span class="line">struct sockaddr_in sAddr , cAddr;</span><br><span class="line">socklen_t cAddr_sz;</span><br><span class="line"></span><br><span class="line">struct epoll_event  event ,ep_event[MAX_EVENTS]; ;</span><br><span class="line">int epfd,event_cnt;</span><br><span class="line"></span><br><span class="line">void error_handler(const string&amp; msg)&#123;</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; &quot;:&quot; &lt;&lt; strerror(errno)  &lt;&lt; endl;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void epoll_add(int type , int sock)&#123;</span><br><span class="line">    event.events = type; //监听读事件 OUT 就是写</span><br><span class="line">    event.data.fd = sock; //将服务器套接字 sSock 的文件描述符赋值给 event 结构体中的 data 成员</span><br><span class="line">    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &amp;event) == -1) &#123;</span><br><span class="line">        error_handler(&quot;epoll_ctl() error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_prepare(const string&amp; port)&#123;</span><br><span class="line">    sSock = socket(PF_INET , SOCK_STREAM , 0);</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create1(0);</span><br><span class="line">    if(epfd == -1) error_handler(&quot;epoll create() error&quot;);  </span><br><span class="line">    epoll_add(EPOLLIN , sSock);</span><br><span class="line"></span><br><span class="line">    memset(&amp;sAddr , 0 , sizeof(sAddr));</span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    sAddr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if(bind(sSock , (struct sockaddr *)&amp;sAddr , sizeof(sAddr)) == -1) error_handler(&quot;bind() error&quot;);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;start listen...&quot; &lt;&lt; endl;</span><br><span class="line">    if(listen(sSock , 5) == -1) error_handler(&quot;listen() error&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void connect_client()&#123;</span><br><span class="line">    cAddr_sz = sizeof(cAddr);</span><br><span class="line">    cSock = accept(sSock , (struct sockaddr *)&amp;cAddr , &amp;cAddr_sz);</span><br><span class="line">    epoll_add(EPOLLIN , cSock);</span><br><span class="line">    cout &lt;&lt; &quot;client is connect : &quot; &lt;&lt; cSock &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work(int client_sock)&#123;</span><br><span class="line"></span><br><span class="line">    char buffer[1024];</span><br><span class="line">    int len = read(client_sock, buffer , sizeof(buffer));</span><br><span class="line">    </span><br><span class="line">    if(len == 0)&#123;//关闭链接</span><br><span class="line">        epoll_ctl(epfd , EPOLL_CTL_DEL , client_sock , nullptr);</span><br><span class="line">        close(client_sock);</span><br><span class="line">        cout &lt;&lt; &quot;close client : &quot; &lt;&lt; client_sock &lt;&lt; endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        write(client_sock, buffer , len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_start()&#123;</span><br><span class="line"></span><br><span class="line">    while(1)&#123;</span><br><span class="line">        event_cnt = epoll_wait(epfd , ep_event , MAX_EVENTS , -1);</span><br><span class="line">        if(event_cnt == -1)&#123;</span><br><span class="line">            puts(&quot;event_wait() error&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0 ; i &lt; event_cnt ; i ++)&#123;</span><br><span class="line">            if(ep_event[i].data.fd == sSock)&#123;//监听到连接请求了</span><br><span class="line">                connect_client();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                work(ep_event[i].data.fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])&#123;</span><br><span class="line"></span><br><span class="line">    if(argc != 2)  error_handler(&quot;Usage&quot; + string(argv[0]) + &quot;&lt;port&gt;&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;server is prepare...&quot; &lt;&lt; endl;</span><br><span class="line">    server_prepare(argv[1]);  </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;server is start!&quot; &lt;&lt; endl;</span><br><span class="line">    server_start();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;server is closed&quot; &lt;&lt; endl;</span><br><span class="line">    close(sSock);</span><br><span class="line">    close(epfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件触发与边缘触发"><a href="#条件触发与边缘触发" class="headerlink" title="条件触发与边缘触发"></a>条件触发与边缘触发</h3><p>条件触发中只要 <strong>输入缓冲有数据</strong> 就会一直通知该事件</p>
<p>边缘触发中 <strong>输入缓冲收到数据仅通知一次</strong>，即使还有数据，也不会再通知事件了</p>
<p>epoll默认和select都是 <strong>条件触发</strong></p>
<p>在条件触发中，每次客户端发送数据包到服务端，服务端都会为其注册一次事件，并多次调用epoll_wait,只要数据未被完全读取，就会一直被触发</p>
<p>而边缘触发，只会在第一次发送数据包注册一次事件，调用一次epoll_wait，如果没有完全读取数据，会错过后续的触发，因此要结合非阻塞模式使用</p>
<h3 id="边缘触发实现"><a href="#边缘触发实现" class="headerlink" title="边缘触发实现"></a>边缘触发实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_EVENTS 10   //最大事件数</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int sSock, cSock;</span><br><span class="line">struct sockaddr_in sAddr, cAddr;</span><br><span class="line">socklen_t cAddr_sz;</span><br><span class="line"></span><br><span class="line">struct epoll_event event, ep_event[MAX_EVENTS];</span><br><span class="line">int epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">void error_handler(const string&amp; msg) &#123;</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_nonblocking(int sock) &#123; //将套接字改为非阻塞模式</span><br><span class="line">    int flag = fcntl(sock, F_GETFL, 0);</span><br><span class="line">    if (flag == -1) error_handler(&quot;fcntl get error&quot;);</span><br><span class="line">    if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) == -1) &#123;</span><br><span class="line">        error_handler(&quot;fcntl set non-blocking error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void epoll_add(int type, int sock) &#123;</span><br><span class="line">    event.events = type | EPOLLET; //监听读事件，使用边缘触发</span><br><span class="line">    event.data.fd = sock; //将套接字的文件描述符赋值给 event 结构体中的 data 成员</span><br><span class="line">    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &amp;event) == -1) &#123;</span><br><span class="line">        error_handler(&quot;epoll_ctl() error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_prepare(const string&amp; port) &#123;</span><br><span class="line">    sSock = socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line">    </span><br><span class="line">    set_nonblocking(sSock);</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create1(0);</span><br><span class="line">    if (epfd == -1) error_handler(&quot;epoll create() error&quot;);</span><br><span class="line">    epoll_add(EPOLLIN, sSock);</span><br><span class="line"></span><br><span class="line">    memset(&amp;sAddr, 0, sizeof(sAddr));</span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    sAddr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">    if (bind(sSock, (struct sockaddr*)&amp;sAddr, sizeof(sAddr)) == -1) error_handler(&quot;bind() error&quot;);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;start listen...&quot; &lt;&lt; endl;</span><br><span class="line">    if (listen(sSock, 5) == -1) error_handler(&quot;listen() error&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void connect_client() &#123;</span><br><span class="line">    cAddr_sz = sizeof(cAddr);</span><br><span class="line">    cSock = accept(sSock, (struct sockaddr*)&amp;cAddr, &amp;cAddr_sz);</span><br><span class="line">    if (cSock &lt; 0) &#123;</span><br><span class="line">        error_handler(&quot;accept() error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_nonblocking(cSock);</span><br><span class="line">    epoll_add(EPOLLIN, cSock);</span><br><span class="line">    cout &lt;&lt; &quot;client is connected: &quot; &lt;&lt; cSock &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work(int client_sock) &#123;</span><br><span class="line">    char buffer[1024];</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int len = read(client_sock, buffer, sizeof(buffer));</span><br><span class="line">        </span><br><span class="line">        if (len == 0) &#123; //关闭链接</span><br><span class="line">            epoll_ctl(epfd, EPOLL_CTL_DEL, client_sock, nullptr);</span><br><span class="line">            close(client_sock);</span><br><span class="line">            cout &lt;&lt; &quot;close client: &quot; &lt;&lt; client_sock &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (len &lt; 0) &#123;</span><br><span class="line">            if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                // 没有数据可读，退出循环</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error_handler(&quot;read error&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            write(client_sock, buffer, len); // 注意可能需要处理未写完的情况</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_start() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        event_cnt = epoll_wait(epfd, ep_event, MAX_EVENTS, -1);</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; &quot;return epoll_wait&quot; &lt;&lt; endl; //验证边缘触发</span><br><span class="line">        </span><br><span class="line">        if (event_cnt == -1) &#123;</span><br><span class="line">            puts(&quot;event_wait() error&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; event_cnt; i++) &#123;</span><br><span class="line">            if (ep_event[i].data.fd == sSock) &#123; //监听到连接请求</span><br><span class="line">                connect_client();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                work(ep_event[i].data.fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    if (argc != 2) error_handler(&quot;Usage: &quot; + string(argv[0]) + &quot; &lt;port&gt;&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;server is preparing...&quot; &lt;&lt; endl;</span><br><span class="line">    server_prepare(argv[1]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;server is started!&quot; &lt;&lt; endl;</span><br><span class="line">    server_start();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;server is closed&quot; &lt;&lt; endl;</span><br><span class="line">    close(sSock);</span><br><span class="line">    close(epfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>边缘触发的优势</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以分离接收数据和处理数据的时间点</span><br><span class="line"></span><br><span class="line">从实际模型的角度出发，边缘触发更有可能带来更高的性能，但不能简单的认为只要使用边缘触发就一定能提高速度</span><br></pre></td></tr></table></figure>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程和进程的差异："><a href="#线程和进程的差异：" class="headerlink" title="线程和进程的差异："></a>线程和进程的差异：</h3><ol>
<li><strong>进程</strong>是操作系统资源分配的基本单位。每个进程都拥有<strong>独立的地址空间</strong>，包括<strong>数据区</strong>、<strong>堆区</strong>和<strong>栈区</strong>。因此，创建一个进程的开销较大，因为需要为其分配和管理独立的资源。</li>
<li><strong>线程</strong>是 CPU 调度的基本单位，是进程的组成部分。每个线程拥有<strong>独立的栈空间</strong>，但与同一进程中的其他线程共享<strong>数据区</strong>和<strong>堆区</strong>。由于线程共享同一进程的资源，因此创建线程的开销比创建进程要小。</li>
<li>在<strong>上下文切换</strong>时：<ul>
<li><strong>进程</strong>的上下文切换需要切换<strong>整个地址空间</strong>，包括数据区、堆区和栈区，因而代价较高。</li>
<li><strong>线程</strong>的上下文切换只需要切换<strong>栈</strong>（因为每个线程有自己的栈），而数据区和堆区是共享的，因此开销较小，切换速度较快。</li>
</ul>
</li>
<li>线程可以通过共享的<strong>数据区</strong>和<strong>堆区</strong>直接进行数据交换，而不需要像进程间通信那样通过复杂的机制（如管道、消息队列、共享内存等）。</li>
</ol>
<hr>
<h3 id="进程和线程的定义："><a href="#进程和线程的定义：" class="headerlink" title="进程和线程的定义："></a>进程和线程的定义：</h3><ol>
<li><strong>进程</strong>是操作系统中资源分配的独立单位，一个进程可以拥有多个线程。</li>
<li><strong>线程</strong>是进程中的执行流单位，一个进程内的多个线程共享同一地址空间和系统资源（如文件句柄、网络连接等）。</li>
</ol>
<hr>
<h3 id="操作系统与进程、线程的关系："><a href="#操作系统与进程、线程的关系：" class="headerlink" title="操作系统与进程、线程的关系："></a>操作系统与进程、线程的关系：</h3><ul>
<li><strong>操作系统</strong>管理多个进程。每个进程是相互独立的，可以并发执行。</li>
<li>每个<strong>进程</strong>可以包含多个线程，它们共享进程的资源，协同完成任务。</li>
</ul>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void thread_main(int cnt, string&amp; message) &#123;</span><br><span class="line">    message = &quot;Hello, I&#x27;m thread\n&quot;;  </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(1));  // 使用C++11的休眠方式</span><br><span class="line">        cout &lt;&lt; &quot;running thread&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int thread_param = 5;</span><br><span class="line">    string message;  // 使用std::string来保存返回值</span><br><span class="line"></span><br><span class="line">    // 创建线程并传递参数和返回值引用</span><br><span class="line">    thread t(thread_main, thread_param, ref(message));</span><br><span class="line"></span><br><span class="line">    // 等待线程执行完毕</span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">    // 输出线程返回的消息</span><br><span class="line">    cout &lt;&lt; &quot;Thread return message: &quot; &lt;&lt; message &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了方式多线程对于同一变量进行访问出现问题，我们必须做线程同步</span><br><span class="line"></span><br><span class="line">互斥量（mutual exclusion）就是其中之一种线程同步方式</span><br></pre></td></tr></table></figure>

<h4 id="应用：利用多线程计算1-10的和"><a href="#应用：利用多线程计算1-10的和" class="headerlink" title="应用：利用多线程计算1-10的和"></a>应用：利用多线程计算1-10的和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int sum = 0;           // 全局变量，用于存储总和</span><br><span class="line">mutex mtx;             // 用于保护 sum 的互斥锁</span><br><span class="line"></span><br><span class="line">void calculate_sum(int start, int end) &#123;</span><br><span class="line">    int local_sum = 0;  // 局部变量来计算每个线程的部分和</span><br><span class="line">    for (int i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        local_sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保护对 sum 的修改，确保线程安全</span><br><span class="line">    //lock_guard 是 RAII（Resource Acquisition Is Initialization）模式的一种实现，它确保在当前作用域结束时自动释放锁。</span><br><span class="line">    lock_guard&lt;mutex&gt; lock(mtx);</span><br><span class="line">    sum += local_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建两个线程分别计算 1-5 和 6-10 的和</span><br><span class="line">    thread t1(calculate_sum, 1, 5);</span><br><span class="line">    thread t2(calculate_sum, 6, 10);</span><br><span class="line"></span><br><span class="line">    // 等待两个线程结束</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    // 输出总和</span><br><span class="line">    cout &lt;&lt; &quot;Total sum: &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>注意：此方法仅在c++20中可用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 全局变量</span><br><span class="line">int sum = 0;</span><br><span class="line">sem_t semaphore; // POSIX 信号量</span><br><span class="line"></span><br><span class="line">void calculate_sum(int start, int end) &#123;</span><br><span class="line">    int local_sum = 0;</span><br><span class="line"></span><br><span class="line">    // 计算局部和</span><br><span class="line">    for (int i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        local_sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 请求进入临界区，等待信号量</span><br><span class="line">    sem_wait(&amp;semaphore);</span><br><span class="line"></span><br><span class="line">    // 修改共享资源</span><br><span class="line">    sum += local_sum;</span><br><span class="line"></span><br><span class="line">    // 释放信号量，允许其他线程进入临界区</span><br><span class="line">    sem_post(&amp;semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化信号量，初始值为 1</span><br><span class="line">    sem_init(&amp;semaphore, 0, 1);</span><br><span class="line"></span><br><span class="line">    // 创建两个线程分别计算 1-5 和 6-10 的和</span><br><span class="line">    thread t1(calculate_sum, 1, 5);</span><br><span class="line">    thread t2(calculate_sum, 6, 10);</span><br><span class="line"></span><br><span class="line">    // 等待两个线程结束</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    // 输出总和</span><br><span class="line">    cout &lt;&lt; &quot;Total sum: &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 销毁信号量</span><br><span class="line">    sem_destroy(&amp;semaphore);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的销毁和多线程并发服务器端的实现"><a href="#线程的销毁和多线程并发服务器端的实现" class="headerlink" title="线程的销毁和多线程并发服务器端的实现"></a>线程的销毁和多线程并发服务器端的实现</h2><h2 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h2><p>server端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX 1010</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void error_handler(const string&amp; msg) &#123;</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; &quot; &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int serverSock;</span><br><span class="line">vector&lt;int&gt; clientSocks;</span><br><span class="line">struct sockaddr_in serverAddr, clientAddr;</span><br><span class="line">socklen_t clientAddrSize;</span><br><span class="line">mutex mtx;</span><br><span class="line"></span><br><span class="line">void server_prepare(const string&amp; port) &#123;</span><br><span class="line">    serverSock = socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (serverSock &lt; 0) error_handler(&quot;socket() error&quot;);</span><br><span class="line"></span><br><span class="line">    memset(&amp;serverAddr, 0, sizeof(serverAddr));</span><br><span class="line">    serverAddr.sin_family = PF_INET;</span><br><span class="line">    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serverAddr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">    if (bind(serverSock, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) == -1)</span><br><span class="line">        error_handler(&quot;bind() error&quot;);</span><br><span class="line"></span><br><span class="line">    if (listen(serverSock, 5) == -1)</span><br><span class="line">        error_handler(&quot;listen() error&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void wait_login() &#123;</span><br><span class="line">    clientAddrSize = sizeof(clientAddr);</span><br><span class="line">    int clientSock = accept(serverSock, (struct sockaddr*)&amp;clientAddr, &amp;clientAddrSize);</span><br><span class="line">    if (clientSock &lt; 0) error_handler(&quot;accept() error&quot;);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        lock_guard&lt;mutex&gt; lock(mtx);</span><br><span class="line">        clientSocks.push_back(clientSock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void logout(int clientSock) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        lock_guard&lt;mutex&gt; lock(mtx);</span><br><span class="line">        clientSocks.erase(remove(clientSocks.begin(), clientSocks.end(), clientSock), clientSocks.end());</span><br><span class="line">    &#125;</span><br><span class="line">    close(clientSock); // 关闭 socket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send_msg(const char msg[], int len) &#123;</span><br><span class="line">    lock_guard&lt;mutex&gt; lock(mtx);</span><br><span class="line">    for (int clientSock : clientSocks) &#123;</span><br><span class="line">        if (write(clientSock, msg, len) &lt; 0) &#123;</span><br><span class="line">            logout(clientSock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recv_msg(int clientSock) &#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    char msg[1024];</span><br><span class="line"></span><br><span class="line">    while ((len = read(clientSock, msg, sizeof(msg))) &gt; 0) &#123;</span><br><span class="line">        send_msg(msg, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (len &lt; 0) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;recv_msg error: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    logout(clientSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_start() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        wait_login();</span><br><span class="line">        int clientSock;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            lock_guard&lt;mutex&gt; lock(mtx);</span><br><span class="line">            clientSock = clientSocks.back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread t(recv_msg, clientSock);</span><br><span class="line">        t.detach(); // 分离线程</span><br><span class="line">        cout &lt;&lt; &quot;Connected client IP: &quot; &lt;&lt; inet_ntoa(clientAddr.sin_addr) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    if (argc != 2) error_handler(&quot;Usage: &quot; + string(argv[0]) + &quot; &lt;port&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Start preparing...&quot; &lt;&lt; endl;</span><br><span class="line">    server_prepare(argv[1]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Server is starting!&quot; &lt;&lt; endl;</span><br><span class="line">    server_start(); </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Server is closing&quot; &lt;&lt; endl;</span><br><span class="line">    close(serverSock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void error_handler(const string&amp; msg) &#123;</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; &quot; &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cSock;</span><br><span class="line">struct sockaddr_in sAddr;</span><br><span class="line">string username;</span><br><span class="line"></span><br><span class="line">void connect_server(const string&amp;ip , const string&amp; port)&#123;</span><br><span class="line">    cSock = socket(PF_INET , SOCK_STREAM , 0 );</span><br><span class="line"></span><br><span class="line">    memset(&amp;sAddr , 0 , sizeof (sAddr));</span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">    sAddr.sin_port = htons(stoi(port));</span><br><span class="line">    </span><br><span class="line">    if(connect(cSock , (struct sockaddr *)&amp;sAddr , sizeof(sAddr)) == -1) error_handler(&quot;connect failed&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send_msg(int cSock)&#123;</span><br><span class="line">    string msg;</span><br><span class="line">    string name_msg;</span><br><span class="line">    while(1)&#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; &quot;Insert Message(q to quite) :&quot;;</span><br><span class="line">        getline(cin,msg);</span><br><span class="line">        if(msg == &quot;q&quot;)&#123;</span><br><span class="line">            cout &lt;&lt; &quot;close connect&quot; &lt;&lt; endl;</span><br><span class="line">            close(cSock);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        name_msg = username + &quot;:&quot; + msg; </span><br><span class="line">        write(cSock , name_msg.c_str() , name_msg.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recv_msg(int cSock) &#123;</span><br><span class="line">    char buffer[1024];</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int len = read(cSock, buffer, sizeof(buffer) - 1);</span><br><span class="line">        if (len &lt;= 0) &#123;</span><br><span class="line">            cerr &lt;&lt; &quot;Connection closed or read error.&quot; &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[len] = &#x27;\0&#x27;; // Null-terminate the string</span><br><span class="line">        cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    if(argc != 4) error_handler(&quot;Usage: &quot; + string(argv[0]) + &quot; &lt;ip addr&gt; &lt;port&gt; &lt;username&gt;&quot;);</span><br><span class="line">    username = argv[3];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;connect server....&quot; &lt;&lt; endl;</span><br><span class="line">    connect_server(argv[1],argv[2]);</span><br><span class="line">    cout &lt;&lt; &quot;connect success!&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    thread t1(send_msg,cSock);</span><br><span class="line">    thread t2(recv_msg,cSock);</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;close connect&quot; &lt;&lt; endl;</span><br><span class="line">    close(cSock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于TCP协议的WEB服务器搭建"><a href="#基于TCP协议的WEB服务器搭建" class="headerlink" title="基于TCP协议的WEB服务器搭建"></a>基于TCP协议的WEB服务器搭建</h2><p>web服务器端：基于<strong>HTTP</strong> （超文本传输协议）协议将网页对应<strong>文件</strong>传输给客户端的服务器端</p>
<h3 id="http特点："><a href="#http特点：" class="headerlink" title="http特点："></a>http特点：</h3><p>服务器端不会维持客户端的状态，即使同一个客户再次发送请求，服务器端也无法辨认原先哪个，而是以相同的方式处理请求</p>
<p>因此被称为 无状态的Stateless 协议</p>
<p>为了弥补这一缺点，引入了cookie和session技术</p>
<h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET filepath HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>服务器端会返回客户端状态码，常见的状态码有以下几种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200 OK ： 处理请求成功</span><br><span class="line">404 NOTfOUND ：请求的文件不存在</span><br><span class="line">400 BAD REQUEST ： 请求方式错误</span><br></pre></td></tr></table></figure>

<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void error_handler(const string&amp; msg) &#123;</span><br><span class="line">    cerr &lt;&lt; msg &lt;&lt; &quot; &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sSock;</span><br><span class="line">struct sockaddr_in sAddr, cAddr;</span><br><span class="line">socklen_t cAddr_size;</span><br><span class="line"></span><br><span class="line">void server_prepare(const string&amp; port) &#123;</span><br><span class="line">    sSock = socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (sSock == -1) error_handler(&quot;socket() error&quot;);</span><br><span class="line"></span><br><span class="line">    memset(&amp;sAddr, 0, sizeof(sAddr));</span><br><span class="line">    sAddr.sin_family = PF_INET;</span><br><span class="line">    sAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    sAddr.sin_port = htons(stoi(port));</span><br><span class="line"></span><br><span class="line">    if (bind(sSock, (struct sockaddr*)&amp;sAddr, sizeof(sAddr)) == -1) error_handler(&quot;bind() error&quot;);</span><br><span class="line">    if (listen(sSock, 20) == -1) error_handler(&quot;listen() error&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send_error(int cSock) &#123;</span><br><span class="line">    string error_msg = &quot;HTTP/1.1 404 Not Found\r\n&quot;</span><br><span class="line">                       &quot;Content-Length: 0\r\n&quot;</span><br><span class="line">                       &quot;Connection: close\r\n\r\n&quot;;</span><br><span class="line">    write(cSock, error_msg.c_str(), error_msg.size());</span><br><span class="line">    close(cSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string get_content_type(const string&amp; filename) &#123;</span><br><span class="line">    if (filename.find(&quot;.html&quot;) != string::npos) return &quot;text/html&quot;;</span><br><span class="line">    if (filename.find(&quot;.css&quot;) != string::npos) return &quot;text/css&quot;;</span><br><span class="line">    if (filename.find(&quot;.js&quot;) != string::npos) return &quot;application/javascript&quot;;</span><br><span class="line">    if (filename.find(&quot;.jpg&quot;) != string::npos) return &quot;image/jpeg&quot;;</span><br><span class="line">    if (filename.find(&quot;.png&quot;) != string::npos) return &quot;image/png&quot;;</span><br><span class="line">    return &quot;application/octet-stream&quot;;  // 默认为二进制流</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send_file_data(const string&amp; filename, int cSock) &#123;</span><br><span class="line">    // 使用 root/ 作为文件的基础路径</span><br><span class="line">    string filepath = &quot;root&quot; + filename;</span><br><span class="line"></span><br><span class="line">    ifstream file(filepath, ios::binary);</span><br><span class="line">    if (!file) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;File not found: &quot; &lt;&lt; filepath &lt;&lt; endl;  // 输出完整文件路径</span><br><span class="line">        send_error(cSock);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    file.seekg(0, ios::end);</span><br><span class="line">    size_t filesize = file.tellg();</span><br><span class="line">    file.seekg(0, ios::beg);</span><br><span class="line">    </span><br><span class="line">    string header = &quot;HTTP/1.1 200 OK\r\n&quot;</span><br><span class="line">                    &quot;Content-Length: &quot; + to_string(filesize) + &quot;\r\n&quot;</span><br><span class="line">                    &quot;Content-Type: text/html\r\n&quot;</span><br><span class="line">                    &quot;Connection: close\r\n\r\n&quot;;</span><br><span class="line">    write(cSock, header.c_str(), header.size());</span><br><span class="line">    </span><br><span class="line">    char buffer[1024];</span><br><span class="line">    while (file.read(buffer, sizeof(buffer))) &#123;</span><br><span class="line">        write(cSock, buffer, file.gcount());</span><br><span class="line">    &#125;</span><br><span class="line">    write(cSock, buffer, file.gcount());</span><br><span class="line">    </span><br><span class="line">    file.close();</span><br><span class="line">    close(cSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void request_handler(int cSock) &#123;//处理客户端的请求，并且将客户端请求的文件名传给发送的函数</span><br><span class="line">    char req_line[1024] = &#123;0&#125;;</span><br><span class="line">    ssize_t bytes_read = read(cSock, req_line, sizeof(req_line) - 1);</span><br><span class="line"></span><br><span class="line">    if (bytes_read &lt;= 0) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Failed to read request from client&quot; &lt;&lt; endl;</span><br><span class="line">        close(cSock);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印客户端的请求行 : Request: GET /index2.html HTTP/1.1</span><br><span class="line">    cout &lt;&lt; &quot;Request: &quot; &lt;&lt; req_line &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    string request(req_line);</span><br><span class="line">    size_t pos = request.find(&quot; &quot;);</span><br><span class="line">    size_t pos2 = request.find(&quot; &quot;, pos + 1);</span><br><span class="line">    string filename = request.substr(pos + 1, pos2 - pos - 1);</span><br><span class="line"></span><br><span class="line">    if (filename == &quot;/&quot;) &#123;</span><br><span class="line">        filename = &quot;index.html&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    send_file_data(filename, cSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void server_start() &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        cAddr_size = sizeof(cAddr);</span><br><span class="line">        int clientSock = accept(sSock, (struct sockaddr*)&amp;cAddr, &amp;cAddr_size);</span><br><span class="line">        if (clientSock == -1) &#123;</span><br><span class="line">            error_handler(&quot;accept() error&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;connect request : &quot; &lt;&lt; inet_ntoa(cAddr.sin_addr) &lt;&lt; &quot;:&quot; &lt;&lt; ntohs(cAddr.sin_port) &lt;&lt; endl;</span><br><span class="line">        thread t(request_handler, clientSock);</span><br><span class="line">        t.detach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        error_handler(&quot;Usage: &quot; + string(argv[0]) + &quot; &lt;port&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;server prepare .....&quot; &lt;&lt; endl;</span><br><span class="line">    server_prepare(argv[1]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;server is start!&quot; &lt;&lt; endl;</span><br><span class="line">    server_start();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;close server&quot; &lt;&lt; endl;</span><br><span class="line">    close(sSock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./server_start 启动后使用curl或者浏览器访问</span><br><span class="line"></span><br><span class="line">http://ip:port/index.html即可</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意本机的文件路径</span><br><span class="line">webserver</span><br><span class="line">	server_start</span><br><span class="line">	root</span><br><span class="line">		index.html(css、js)</span><br></pre></td></tr></table></figure>



<h1 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h1><h2 id="第一章课后习题答案"><a href="#第一章课后习题答案" class="headerlink" title="第一章课后习题答案"></a>第一章课后习题答案</h2><ol>
<li><p>套接字在网络编程中的作用是什么？为什么称它为套接字？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">套接字是网络传输传输用的软件设备</span><br><span class="line"></span><br><span class="line">socket英文原意是插座：我们把插头插到插座上就能从电网获得电力供给，同样，为了与远程计算机进行数据传输，需要连接到Internet,而变成中的“套接字”就是用来连接该网络的工具</span><br></pre></td></tr></table></figure>
</li>
<li><p>在服务器端创建套接字后，会依次调用listen函数和accept函数。请比较并说明两者作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen:将套接字转为可接受连接方式</span><br><span class="line"></span><br><span class="line">accept:受理连接请求，并且在没有连接请求的情况调用该函数，不会返回， 直到有连接请求为止。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux中，对套接字数据进行I&#x2F;O时可以直接使用I&#x2F;O相关函数；而在Windows中则不可以。原因为何？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux把套接字也看作是文件，所以可以用文件I/O相关函数；</span><br><span class="line"></span><br><span class="line">而Windows要区分套接字和文件，所以设置了特殊的函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建套接字后一般会给它分配地址，为什么？为了完成地址分配需要调用哪些函数？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要在网络上区分来自不同机器的套接字，所以需要地址信息。分配地址是通过bind()函数实现</span><br><span class="line">int bind(int sock , const struct sockaddr *addr , socklen_t addrlen);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux中的文件描述符与Windows的句柄实际上非常类似。请以套接字为对象说明他们的含义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux的文件描述符是为了区分指定文件而赋予文件的整数值（相当于编号）。</span><br><span class="line"></span><br><span class="line">Windows的文件描述符其实也是套接字的整数值，其目的也是区分指定套接字。s</span><br></pre></td></tr></table></figure>
</li>
<li><p>底层文件I&#x2F;O函数与ANSI标准定义的文件I&#x2F;O函数之间有何区别？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ANSI标准定义的输入、输出函数是与操作系统（内核）无关的以C标准写成的函数。</span><br><span class="line"></span><br><span class="line">相反，底层文件I/O函数是直接提供的。</span><br><span class="line"></span><br><span class="line">理论上ANSI标准I/O提供了某些机制，性能上由于底层I/O</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第二章课后习题答案"><a href="#第二章课后习题答案" class="headerlink" title="第二章课后习题答案"></a>第二章课后习题答案</h2><ul>
<li>什么是协议？在收发数据中定义协议有何意义？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议就是为了完成数据交换而定好的约定。因此，定义协议意味着对数据传输所必需的的承诺进行定义。</span><br></pre></td></tr></table></figure>

<ul>
<li>面向连接的TCP套接字传输特性有3点，请分别说明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">传输过程中数据不会丢失</span><br><span class="line"></span><br><span class="line">按序传输数据</span><br><span class="line"></span><br><span class="line">传输的数据不存在数据边界(Boundary)</span><br></pre></td></tr></table></figure>

<ul>
<li>下面哪些是面向消息的套接字的特性？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">传输数据可能丢失</span><br><span class="line"></span><br><span class="line">以快速传递为目标</span><br><span class="line"></span><br><span class="line">与面向连接的套接字不同，不存在连接的概念</span><br></pre></td></tr></table></figure>

<ul>
<li>什么时候用UDP，什么时候用TCP（非原题）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要快UDP，要稳TCP</span><br></pre></td></tr></table></figure>

<ul>
<li>何种类型的套接字不存在数据边界？这类套接字接收数据时需要注意什么？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接指向型TCP套接字不存在数据边界。</span><br><span class="line">因此输入输出函数的响应次数不具有意义。重要的不是函数的响应次数，而是数据的收发量。</span><br><span class="line">因此，必须将传输数据的量和接收数据的量制作成编码，保证发送数据的量和接收数据的量是一致的，特别要注意是制作依赖函数响应次数判断代码</span><br></pre></td></tr></table></figure>

<ul>
<li><p>服务端write一次，客户端read多次，改成write多次，read一次有什么区别（非原题）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大文件或大数据块传输：服务端 write 一次，客户端 read 多次可能更为合适，因为这样可以减少系统调用和网络延迟。</span><br><span class="line"></span><br><span class="line">实时性要求高的场景：如聊天应用、流媒体等场景，服务端 write 多次，客户端 read 一次可以更好地逐步发送小数据包，保证实时响应。</span><br><span class="line"></span><br><span class="line">资源限制：如果系统资源（如内存、带宽）有限，选择多次发送小数据包能更好地节省资源。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第三章课后习题答案"><a href="#第三章课后习题答案" class="headerlink" title="第三章课后习题答案"></a>第三章课后习题答案</h2><ol>
<li><p>IP地址族IPv4和IPv6有何区别？在何种背景下诞生了IPv6?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPV4是4字节地址族，IPV6是16字节地址族。</span><br><span class="line"></span><br><span class="line">IPV6的诞生是为了应对2010年前后IP地址耗尽的问题而提出的标准</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过IPV4网络ID、主机ID及路由器的关系说明向公司局域网中的计算机传输数据的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先数据传输的第一个环节是向目标IP所属的网络传输数据。此时使用的是IP地址中的网络ID。</span><br><span class="line">传输的数据将被传到管理网络的路由器，接受数据的路由器将参照IP地址的主机号找自己保存的路由表，找到对应的主机发送数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>套接字地址分为IP地址和端口号。为什么需要IP地址和端口号？或者说，通过IP可以区分哪些对象？通过端口号可以区分哪些对象？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP地址是为了区分网络上的主机。</span><br><span class="line"></span><br><span class="line">端口号是区分同一主机下的不同的SOCKET，以确保软件准确收发数据。</span><br></pre></td></tr></table></figure>
</li>
<li><p>IP地址分类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A类地址：1.0.0.0 到 126.255.255.255</span><br><span class="line">B类地址：128.0.0.0 到 191.255.255.255</span><br><span class="line">C类地址：192.0.0.0 到 223.255.255.255</span><br><span class="line">D类地址：224.0.0.0 到 239.255.255.255（组播地址）</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算机通过路由器或交换机连接到互联网。请说出路由器和交换机的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">路由器是帮助数据传输到目的地的中介。</span><br><span class="line"></span><br><span class="line">不仅如此，还起到帮助连接本地网络的电脑和互联网的作用</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是知名端口？其范围是多少？知名端口中具有代表性的HTTP合同FTP端口号各是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“知名端口(Well-known PROT)”是指预定分配给特定操作的端口。</span><br><span class="line"></span><br><span class="line">其范围是0~1023，其中最知名的端口是HTTP:80端口和TCP:21</span><br></pre></td></tr></table></figure>
</li>
<li><p>题目大概意思是：为什么bind中第二个参数是<code>sockaddr</code>，但是传入的是<code>sockaddr_in</code></p>
</li>
</ol>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind函数第二个参数类型是sockaddr结构体，很难份分配IP地址和端口号，因此IP地址和PORT号的分配是通过sockaddr_in完成的。</span><br><span class="line">因为该结构体和sockaddr结构体的组成字节序和大小完全相同，所以可以强转</span><br></pre></td></tr></table></figure>

<ul>
<li>请解释大端序、小端序、网络字节序，并说明为何需要网络字节序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小端序是把高位字节存储到高位地址上；大端序是把高位字节存储到低位地址上。</span><br><span class="line"></span><br><span class="line">因为保存栈的方式有差异，所以对网络传输数据的过程制定了标准，这就是“网路字节序”。</span><br><span class="line"></span><br><span class="line">而且，在网络字节序中，数据传输的标准是“大端序”</span><br></pre></td></tr></table></figure>

<ul>
<li>大端计算机希望将4字节整型数据12传到小端序计算机。请说出数据传输过程中发生的字节序变换过程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为网络字节序的顺序标准是“大端序”，所以大端序的计算机在网络传输中不需要先转换字节顺序，直接传输。</span><br><span class="line"></span><br><span class="line">但是接受数据的是小端序计算机，因此，要经过网络转本地序的过程，再保存到存储设备上</span><br></pre></td></tr></table></figure>

<ul>
<li>怎么表示回送地址？其含义是什么？如果向回送地址传输数据将会发生什么情况？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">回送地址表示计算机本身，为127.0.0.1。</span><br><span class="line"></span><br><span class="line">因此，如果将数据传送到IP地址127.0.0.1，数据会不会通过传输到网络的其他设备上而直接返回。</span><br></pre></td></tr></table></figure>

<h2 id="第四章课后习题答案"><a href="#第四章课后习题答案" class="headerlink" title="第四章课后习题答案"></a>第四章课后习题答案</h2><ul>
<li>请说明TCP&#x2F;IP的4层协议栈，并说明TCP和UDP套接字经过的层级结构差异</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链路层—&gt;IP层—&gt;TCP层—&gt;应用层</span><br><span class="line"></span><br><span class="line">链路层—&gt;IP层—&gt;UDP层—&gt;应用层</span><br></pre></td></tr></table></figure>



<ul>
<li>请说出TCP&#x2F;IP协议栈中链路层和IP层的作用，并给出两者关系。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链路层是LAN、WAN、MAN等网络标准相关的协议栈，是定义物理性质标准的层级。</span><br><span class="line"></span><br><span class="line">相反，IP层是定义网络传输数据标准的层级。即IP层负责以链路层为基础的数据传输</span><br></pre></td></tr></table></figure>

<ul>
<li>为何需要把TCP&#x2F;IP协议栈分成4层（或7层）？结合开放式系统回答</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将复杂的TCP/IP协议分层化的话，就可以将分层的层级标准发展成开放系统。</span><br><span class="line"></span><br><span class="line">实际上，TCP/IP是开放系统，各层级都被初始化，并以该标准为依据组成了互联网。</span><br><span class="line"></span><br><span class="line">因此，按照不同层级标准，硬件和软件可以相互替代，这种标准化是TCP/IP蓬勃发张的依据</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端调用connect函数向服务器端发送连接请求。服务器端调用哪个函数后，客户端可以调用connect函数？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen函数，客户端才可以调用connect函数</span><br></pre></td></tr></table></figure>

<ul>
<li>什么时候创建连接请求等待队列？它有何作用？与accept有什么关系</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen函数的调用创建了请求等待队列。它是存储客户端连接请求信息的空间。</span><br><span class="line"></span><br><span class="line">accept函数调用后，将从本地存储的连接请求信息取出，与客户端建立连接。</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端中为何不需要调用bind函数分配地址？如果不调用bind函数，那何时、如何向套接字分配IP地址和端口号？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端是请求连接的程序，不是一个接收连接的程序。所以，指导服务器的地址信息是更重要的因素，没有必要通过bind函数明确地分配地址信息。</span><br><span class="line"></span><br><span class="line">但是，要想和服务器通信，必须将自己的地址信息分配到套接字上，因此，在connect函数调用时，自动把IP地址和端口号输入到套接字上</span><br></pre></td></tr></table></figure>

<h2 id="第五章课后习题答案"><a href="#第五章课后习题答案" class="headerlink" title="第五章课后习题答案"></a>第五章课后习题答案</h2><ul>
<li>请说明TCP套接字连接设置的三次握手过程。尤其是3次数据交换过程每次收发的数据内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A -》 B（提出连接申请 SYN）</span><br><span class="line"></span><br><span class="line">B -》 A（接受并回复 SYN + ACK）</span><br><span class="line"></span><br><span class="line">A -》 B（回复收到 ACK）</span><br></pre></td></tr></table></figure>

<ul>
<li>TCP是可靠的数据传输协议，但在通过网络通信的过程可能丢失数据。请通过ACK和SEQ说明TCP通过何种机制保证丢失数据的可靠传输。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SEQ顺序标识符是给信息编号。</span><br><span class="line"></span><br><span class="line">ACK是用于回复带有编号的信息</span><br><span class="line"></span><br><span class="line">也就是说，每次传输信息时，都同时发送SEQ标识，而受到信息的主机应以SEQ信息为基础回复发送信息的主机。</span><br><span class="line"></span><br><span class="line">通过这种机制，传输数据的主机就可以确认数据是否被正确接收。在传输失败时，可以重新传送。</span><br></pre></td></tr></table></figure>



<ul>
<li>TCP套接字中调用write和read函数时数据如何移动？结合I&#x2F;O缓冲进行说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当write函数被调用时，数据就会向端口的输出缓冲区移动。</span><br><span class="line"></span><br><span class="line">然后经过网络传输传输到对方主机套接字的输入缓冲。这样，输入缓冲中存储的数据通过read函数的响应来读取</span><br></pre></td></tr></table></figure>

<ul>
<li>对方主机的输入缓冲剩余50字节空间时，若本方主机通过write函数请求传输70字节，问TCP如何处理这种情况？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对方主机会把输入缓冲中可存储的数据大小传送给要传输数据的数据（本方）。</span><br><span class="line"></span><br><span class="line">因此，在剩余空间为50字节的情况，即使要求传送70字节的数据，也不能传输50字节以上，剩余的部分保存在传输方的输出缓冲中，等待对方主机的输入缓冲出现空间。</span><br><span class="line"></span><br><span class="line">而且，这种交换缓冲多余空间信息的协议被称为滑动窗口协议</span><br></pre></td></tr></table></figure>

<h2 id="第六章课后习题答案"><a href="#第六章课后习题答案" class="headerlink" title="第六章课后习题答案"></a>第六章课后习题答案</h2><ol>
<li><p>UDP为什么比TCP速度快？为什么TCP数据传输可靠而UDP数据传输不可靠？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UDP和TCP不同，不进行流量控制。</span><br><span class="line">由于该控制涉及到套接字的连接和结束，以及整个数据收发过程，因此，TCP传输的数据是可以信赖的。相反,UDP不进行这种控制，因此无法信任数据的传输，</span><br><span class="line">但正因UDP不进行流量控制，所以比TCP更快</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面不属于UDP特点的是？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">利用UDP进行传输的时候，如果有两个目标字，则需要两个套接字</span><br><span class="line"></span><br><span class="line">UDP套接字中无法使用已分配给TCP的同一端口号</span><br><span class="line"></span><br><span class="line">UDP变已连接后也需要三次握手</span><br></pre></td></tr></table></figure>
</li>
<li><p>UDP数据包向对方主机的UDP套接字传递过程中，IP和UDP分别负责哪些部分？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP负责链路选择。</span><br><span class="line"></span><br><span class="line">UDP负责端到端的传输</span><br></pre></td></tr></table></figure>
</li>
<li><p>UDP一般比TCP快，但根据交换数据的特点，其差异可大可小。请说明何种情况下UDP的性能优于TCP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UDP与TCP不同，不经过连接以及断开SOCKET的过程；</span><br><span class="line"></span><br><span class="line">因此，在频繁的连接及断开的情况下，UDP的数据收发能力会凸显出更好的性能。</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端TCP套接字调用connect函数时自动分配IP和端口号。UDP中不调用bind函数，那何时分配IP和端口号？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首次调用sendto函数时，发现尚未分配信息，则给相应的套接字自动分配IP和端口号</span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP客户端必须调用connect函数，而UDP中可以选择性调用。请问，在UDP中调用connect函数有哪些好处？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">每当以UDP套接字为对像调用sendto函数时，都要经过以下过程</span><br><span class="line"></span><br><span class="line">- 第一阶段：为目标UDP注册端口和IP</span><br><span class="line">- 第二阶段：数据传输</span><br><span class="line">- 第三阶段：删除UDP注册的IP和端口信息</span><br><span class="line"></span><br><span class="line">其中，只要调用connect函数，就可以忽略每次传输数据时反复进行的第一阶段和第三阶段。</span><br><span class="line"></span><br><span class="line">然而，调用connect函数并不意味着经过连接过程，只是将IP地址和端口号指定在UDP的发送对象上。</span><br><span class="line"></span><br><span class="line">这样connect函数使用后，还可以用write、read函数进行数据处理，而不必使用sendto、recvfrom</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第七章课后习题"><a href="#第七章课后习题" class="headerlink" title="第七章课后习题"></a>第七章课后习题</h2><ol>
<li><p>解释TCP中“流”的概念。UDP中能否形成流？请说明原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP的流指，两台主机通过套接字建立连接后进入可交换数据的状态，也称为“流形成的状态”。</span><br><span class="line"></span><br><span class="line">而对于UDP来说，不存在流，因为两个SOCKET不能相互连接</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux中的close函数或Windows中的<code>closesocket</code>函数属于单方面断开连接的方法，有可能带来一些问题。什么是单方面断开连接？什么情况下会出现问题？</p>
<p>单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方面的断开连接意味着套接字无法再发送数据。</span><br><span class="line"></span><br><span class="line">一般在对方有剩余数据为发送完成时，断开己方连接，会造成问题。</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是半关闭？针对输出流执行半关闭的主机处于何种状态？半关闭会导致对方主机接收什么信息？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半关闭是指只完成输入和输出流中的一个。</span><br><span class="line"></span><br><span class="line">如果对输出流进行半关闭，EOF无法被传送到对方主机，己方套接字无法传送数据，但可以接收对方主机传送的数据。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第八章课后习题"><a href="#第八章课后习题" class="headerlink" title="第八章课后习题"></a>第八章课后习题</h2><p>略（太简单了）</p>
<h2 id="第九章课后习题"><a href="#第九章课后习题" class="headerlink" title="第九章课后习题"></a>第九章课后习题</h2><ol>
<li><p>下列关于Time-wait状态的说法错误的是？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time-wait状态只在服务器端出现</span><br><span class="line"></span><br><span class="line">time-wait状态与断开连接的过程无关，而与请求连接中发送的SYN消息有关</span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP_NODELAY可选项与Nagle算法有关，可通过它禁止Nagle算法。请问何时应考虑禁用Nagle算法？结合收发数据的特性给出说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据传输数据的特性，网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快。例如“传输大文件数据”。将文件数据传入输出缓冲不会花太多时间，因此，即便不使用Nagle算法那，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而会在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第十章课后习题"><a href="#第十章课后习题" class="headerlink" title="第十章课后习题"></a>第十章课后习题</h2><ul>
<li><p>下列关于进程的说法错误的是？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进程可以包括其他进程，即一个进程的内存空间还可以包含其他的进程</span><br><span class="line"></span><br><span class="line">子进程可以创建其他的子进程，而创建出来的子进程还可以创建其他的子进程，但所有的进程只与一个父进程建立父子关系</span><br><span class="line">（进程是颗树）</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用fork函数将创建子进程，以下关于子进程描述错误的是？acd(a选项我测试过，真的不会销毁)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">父进程销毁时会同时销毁子进程</span><br><span class="line">（当父进程结束时，子进程会成为孤儿进程，并由 init 进程（或在现代系统中，由 systemd 或类似的系统进程）收养）</span><br><span class="line"></span><br><span class="line">子进程是复制父进程所有资源创建出的进程</span><br><span class="line">（只有在父进程或子进程试图修改这些资源时，系统才会实际进行复制。）</span><br><span class="line"></span><br><span class="line">通过fork创建的子进程将执行从开始到fork调用为止的代码</span><br><span class="line">（子进程从 fork 调用后的代码开始执行）</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建子进程时将复制父进程的所有内容，此时的复制对象也包含套接字文件描述符。复制的文件描述符整数值是否与原文件描述符整数值相同？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是</span><br></pre></td></tr></table></figure>
</li>
<li><p>请说明进程变为僵尸进程的过程及预防措施</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">僵尸进程是子进程。</span><br><span class="line"></span><br><span class="line">在子进程结束时，其返回值会传到操作系统，直到返回值被其父进程接收为止，该（子）进程会一直作为僵尸进程存在。</span><br><span class="line"></span><br><span class="line">所以，为了防止这种情况的发生，父进程必须明确接收子进程结束时的返回值。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第十一章课后习题"><a href="#第十一章课后习题" class="headerlink" title="第十一章课后习题"></a>第十一章课后习题</h2><ol>
<li><p>什么是进程间通信？分别从概念和内存的角度进行说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概括性地说，进程间通信是指两个进程之间交换数据。</span><br><span class="line"></span><br><span class="line">但是从内存的角度看，可以理解为两个进程共有内存。因为共享的内存区域存在，可以进行数据交换</span><br></pre></td></tr></table></figure>
</li>
<li><p>进程间通信需要特殊的IPC机制，这是由操作系统提供的。进程间通信时为何需要操作系统的帮助？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要想实现IPC机制，需要共享的内存，</span><br><span class="line"></span><br><span class="line">但由于两个进程之间不共享内存，因此需要操作系统的帮助，也就是说，两进程共享的内存空间必须由操作系统来提供</span><br></pre></td></tr></table></figure>



<p><strong>IPC：Inter-Process Communucation ： 进程之间的通信</strong></p>
</li>
<li><p>“管道”是典型的IPC技术。关于管道，请回答如下问题。</p>
<ul>
<li><p>管道是进程间交换数据的路径。如何创建该路径?由谁创建？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">管道是由pip函数产生的，而实际产生管道的主体是操作系统</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了完成进程间通信，2个进程需同时连接管道。那2个进程如何连接到同一管道？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipe函数通过输入参数返回管道的输入输出文件描述符。</span><br><span class="line"></span><br><span class="line">这个文件描述符在fork函数中复制到了其子进程，因此，父进程和子进程可以同时访问同一管道。</span><br></pre></td></tr></table></figure>
</li>
<li><p>管道允许进行2个进程间的双向通信。双向通信中需要注意哪些内容？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">管道并不管理进程间的数据通信。因此，如果数据流入管道，任何进程都可以读取数据。因此，要合理安排共享空间的输入和读取</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="第十二章课后习题答案"><a href="#第十二章课后习题答案" class="headerlink" title="第十二章课后习题答案"></a>第十二章课后习题答案</h2><ol>
<li><p>请解释复用技术的通用含义，并说明何为I&#x2F;O复用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复用技术指为了提高物理设备的效率，用最少的物理要素传递最多数据时使用的技术。</span><br><span class="line"></span><br><span class="line">同样，I/O复用是指将需要I/O的套接字捆绑在一起，利用最少限度的资源来收发数据的技术</span><br></pre></td></tr></table></figure>
</li>
<li><p>多进程并发服务器的缺点有哪些？如何在I&#x2F;O复用服务器端中弥补？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多进程并发服务器的服务方式是，每当客户端提出连接要求时，就会追加生成进程。</span><br><span class="line"></span><br><span class="line">但构建进程是一项非常有负担的工作，因此，向众多客户端提供服务存在一定的局限性。</span><br><span class="line"></span><br><span class="line">而复用服务器则是将套接字的文件描述符捆绑在一起管理的方式，因此可以一个进程管理所有的I/O操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>下列select中描述错误的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若已通过select 注册成为监视对象，则后序调用select时无需重复注册</span><br><span class="line"></span><br><span class="line">复用服务器同一时间只能服务一个客户端，因此需要服务的客户端接入服务器端后只能等待</span><br></pre></td></tr></table></figure>


</li>
<li><p>select函数的观察对象中应包含服务器端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器套接字的作用是监听有无连接请求，即判断接收的连接请求是否存在</span><br><span class="line"></span><br><span class="line">应该将其包含到“读”类监听对象的集合中</span><br></pre></td></tr></table></figure>
</li>
<li><p>select函数使用的fd_set结构体在Windows和Linux中具有不同的声明。请说明却别，同时解释存在区别的必然性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux的文件描述符从0开始递增，因此可以找出当前文件描述符数量和最后生成的文件描述符之间的关系。</span><br><span class="line"></span><br><span class="line">但Windows的套接字句柄并非从0开始，并且句柄的整数值之间并无规律可循，因此需要直接保存句柄的数组和记录句柄数的变量</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第十三章答案"><a href="#第十三章答案" class="headerlink" title="第十三章答案"></a>第十三章答案</h2><ol>
<li><p>下面关于MSG_OOB可选项的说法错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MSG_OOB 指通过其他路径高速传输数据，因此 TCP中设置该选项数据先到达对方主机</span><br><span class="line"></span><br><span class="line">MSGOOB只是提高了传输速度，接受方无法识别</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用readv&amp;writev函数收发数据有何优点？分别从函数调用次数和I&#x2F;O缓冲的角度给出说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readv&amp;writev函数可以将分散保存在多个缓冲中的数据一并接受和发送，是对数据进行整合传输及发送的函数，因此可以进行更有效的数据传输。</span><br><span class="line"></span><br><span class="line">而且，输入输出函数的调用次数也相应减少，也会产生相应的优势</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过recv函数见证输入缓冲是否存在数据时（确认后立即返回），如何设置recv函数最后一个参数中的可选项？分别说明各可选项的含义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同时设置MSG_PEEK选项和MSG_DONTWAIT选项，以验证输入缓冲是否存在可接收的数据。</span><br><span class="line"></span><br><span class="line">设置MSG_PEEK选项并调用recv函数时，即使读取了输入缓冲数据也不会删除。</span><br><span class="line"></span><br><span class="line">因此，该选项通常与MSG_DONTWAIT合作，用于调用以非阻塞方式验证待读数据存在与否的函数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>可在Linux平台通过注册时间处理函数接收MSG_OOB数据。那Windows中如何接受？请说明接收方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSG_OOB数据的接收，在select函数中属于异常数据，既在Windows中可以通过异常处理来接收Out-of-band数据</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第十四章答案"><a href="#第十四章答案" class="headerlink" title="第十四章答案"></a>第十四章答案</h2><ol>
<li><p>TTL的含义是什么？请从路由器的角度说明较大的TTL值与较小的TTL值之间的区别及问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TTL是Time to Live的缩写，是决定“信息传递距离”的主要因素。</span><br><span class="line"></span><br><span class="line">TTL表现为整数，没经过一个路由器就减1。如果该值为0，该数据报就会因无法再传递而消失。</span><br><span class="line"></span><br><span class="line">TTL设置大了会对网络流量造成不良影响，设置太小的话，就可能无法到达目的地</span><br></pre></td></tr></table></figure>
</li>
<li><p>多播和广播的异同是什么？请从数据通信的角度进行说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多播和广播的相同点是，两者都是以UDP形式传输数据。一次传输数据，可以向两个以上主机传送数据。</span><br><span class="line"></span><br><span class="line">但传送的范围是不同的：广播是对局域网的广播；而多播是对网络注册机器的多播</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是错误的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多播无法跨越多个网络</span><br><span class="line"></span><br><span class="line">只能够有一个主机向多播组发送数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>多播也对网络流量有利，请比较TCP数据交换方式解释其原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多播数据在路由器进行复制。因此，即使主机数量很多，如果各主机存在的相同路径，也可以通过一次数据传输到多台主机上。</span><br><span class="line"></span><br><span class="line">但TCP无论路径如何，都要根据主机数量进行数据传输。</span><br></pre></td></tr></table></figure>
</li>
<li><p>多播方式的数据通信需要MBone虚拟网络。换言之，MBone是用于多播的网络，但它是虚拟网络。请解释此处“虚拟网络”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以物理网络为基础，通过软件方法实现的多播通信必备的虚拟网络</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第十五章答案"><a href="#第十五章答案" class="headerlink" title="第十五章答案"></a>第十五章答案</h2><ul>
<li>说明标准I&#x2F;O函数的2个优点。它为何拥有这2个优点？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可移植性强 ： 基于ANSIX标准具有良好的一致性</span><br><span class="line"></span><br><span class="line">性能更高 ： 可以利用缓冲提高性能</span><br></pre></td></tr></table></figure>

<ul>
<li>标准IO中，“调用fputs函数传输数据时，调用后应立即开始发送！”，为何这种想法是错误的？为了达到这种效果应添加哪些处理过程？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过标准输出函数的传输的数据不直接通过套接字的输出缓冲区发送，而是保存在标准输出函数的缓冲中，然后再用fflush函数进行输出。</span><br><span class="line"></span><br><span class="line">因此，即使调用“fputs&quot;函数，也不能立即发送数据。如果想保障数据传输的时效性，必须经过fflush函数的调用过程</span><br></pre></td></tr></table></figure>

<h2 id="第十七章答案"><a href="#第十七章答案" class="headerlink" title="第十七章答案"></a>第十七章答案</h2><ul>
<li>利用select函数实现服务器端时，代码层面存在的2个缺点是？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用select函数后常见的针对所有文件描述符的循环语句</span><br><span class="line"></span><br><span class="line">每次调用select函数时都需要向该函数传递监视对象信息</span><br></pre></td></tr></table></figure>

<ul>
<li>无论是select方式还是epoll方式，都需要将监视对象文件描述符信息通过函数调用传递给操作系统。请解释传递该信息的原因</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select和epoll是系统函数，准确地说，是要求观察套接字变化的方式的。</span><br><span class="line"></span><br><span class="line">套接字是受操作系统进行管理的。</span><br><span class="line"></span><br><span class="line">既，select和epoll是一个有操作系统执行的函数。因此，应该将监视对象的文件描述符传递给操作系统</span><br></pre></td></tr></table></figure>

<ul>
<li>select方式和epoll方式的最大差异在于监视对象文件描述符传递给操作系统的方式。请说明具体的差异，并解释为何存在这种差异。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoll不同于select的地方是只要将监视对象文件描述符的信息传递一个给操作系统就可以了。</span><br><span class="line"></span><br><span class="line">因此epoll方式克服了select方式的缺点，体现在linux内核上保存监视对象信息的方式。</span><br></pre></td></tr></table></figure>

<ul>
<li>虽然epoll是select的改进方式，但select也有自己的缺点。在何种情况下使用select方式更合理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果连接服务器的人数不多（不需要高性能），而且需要在多种操作系统（windows和linux）下进行操作，在兼容性方面，使用select会比epoll更合理</span><br></pre></td></tr></table></figure>

<ul>
<li>epoll以条件触发或边缘触发方式工作。二者有何区别？从输入缓冲的角度说明这2中方式通知事件的时间点的差异</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在条件触发方式中，只要输入缓冲有数据，就会持续进行事件通知；</span><br><span class="line"></span><br><span class="line">而在边缘触发中，只有当输入缓冲数据为空时才进行通知</span><br></pre></td></tr></table></figure>

<ul>
<li>采用边缘触发时可以分离数据的接收和处理时间点。说明其原因及优点。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果使用边缘触发方式，在输入缓冲中接收数据时，只会发生一次事件通知，而且输入缓冲中仍有数据时，不会进行通知，因此可以在数据被接收后，在想要的时间内处理数据。</span><br><span class="line"></span><br><span class="line">而且，如果分离数据的接收和处理时间点，在服务器中会有更大的灵活性</span><br></pre></td></tr></table></figure>

<h2 id="第十八章答案"><a href="#第十八章答案" class="headerlink" title="第十八章答案"></a>第十八章答案</h2><ul>
<li>单CPU系统中如何同时执行多个进程？请解释该过程中发生的上下文切换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为系统将CPU切分成多个微小的块后分配给多个进程，为了分时使用CPU,需要”上下文切换“过程。”</span><br><span class="line"></span><br><span class="line">上下文切换“是指，在CPU改变运行对象的过程中，执行准备的过程将之前执行的进程数据从换出内存，并将待执行额进程数据传到内存的工作区域</span><br></pre></td></tr></table></figure>

<ul>
<li>为何线程的上下文切换速度相对更快？线程间数据交换为何不需要类似IPC的特别技术？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为线程进行上下文切换时不需要切换数据区和堆区。同时，可以利用数据区和堆区进行数据交换</span><br></pre></td></tr></table></figure>

<ul>
<li>请从执行流角度说明进程和线程的区别</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程：在操作系统中构成单独执行流的单位</span><br><span class="line">线程：在进程内构成单独执行流的单位</span><br></pre></td></tr></table></figure>

<ul>
<li><p>下面关于临界区说法错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程安全的函数不存在临界区，即便多个线程同时调用也不会发生问题</span><br><span class="line"></span><br><span class="line">1个临界区只能有一个代码块构成，而非多个代码块，换言之线程A的代码块A和线程B的代码块B绝对不会有临界区</span><br><span class="line"></span><br><span class="line">临界区由访问全局变量的代码构成，其他变量不会出问题</span><br></pre></td></tr></table></figure>


</li>
<li><p>下面关于线程同步描述错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程同步是代替进程IPC的技术</span><br></pre></td></tr></table></figure>
</li>
<li><p>请说明完全销毁Linux线程的两种方法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_join函数和pthread_detach函数</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/21/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="prev" title="后端基础">
      <i class="fa fa-chevron-left"></i> 后端基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/09/21/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="next" title="线程池">
      线程池 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%88TCP-IP%E7%BC%96%E7%A8%8B%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">网络是如何连接的（TCP&#x2F;IP编程）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A4%A7%E8%87%B4%E6%A6%82%E6%8B%AC"><span class="nav-number">1.1.</span> <span class="nav-text">一、网络连接的大致概括</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81dns%E8%A7%A3%E6%9E%90"><span class="nav-number">1.1.0.0.0.1.</span> <span class="nav-text">1、dns解析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81socket%EF%BC%88%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%89%E5%88%9B%E5%BB%BA"><span class="nav-number">1.1.0.0.0.2.</span> <span class="nav-text">2、socket（套接字）创建</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.1.0.0.0.3.</span> <span class="nav-text">3、服务器连接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E5%8F%97"><span class="nav-number">1.1.0.0.0.4.</span> <span class="nav-text">4、数据的发送与接受</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.1.0.0.0.5.</span> <span class="nav-text">5、断开连接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%EF%BC%9A%E5%9C%A8ubuntu%E4%B8%8B%E7%9A%84dns%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">1.1.0.0.0.6.</span> <span class="nav-text">追加：在ubuntu下的dns解析器的调用</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TPC-IP%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">TPC&#x2F;IP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81hello%EF%BC%88TCP%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">1、hello（TCP）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E7%89%88%E6%9C%AC"><span class="nav-number">2.1.1.</span> <span class="nav-text">linux版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#win%E7%89%88%E6%9C%AC"><span class="nav-number">2.1.2.</span> <span class="nav-text">win版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%9B%9E%E5%A3%B0%EF%BC%88UDP%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">2、回声（UDP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81DNS%E8%A7%A3%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">3、DNS解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B-I-O-%E5%88%86%E5%89%B2"><span class="nav-number">2.4.</span> <span class="nav-text">4、并发服务器(多线程 + I &#x2F;O 分割)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.4.1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#zombie%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">zombie进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8waitpid%E9%98%B2%E6%AD%A2%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">使用waitpid防止僵尸进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">综合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E4%B8%BAI-O%E5%88%86%E5%89%B2%EF%BC%9A"><span class="nav-number">2.4.2.</span> <span class="nav-text">何为I&#x2F;O分割：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">管道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B-I-O%E5%A4%8D%E7%94%A8%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">5、并发服务器（多线程+ I &#x2F;O复用）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E4%B8%BAIO%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="nav-number">2.5.1.</span> <span class="nav-text">何为IO复用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Select%E7%9B%91%E8%A7%86%E4%BA%8B%E4%BB%B6%EF%BC%88event%EF%BC%89"><span class="nav-number">2.5.2.</span> <span class="nav-text">Select监视事件（event）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">2.5.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B7IO%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.</span> <span class="nav-text">多样IO函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MSG-OOB%E4%B8%8ETCP%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.7.</span> <span class="nav-text">MSG_OOB与TCP紧急模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-MSG-OOB-Out-of-Band-Data"><span class="nav-number">2.7.1.</span> <span class="nav-text">1. MSG_OOB (Out-of-Band Data)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TCP-%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%EF%BC%88TCP-Urgent-Mode%EF%BC%89"><span class="nav-number">2.7.2.</span> <span class="nav-text">2. TCP 紧急模式（TCP Urgent Mode）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-MSG-OOB-%E4%B8%8E-TCP-%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.7.3.</span> <span class="nav-text">3. MSG_OOB 与 TCP 紧急模式的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.7.4.</span> <span class="nav-text">4. 优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.7.5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">2.7.6.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD%E4%B8%8E%E5%B9%BF%E6%92%AD"><span class="nav-number">2.8.</span> <span class="nav-text">多播与广播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.8.1.</span> <span class="nav-text">多播实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.8.2.</span> <span class="nav-text">广播实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll"><span class="nav-number">2.9.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">2.9.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91"><span class="nav-number">2.9.2.</span> <span class="nav-text">条件触发与边缘触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.9.3.</span> <span class="nav-text">边缘触发实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.10.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9A"><span class="nav-number">2.10.1.</span> <span class="nav-text">线程和进程的差异：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">2.10.2.</span> <span class="nav-text">进程和线程的定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="nav-number">2.10.3.</span> <span class="nav-text">操作系统与进程、线程的关系：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.10.4.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">2.10.5.</span> <span class="nav-text">互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%971-10%E7%9A%84%E5%92%8C"><span class="nav-number">2.10.5.1.</span> <span class="nav-text">应用：利用多线程计算1-10的和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.10.6.</span> <span class="nav-text">信号量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.11.</span> <span class="nav-text">线程的销毁和多线程并发服务器端的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="nav-number">2.12.</span> <span class="nav-text">聊天室</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84WEB%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA"><span class="nav-number">2.13.</span> <span class="nav-text">基于TCP协议的WEB服务器搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#http%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">2.13.1.</span> <span class="nav-text">http特点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.13.2.</span> <span class="nav-text">请求格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">2.13.3.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">课后习题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">3.1.</span> <span class="nav-text">第一章课后习题答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">3.2.</span> <span class="nav-text">第二章课后习题答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">3.3.</span> <span class="nav-text">第三章课后习题答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">3.4.</span> <span class="nav-text">第四章课后习题答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">3.5.</span> <span class="nav-text">第五章课后习题答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">3.6.</span> <span class="nav-text">第六章课后习题答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="nav-number">3.7.</span> <span class="nav-text">第七章课后习题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="nav-number">3.8.</span> <span class="nav-text">第八章课后习题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="nav-number">3.9.</span> <span class="nav-text">第九章课后习题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="nav-number">3.10.</span> <span class="nav-text">第十章课后习题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="nav-number">3.11.</span> <span class="nav-text">第十一章课后习题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">3.12.</span> <span class="nav-text">第十二章课后习题答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E7%AD%94%E6%A1%88"><span class="nav-number">3.13.</span> <span class="nav-text">第十三章答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E7%AD%94%E6%A1%88"><span class="nav-number">3.14.</span> <span class="nav-text">第十四章答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E7%AD%94%E6%A1%88"><span class="nav-number">3.15.</span> <span class="nav-text">第十五章答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%E7%AD%94%E6%A1%88"><span class="nav-number">3.16.</span> <span class="nav-text">第十七章答案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%E7%AD%94%E6%A1%88"><span class="nav-number">3.17.</span> <span class="nav-text">第十八章答案</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AlexQFMM"
      src="/images/Avatar.jpg">
  <p class="site-author-name" itemprop="name">AlexQFMM</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://qexo-ten-roan.vercel.app/" title="控制中心 → https:&#x2F;&#x2F;qexo-ten-roan.vercel.app&#x2F;" rel="noopener" target="_blank">控制中心</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AlexQFMM</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'UaEUwcYLlkREnSn9jPNe0oRf-gzGzoHsz',
      appKey     : '5d7KwGdf31jiCBxBobH0wVk6',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/miku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
