<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="常见数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="常见数据结构">
<meta property="og:url" content="http://example.com/2024/03/23/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="AlexHome">
<meta property="og:description" content="常见数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-23T19:28:45.000Z">
<meta property="article:modified_time" content="2024-12-01T13:58:43.018Z">
<meta property="article:author" content="AlexQFMM">
<meta property="article:tag" content="力扣">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/03/23/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>常见数据结构 | AlexHome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">AlexHome</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
        <li class="menu-item menu-item-mypage">

    <a href="/MYHTML/test/index.html" rel="section"><i class="fas fa-file-user fa-fw"></i>myPage</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/23/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.jpg">
      <meta itemprop="name" content="AlexQFMM">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AlexHome">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          常见数据结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-23 19:28:45" itemprop="dateCreated datePublished" datetime="2024-03-23T19:28:45+00:00">2024-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-01 13:58:43" itemprop="dateModified" datetime="2024-12-01T13:58:43+00:00">2024-12-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8A%9B%E6%89%A3/" itemprop="url" rel="index"><span itemprop="name">力扣</span></a>
                </span>
            </span>

          
            <span id="/2024/03/23/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-meta-item leancloud_visitors" data-flag-title="常见数据结构" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/03/23/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/03/23/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h1><span id="more"></span>

<h1 id="特殊、数组-集合"><a href="#特殊、数组-集合" class="headerlink" title="特殊、数组&#x2F;集合"></a>特殊、数组&#x2F;集合</h1><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>特点：连续的空间</p>
<p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int n[10];</span><br><span class="line">int n[10][10]//死空间</span><br><span class="line"></span><br><span class="line">int* n = (int*)malloc(sizeof(int) * 10);</span><br><span class="line">int** n = (int**)malloc(10 * sizeof(int*)); // 分配行指针数组</span><br><span class="line">for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    n[i] = (int*)malloc(10 * sizeof(int)); // 分配每行的列数</span><br><span class="line">&#125;//指针,可改变大小,但需要手动释放</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;n;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;n//容器，动态大小，方便</span><br></pre></td></tr></table></figure>

<p>常用方法（ vector）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push_back(val);</span><br><span class="line">pop_back();</span><br><span class="line">sort(n.begin(),n.end());</span><br></pre></td></tr></table></figure>

<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h6 id="set"><a href="#set" class="headerlink" title="set"></a>set</h6><p>在内部使用红黑树等数据结构来维护元素的顺序，是一种有序集合。</p>
<p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; mySet</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find(val)</span><br><span class="line">insert(val)</span><br><span class="line">erase(val) //删除</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br></pre></td></tr></table></figure>

<h6 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h6><p>允许 重复元素存在</p>
<p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;int&gt; multiSet</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1、力扣704-二分查找（双指针）"><a href="#1、力扣704-二分查找（双指针）" class="headerlink" title="1、力扣	704 二分查找（双指针）"></a>1、力扣	704 二分查找（双指针）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p>解法：没啥好说的，记就完事了</p>
<p>注意开闭的区别</p>
<p>开区间的left和right就直接等于mid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left =0;</span><br><span class="line">        int right = nums.size()-1;</span><br><span class="line"></span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            int mid = (left+right)/2;</span><br><span class="line">            if(nums[mid] == target) return mid;</span><br><span class="line">            else if(nums[mid] &lt; target) left = mid+1;</span><br><span class="line">            else right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、力扣-27-移除元素（双指针）"><a href="#2、力扣-27-移除元素（双指针）" class="headerlink" title="2、力扣 27 移除元素（双指针）"></a>2、力扣 27 移除元素（双指针）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>

<p>解法：双指针</p>
<p>定义一个快指针用来遍历，一个慢指针用来存放结果</p>
<p>如果快指针指到的元素是我们需要的，慢指针就存放快指针当前存放的元素，并且向前进一步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int slow =0;</span><br><span class="line">        for(int fast=0;fast&lt;nums.size();fast++)&#123;</span><br><span class="line">            if(nums[fast]!=val) nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、力扣-977-有序数组的平方（双指针）"><a href="#3、力扣-977-有序数组的平方（双指针）" class="headerlink" title="3、力扣 977 有序数组的平方（双指针）"></a>3、力扣 977 有序数组的平方（双指针）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>定义头尾双指针，还需要一个存放用的指针</p>
<p>因为在本题中是已经有序的带负数的数组，那么它平方后的趋势就是头尾大，中间小</p>
<p>所以我们可以用两个指针一头一尾，判定，将大的存放到ans后面，存放过的指针就–，小的不动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int head=0;</span><br><span class="line">        int tail = nums.size()-1;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt;ans(tail+1);</span><br><span class="line">        int ans_tail = tail;</span><br><span class="line"></span><br><span class="line">        while(ans_tail &gt;=0 )&#123;</span><br><span class="line">            int num1 = nums[head]*nums[head];</span><br><span class="line">            int num2 = nums[tail]*nums[tail];</span><br><span class="line">            if(num1 &gt; num2)&#123;</span><br><span class="line">                ans[ans_tail] = num1;</span><br><span class="line">                head++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ans[ans_tail] = num2;</span><br><span class="line">                tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans_tail--;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、-力扣-209-长度最小的子数组（滑动窗口）"><a href="#4、-力扣-209-长度最小的子数组（滑动窗口）" class="headerlink" title="4、 力扣 209 长度最小的子数组（滑动窗口）"></a>4、 力扣 209 长度最小的子数组（滑动窗口）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 target 。</span><br><span class="line"></span><br><span class="line">找出该数组中满足其总和大于等于 target 的长度最小的 连续</span><br><span class="line">子数组</span><br><span class="line"> [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>注意审题，这题要求的是大于等于</p>
<p>这题可以用到一个滑动窗口的思想</p>
<p>从第一个元素开始累加，一直到满足条件为止是第一个长度大小。</p>
<p>此时先将下标定在这里。从开头开始减去元素，看看是否还满足条件。</p>
<p>期间每次操作后都记录长度大小的最小值</p>
<p>如此反复一直到数组末尾即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int right=0;right&lt;nums.size();right++)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            while(sum &gt;= target)&#123;</span><br><span class="line">                ans = min(ans,right-left+1);</span><br><span class="line">                sum-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ans == INT_MAX) return 0;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5、力扣-54-螺旋矩阵（模拟遍历）"><a href="#5、力扣-54-螺旋矩阵（模拟遍历）" class="headerlink" title="5、力扣 54 螺旋矩阵（模拟遍历）"></a>5、力扣 54 螺旋矩阵（模拟遍历）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p>解法：模拟它行走的路程</p>
<p>每次走完后可以理解为缩圈</p>
<p>走完第一行就把第一行剪掉就是了（top++）；</p>
<p>走完最后一列就把最后一列剪掉（right–）；</p>
<p>走完最后一行就把底端剪切（down–）；</p>
<p>走完第一列再把第一列剪除（left++）；</p>
<p>直到上边界遇到下边界，或者左边界碰上右边界</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt;ans;</span><br><span class="line">        if(matrix.empty()) return ans;</span><br><span class="line">        int left =0;</span><br><span class="line">        int top =0;</span><br><span class="line">        int right = matrix[0].size()-1;</span><br><span class="line">        int down = matrix.size()-1;</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            for(int i=left;i &lt;= right;i++)//上边界左到右</span><br><span class="line">                ans.push_back(matrix[top][i]);</span><br><span class="line">            if(++top &gt; down) break;</span><br><span class="line"></span><br><span class="line">            for(int i = top;i&lt;=down;i++)//右边界上到下</span><br><span class="line">                ans.push_back(matrix[i][right]);</span><br><span class="line">            if(--right &lt; left) break;</span><br><span class="line">            </span><br><span class="line">            for(int i=right;i&gt;=left;i--)&#123;//底边界右到左</span><br><span class="line">                ans.push_back(matrix[down][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--down &lt; top) break;</span><br><span class="line"></span><br><span class="line">            for(int i=down;i&gt;=top;i--)&#123;//左边界从下到上</span><br><span class="line">                ans.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++left &gt; right) break;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h1><p>特点：每个结点都有一个指向下一个结点的指针</p>
<p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode* list = new ListNode()</span><br></pre></td></tr></table></figure>

<h2 id="实现（c-中需要手动实现）"><a href="#实现（c-中需要手动实现）" class="headerlink" title="实现（c++中需要手动实现）"></a>实现（c++中需要手动实现）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode &#123;// 定义链表节点结构体</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125; //初始化参数</span><br><span class="line">    </span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;//可选</span><br><span class="line">	ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;//可选</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="在指定位置插入链表"><a href="#在指定位置插入链表" class="headerlink" title="在指定位置插入链表"></a>在指定位置插入链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode* insert(ListNode* head,int val,int index)&#123;</span><br><span class="line">	ListNode* sp_head = new ListNode(0);</span><br><span class="line">	sp_head-&gt;next = head; </span><br><span class="line">	ListNode* newnode = new ListNode(val);</span><br><span class="line">	ListNode* pre = sp_head;</span><br><span class="line">	while(--index &amp;&amp; pre-&gt;next!=nullptr)&#123;</span><br><span class="line">		pre = pre-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	if(index &gt;0 ) return head;</span><br><span class="line">	newnode-&gt;next = pre-&gt;next;</span><br><span class="line">	pre-&gt;next = newnode-&gt;next;</span><br><span class="line">	</span><br><span class="line">	head = sp_head-&gt;next;</span><br><span class="line">    delete sp_head;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="1、力扣-203-移除链表元素"><a href="#1、力扣-203-移除链表元素" class="headerlink" title="1、力扣 203 移除链表元素"></a>1、力扣 203 移除链表元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>加个特殊头节点防止在头节点进行修改，一直遍历到需要删除的结点的前一个结点，直接next &#x3D; next-&gt;next就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode* sp_head = new ListNode(0);</span><br><span class="line">        sp_head-&gt;next = head;</span><br><span class="line">        ListNode* pre = sp_head;</span><br><span class="line">        while(pre-&gt;next)&#123;</span><br><span class="line">            if(pre-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                ListNode* temp = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">                delete temp;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sp_head-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、-力扣-707-设计链表"><a href="#2、-力扣-707-设计链表" class="headerlink" title="2、 力扣 707 设计链表"></a>2、 力扣 707 设计链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">你可以选择使用单链表或者双链表，设计并实现自己的链表。</span><br><span class="line"></span><br><span class="line">单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。</span><br><span class="line"></span><br><span class="line">如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。</span><br><span class="line"></span><br><span class="line">实现 MyLinkedList 类：</span><br><span class="line"></span><br><span class="line">MyLinkedList() 初始化 MyLinkedList 对象。</span><br><span class="line">int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。</span><br><span class="line">void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</span><br><span class="line">void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。</span><br><span class="line">void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。</span><br><span class="line">void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1], [3], [1, 2], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, 2, null, 3]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = new MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(1);</span><br><span class="line">myLinkedList.addAtTail(3);</span><br><span class="line">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 2</span><br><span class="line">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 3</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>​	私有成员一个头节点和一个数量统计，方便在末尾进行修改，添加和删除都遍历到需要元素的前一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList &#123;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int size;</span><br><span class="line">    ListNode *head;</span><br><span class="line">public:</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        this-&gt;size = 0;</span><br><span class="line">        this-&gt;head = new ListNode(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        for (int i = 0; i &lt;= index; i++) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtHead(int val) &#123;</span><br><span class="line">        addAtIndex(0, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtTail(int val) &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        if (index &gt; size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        ListNode *pred = head;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *toAdd = new ListNode(val);</span><br><span class="line">        toAdd-&gt;next = pred-&gt;next;</span><br><span class="line">        pred-&gt;next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void deleteAtIndex(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        ListNode *pred = head;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = pred-&gt;next;</span><br><span class="line">        pred-&gt;next = pred-&gt;next-&gt;next;</span><br><span class="line">        delete p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3、-力扣-206-反转链表"><a href="#3、-力扣-206-反转链表" class="headerlink" title="3、 力扣 206 反转链表"></a>3、 力扣 206 反转链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题解：利用头插法的原理逆序（迭代法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* L2 = new ListNode(0);</span><br><span class="line">        L2-&gt;next = NULL;</span><br><span class="line">        </span><br><span class="line">        while(head)&#123;</span><br><span class="line">            ListNode* temp= new ListNode(head-&gt;val);</span><br><span class="line">            temp-&gt;next = L2-&gt;next;</span><br><span class="line">            L2-&gt;next = temp;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return L2-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<p>原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2-&gt;1-&gt;nullptr </span><br><span class="line"></span><br><span class="line">2-&gt;1-&gt;2</span><br><span class="line"></span><br><span class="line">2-&gt;nullptr</span><br><span class="line"></span><br><span class="line">1-&gt;2-&gt;nullptr</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、-力扣-24-两两交换链表中的元素"><a href="#4、-力扣-24-两两交换链表中的元素" class="headerlink" title="4、 力扣 24 两两交换链表中的元素"></a>4、 力扣 24 两两交换链表中的元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>添加一个特殊头节点，方便在头部进行操作</p>
<p>定义三个指针，</p>
<p>一个用来记录需要交换的两个元素前一个结点（index）</p>
<p>一个用来记录需要交换的第一个结点（first）</p>
<p>一个用来记录第二个结点（second）</p>
<p>每次交换完后，让index向后移动两位 也就是移动到 交换的第一个结点（first）处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        if(head == NULL || head-&gt;next == NULL) return head;</span><br><span class="line">        </span><br><span class="line">        ListNode* null_head = new ListNode(0,head);</span><br><span class="line">        ListNode* index = null_head;</span><br><span class="line">        </span><br><span class="line">        while(index-&gt;next != NULL &amp;&amp; index-&gt;next-&gt;next != NULL)&#123;</span><br><span class="line">            ListNode* first=index-&gt;next;</span><br><span class="line">            ListNode* second=index-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            index-&gt;next = second;</span><br><span class="line">            first-&gt;next = second-&gt;next;</span><br><span class="line">            second-&gt;next = first;</span><br><span class="line">            index = first;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return null_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5、力扣-19-删除链表的倒数第N个结点"><a href="#5、力扣-19-删除链表的倒数第N个结点" class="headerlink" title="5、力扣 19 删除链表的倒数第N个结点"></a>5、力扣 19 删除链表的倒数第N个结点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>定义一个特殊头节点，方便于顶端操作</p>
<p>定义快慢两个指针，当快指针走够n步后，慢指针开始走。当快指针走到末尾，慢指针指向的元素就是第n个元素</p>
<p>为了方便删除，也可以让快指针走到倒数第二个元素，这样慢指针走到的就是第n-1个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        if(!head) return head;</span><br><span class="line">        ListNode* sp_head = new ListNode(0);</span><br><span class="line">        sp_head-&gt;next = head;</span><br><span class="line">        ListNode* slow = sp_head;</span><br><span class="line">        ListNode* fast = sp_head;</span><br><span class="line">        while(fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">            if(n &lt;0)</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        return sp_head-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-、力扣-142-环形链表-Ⅱ"><a href="#6-、力扣-142-环形链表-Ⅱ" class="headerlink" title="6 、力扣 142 环形链表 Ⅱ"></a>6 、力扣 142 环形链表 Ⅱ</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line"></span><br><span class="line">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span><br><span class="line"></span><br><span class="line">不允许修改 链表。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>首先明确，定义快慢指针，一个走的快，一个走的慢，如果有环，那一定会重逢。</p>
<p>当重逢的时候就证明了有环的存在，问题就是如何寻找环的入口了</p>
<p>我们假设 （从左到右）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从起点到环入口的距离为x</span><br><span class="line"></span><br><span class="line">入口到重逢地点的距离为y</span><br><span class="line"></span><br><span class="line">重逢地点到入口的距离为z</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">慢指针走过的路即为 2*（x+y） （因为慢指针的速度是快指针的一半）</span><br><span class="line"></span><br><span class="line">快指针走过的路即为 x+（y+z）*n +y</span><br><span class="line"></span><br><span class="line">等式连接 约分 可得 x = n*(y+z) - y</span><br><span class="line">x = ny +nz -y</span><br><span class="line">x = (n-1)y + nz</span><br><span class="line">x = (n-1)y + (n-1+1)*z</span><br><span class="line">x = (n-1)y + (n-1)z + z</span><br><span class="line">x = (n-1)(y+z) + z</span><br></pre></td></tr></table></figure>

<p>我们可以发现，当n&#x3D;&#x3D;1的时候，x是等于z的</p>
<p>也就是说，当一个指针从起点开始移动，一个指针从重逢地点开始移动，必会在入口处重逢</p>
<p>所以当快慢指针重逢时，再声明两个指针（index1和index2）在头部和重逢部 移动</p>
<p>当index1 &#x3D;&#x3D; index2 的时候，环的入口也就找到了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        while(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if(slow == fast)&#123;</span><br><span class="line">                ListNode* index1 = head;</span><br><span class="line">                ListNode* index2 = fast;</span><br><span class="line">                while(index1!=index2)&#123;</span><br><span class="line">                    index1=index1-&gt;next;</span><br><span class="line">                    index2=index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、栈"><a href="#二、栈" class="headerlink" title="二、栈"></a>二、栈</h1><p>特点 ：先进后出</p>
<p>入栈顺序 ：a[0],a[1],a[2]</p>
<p>出栈顺序 ：a[2],a[1],a[0]</p>
<p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; st;</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push(val);</span><br><span class="line">pop();</span><br><span class="line">top();</span><br><span class="line">empty();</span><br><span class="line">size();</span><br></pre></td></tr></table></figure>

<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><h3 id="1、力扣-232-用栈实现队列"><a href="#1、力扣-232-用栈实现队列" class="headerlink" title="1、力扣 232 用栈实现队列"></a>1、力扣 232 用栈实现队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</span><br><span class="line"></span><br><span class="line">实现 MyQueue 类：</span><br><span class="line"></span><br><span class="line">void push(int x) 将元素 x 推到队列的末尾</span><br><span class="line">int pop() 从队列的开头移除并返回元素</span><br><span class="line">int peek() 返回队列开头的元素</span><br><span class="line">boolean empty() 如果队列为空，返回 true ；否则，返回 false</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</span><br><span class="line">你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>用两个栈来模拟，一个栈用来入，一个栈用来出。</p>
<p>先进后出，先进后出 &#x3D;&#x3D;》先进先出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    stack&lt;int&gt; InSt,OutSt;</span><br><span class="line">    </span><br><span class="line">    void in_too_out()&#123;</span><br><span class="line">        while(!InSt.empty())&#123;</span><br><span class="line">            OutSt.push(InSt.top());</span><br><span class="line">            InSt.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        InSt.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">       if(OutSt.empty()) &#123;</span><br><span class="line">        in_too_out();   </span><br><span class="line">       &#125;</span><br><span class="line">        int x = OutSt.top();</span><br><span class="line">        OutSt.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int peek() &#123;</span><br><span class="line">        if(OutSt.empty())&#123;</span><br><span class="line">            in_too_out();    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int x = OutSt.top();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return InSt.empty()&amp;&amp;OutSt.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、力扣-20-有效的括号"><a href="#2、力扣-20-有效的括号" class="headerlink" title="2、力扣 20 有效的括号"></a>2、力扣 20 有效的括号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串 s ，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：</span><br><span class="line"></span><br><span class="line">左括号必须用相同类型的右括号闭合。</span><br><span class="line">左括号必须以正确的顺序闭合。</span><br><span class="line">每个右括号都有一个对应的相同类型的左括号。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>利用栈来做</p>
<p>左括号入队，右括号判定</p>
<p>合法栈顶弹出，不合法直接return false</p>
<p>若栈为空，又遇到右括号，说明缺少左括号，直接报错</p>
<p>若遍历完了，栈还不为空，说明缺少右括号，报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool check(char ch1,char ch2)&#123;</span><br><span class="line">        if(ch1 == &#x27;(&#x27; &amp;&amp; ch2 == &#x27;)&#x27; ) return true;</span><br><span class="line">        if(ch1 == &#x27;[&#x27; &amp;&amp; ch2 == &#x27;]&#x27; ) return true;</span><br><span class="line">        if(ch1 == &#x27;&#123;&#x27; &amp;&amp; ch2 == &#x27;&#125;&#x27; ) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        stack&lt;char&gt;st;</span><br><span class="line">        for(char ch:s)&#123;</span><br><span class="line">            if(st.empty() &amp;&amp; (ch == &#x27;)&#x27; || ch ==&#x27;&#125;&#x27; || ch == &#x27;]&#x27;) )</span><br><span class="line">                return false;</span><br><span class="line">            if(ch == &#x27;(&#x27; || ch == &#x27;&#123;&#x27; || ch == &#x27;[&#x27;)</span><br><span class="line">                st.push(ch);</span><br><span class="line">            else&#123;</span><br><span class="line">                if(!check(st.top(),ch)) return false;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return st.empty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、力扣-1047-删除字符串中的所有相邻重复项"><a href="#3、力扣-1047-删除字符串中的所有相邻重复项" class="headerlink" title="3、力扣 1047 删除字符串中的所有相邻重复项"></a>3、力扣 1047 删除字符串中的所有相邻重复项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</span><br><span class="line"></span><br><span class="line">在 S 上反复执行重复项删除操作，直到无法继续删除。</span><br><span class="line"></span><br><span class="line">在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>和括号大同小于，栈处理，同等就出栈，不同就入栈，最后反转一下出栈后的字符串就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string removeDuplicates(string s) &#123;</span><br><span class="line">        string st;</span><br><span class="line">        for(char ch:s)&#123;</span><br><span class="line">            if(st.empty() || st.back()!=ch)</span><br><span class="line">                st.push_back(ch);</span><br><span class="line">            else</span><br><span class="line">                st.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return st;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、力扣-150-逆波兰表达式求值"><a href="#4、力扣-150-逆波兰表达式求值" class="headerlink" title="4、力扣 150 逆波兰表达式求值"></a>4、力扣 150 逆波兰表达式求值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</span><br><span class="line"></span><br><span class="line">请你计算该表达式。返回一个表示表达式值的整数。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">有效的算符为 &#x27;+&#x27;、&#x27;-&#x27;、&#x27;*&#x27; 和 &#x27;/&#x27; 。</span><br><span class="line">每个操作数（运算对象）都可以是一个整数或者另一个表达式。</span><br><span class="line">两个整数之间的除法总是 向零截断 。</span><br><span class="line">表达式中不含除零运算。</span><br><span class="line">输入是一个根据逆波兰表示法表示的算术表达式。</span><br><span class="line">答案及所有中间计算结果可以用 32 位 整数表示。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>由于本体是后缀表达式，所以不用考虑符号的优先级</p>
<p>遇到数字就压入，遇到符号就连续弹出，计算，注意后弹出的作为第一个元素</p>
<p>计算完后将结果继续压入</p>
<p>最后栈内的数字就是结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt;st;</span><br><span class="line"></span><br><span class="line">        for (const string&amp; s : tokens) &#123;</span><br><span class="line">        if (s == &quot;+&quot; || s == &quot;-&quot; || s == &quot;*&quot; || s == &quot;/&quot;) &#123;</span><br><span class="line">            int num2 = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            int num1 = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            if (s == &quot;+&quot;)</span><br><span class="line">                st.push(num1 + num2);</span><br><span class="line">            else if (s == &quot;-&quot;)</span><br><span class="line">                st.push(num1 - num2);</span><br><span class="line">            else if (s == &quot;*&quot;)</span><br><span class="line">                st.push(num1 * num2);</span><br><span class="line">            else if (s == &quot;/&quot;)</span><br><span class="line">                st.push(num1 / num2);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            st.push(stoi(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        return st.top();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="衍生结构：单调栈"><a href="#衍生结构：单调栈" class="headerlink" title="衍生结构：单调栈"></a>衍生结构：单调栈</h2><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">栈中的元素单调增加/减少</span><br><span class="line"></span><br><span class="line">存放的是下标</span><br><span class="line"></span><br><span class="line">适合求左边/右边 第一个比他 大/小 的元素</span><br></pre></td></tr></table></figure>

<h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="1、力扣-739-每日温度"><a href="#1、力扣-739-每日温度" class="headerlink" title="1、力扣 739.每日温度"></a>1、力扣 739.每日温度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>1、本题可以看作是求一个元素右边第一个比他大的元素，</p>
<p>​	使用单调递增(<strong>从栈顶往栈底</strong>)的单调栈</p>
<p>2、遍历数组，将元素存入栈中，初次直接入栈，若即将入栈的元素（即下边为当前的i的元素）小于等于栈顶元素，直接压入</p>
<p>3、若即将入栈的元素大于栈顶元素，进入循环判定，直到栈内为空和栈内没有元素大于他，一一计算差值（i-st.top）并全部弹出</p>
<p>4、将最大的元素继续入栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;</span><br><span class="line">        int n = temperatures.size();</span><br><span class="line">        vector&lt;int&gt; ans(n);</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            while(!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()])&#123; </span><br><span class="line">                ans[st.top()] = i-st.top(); </span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;    </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2、力扣-84-矩形中最大的面积"><a href="#2、力扣-84-矩形中最大的面积" class="headerlink" title="2、力扣 84.矩形中最大的面积"></a>2、力扣 84.矩形中最大的面积</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</span><br><span class="line"></span><br><span class="line">求在该柱状图中，能够勾勒出来的矩形的最大面积。</span><br><span class="line"></span><br><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形面积为 10</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>1、本题思路是锁定高度求底边最长，因此可以看作是找一个元素左边以及右边第一个小于当前元素的元素下标距离，所以使用单调栈</p>
<p>2、因为是小于，所以使用递减的单调栈</p>
<p>3、为了方便操作，在数组的收尾都加上0，这样最左边和最右边都有一个最小的终结值。</p>
<p>4、如果相同或者大于栈顶元素就将他压入</p>
<p>5、如果小于栈顶元素就开始进入循环计算</p>
<p>6、当前的元素就是栈顶元素，也就是锁定的高</p>
<p>7、左边第一个比他小的元素就是栈顶的第二个元素</p>
<p>8、右边第一个比他小的元素就是即将入栈的元素</p>
<p>9、因为存储的是下标，所以底边长为右减左减1；</p>
<p>10、将当前的元素压入，做下次对比。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//找左边和右边第一个比他小的</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        </span><br><span class="line">        heights.insert(heights.begin(),0);</span><br><span class="line">        heights.push_back(0);</span><br><span class="line">        </span><br><span class="line">        stack&lt;int&gt;st;</span><br><span class="line">        st.push(0);</span><br><span class="line">        int ans = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i=1;i&lt;heights.size();i++)&#123;</span><br><span class="line">            while(!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()])&#123;</span><br><span class="line">                int h_index = st.top();//高</span><br><span class="line">                st.pop();</span><br><span class="line">                int left = st.top();</span><br><span class="line">                int right = i;</span><br><span class="line">                ans = max(ans,heights[h_index]*(right-left-1));</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、力扣-496-下一个更大的元素Ⅰ"><a href="#3、力扣-496-下一个更大的元素Ⅰ" class="headerlink" title="3、力扣 496 下一个更大的元素Ⅰ"></a>3、力扣 496 下一个更大的元素Ⅰ</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</span><br><span class="line"></span><br><span class="line">给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</span><br><span class="line"></span><br><span class="line">对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</span><br><span class="line"></span><br><span class="line">返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>1、题目明示是右边下一个更大的元素，所以确定是递增单调栈，将结果存储至ans数组，ans默认值为-1，大小和子数组大小一致</p>
<p>2、因为需要求的是子数组，为了方便确认目前求的元素是否属于子数组，用unordered_map来存储子数组的元素&lt;key：元素，value：下标&gt;</p>
<p>3、如果当前元素大于栈顶元素，并且他属于子数组（map中存在），那么就将它存入ans数组，否则直接不要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        stack &lt;int&gt; st;</span><br><span class="line">        vector&lt;int&gt; ans(nums1.size(),-1);</span><br><span class="line">        if(nums1.size() == 0) return ans;</span><br><span class="line">        unordered_map&lt;int,int&gt;checkMap;</span><br><span class="line">        for(int i=0;i&lt;nums1.size();i++) checkMap[nums1[i]] = i;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;nums2.size();i++)&#123;</span><br><span class="line">            while(!st.empty()&amp;&amp;nums2[i] &gt; nums2[st.top()])&#123;</span><br><span class="line">                if(checkMap.count(nums2[st.top()]) &gt; 0)&#123;//如果他在map里存在,就执行操作</span><br><span class="line">                    int index = checkMap[nums2[st.top()]];</span><br><span class="line">                    ans[index] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4、力扣503-下一个更大的元素Ⅱ"><a href="#4、力扣503-下一个更大的元素Ⅱ" class="headerlink" title="4、力扣503 下一个更大的元素Ⅱ"></a>4、力扣503 下一个更大的元素Ⅱ</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</span><br><span class="line"></span><br><span class="line">数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>1、下一个更大-&gt;递增单调栈</p>
<p>2、首尾相连的数组我们可以用求余的方法，i的取值范围扩展到2n即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        stack&lt;int&gt;st;</span><br><span class="line">        vector&lt;int&gt; ans(nums.size(),-1);</span><br><span class="line">        st.push(0);</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i=1;i&lt; n*2;i++)&#123;</span><br><span class="line">            int index = i%n;</span><br><span class="line">            while(!st.empty() &amp;&amp; nums[index] &gt; nums[st.top()])&#123;</span><br><span class="line">                ans[st.top()] = nums[index];</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(index);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、力扣42-接雨水"><a href="#5、力扣42-接雨水" class="headerlink" title="5、力扣42 接雨水"></a>5、力扣42 接雨水</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><span class="line"></span><br><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>1、该题可以看成求当前元素左边第一个比他大的和右边第一个比他大的元素，所以用递增单调栈</p>
<p>2、水槽的面积就是左边第一个比他大的到右边第一个比他大的距离 乘以 左右两边最小的那一个高度</p>
<p>3、因为是递增的单调栈，所以栈顶元素就是当前元素，即将入栈的就是右边第一个比他大的，栈内第二个元素就是左边第一个比他大的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; height.size(); i++) &#123;</span><br><span class="line">            while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;</span><br><span class="line">                int mid = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                if (st.empty()) break; // 无法形成容器，退出循环                </span><br><span class="line">                int left = st.top();</span><br><span class="line">                int right = i;</span><br><span class="line">                int h = min(height[left], height[right]) - height[mid];</span><br><span class="line">                int w = right - left - 1;</span><br><span class="line">                ans += h * w;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h1><p>特点：先进先出</p>
<p>入队顺序 ：a[0],a[1],a[2]</p>
<p><strong>rear</strong> ——————————– front</p>
<p>​			a[2]	  a[1]	 a[0]</p>
<p><strong>rear</strong> ——————————– front</p>
<p>出队顺序 ：a[0],a[1],a[2]</p>
<p>rear ——————————– <strong>front</strong></p>
<p>​															a[2]	  a[1]	 a[0]</p>
<p>rear ——————————– <strong>front</strong></p>
<h2 id="1、单端队列"><a href="#1、单端队列" class="headerlink" title="1、单端队列"></a>1、单端队列</h2><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; q1</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push(val);</span><br><span class="line">pop();</span><br><span class="line">front();</span><br><span class="line">back();</span><br><span class="line">empty();</span><br><span class="line">size();</span><br></pre></td></tr></table></figure>



<h4 id="例题、力扣-225-用队列实现栈"><a href="#例题、力扣-225-用队列实现栈" class="headerlink" title="例题、力扣 225 用队列实现栈"></a>例题、力扣 225 用队列实现栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</span><br><span class="line"></span><br><span class="line">实现 MyStack 类：</span><br><span class="line"></span><br><span class="line">void push(int x) 将元素 x 压入栈顶。</span><br><span class="line">int pop() 移除并返回栈顶元素。</span><br><span class="line">int top() 返回栈顶元素。</span><br><span class="line">boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。</span><br><span class="line">你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>只需要使用一个队列。在需要出栈的时候，循环出队入队size-1次，便是栈顶元素（其实就是队尾）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; q1;</span><br><span class="line">    </span><br><span class="line">    void find_end()&#123;</span><br><span class="line">        for(int i=0;i&lt;q1.size()-1;i++)&#123;</span><br><span class="line">            int x = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            q1.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        q1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(!q1.empty())&#123;</span><br><span class="line">            find_end();</span><br><span class="line">        &#125;</span><br><span class="line">        int x = q1.front();</span><br><span class="line">        q1.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        int x =q1.back();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return q1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2、双端队列"><a href="#2、双端队列" class="headerlink" title="2、双端队列"></a>2、双端队列</h2><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; q1;</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push_front(val);</span><br><span class="line">push_back(val);</span><br><span class="line">pop_front(val);</span><br><span class="line">pop_back(val);</span><br><span class="line">front();</span><br><span class="line">back();</span><br><span class="line">empty();</span><br><span class="line">size();</span><br></pre></td></tr></table></figure>

<h3 id="衍生类型1：单调队列"><a href="#衍生类型1：单调队列" class="headerlink" title="衍生类型1：单调队列"></a>衍生类型1：单调队列</h3><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">遇到比当前元素 大（小）的，就全部出队</span><br><span class="line"></span><br><span class="line">遇到小的就加到最后</span><br><span class="line"></span><br><span class="line">当 下标 超出范围弹出</span><br><span class="line"></span><br><span class="line">存放的是下标</span><br><span class="line"></span><br><span class="line">求滑动窗口中的 最大值</span><br></pre></td></tr></table></figure>

<h4 id="例题、力扣-239-滑动窗口最大值"><a href="#例题、力扣-239-滑动窗口最大值" class="headerlink" title="例题、力扣 239 滑动窗口最大值"></a>例题、力扣 239 滑动窗口最大值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line"></span><br><span class="line">返回 滑动窗口中的最大值 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>使用单调队列（双端队列）实现滑动窗口</p>
<p>单调队列内存放的是数组元素的下标</p>
<p>只保留从队首到队尾的从大到小元素</p>
<p>如果最大元素的下标，小于i-k+1，就将他出队</p>
<p>如果遇到比当前最大元素还要大的，就将队内全部清空，因为不可能成为最大值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        deque&lt;int&gt; q1;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            // 删除队列中不在当前窗口内的元素</span><br><span class="line">            if (!q1.empty() &amp;&amp; q1.front() &lt; i - k + 1) &#123;</span><br><span class="line">                q1.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 删除队列中比当前元素小的元素，因为它们不可能成为窗口中的最大值</span><br><span class="line">            while (!q1.empty() &amp;&amp; nums[q1.back()] &lt; nums[i]) &#123;</span><br><span class="line">                q1.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 将当前元素的索引加入队列</span><br><span class="line">            q1.push_back(i);</span><br><span class="line">            // 如果窗口已经形成，记录窗口中的最大值</span><br><span class="line">            </span><br><span class="line">            if (i &gt;= k - 1) &#123;</span><br><span class="line">                ans.push_back(nums[q1.front()]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大顶堆法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;&gt; q1;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            while (!q1.empty() &amp;&amp; q1.top().second &lt;= i - k) // 移除超出窗口范围的元素</span><br><span class="line">                q1.pop();</span><br><span class="line">            q1.push(&#123;nums[i], i&#125;);</span><br><span class="line">            if (i &gt;= k - 1) // 当窗口大小达到 k 时，将队列的顶部元素加入结果数组</span><br><span class="line">                ans.push_back(q1.top().first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="衍生类型2：顶堆（优先队列）"><a href="#衍生类型2：顶堆（优先队列）" class="headerlink" title="衍生类型2：顶堆（优先队列）"></a>衍生类型2：顶堆（优先队列）</h3><p>定义：</p>
<p>最大堆：顶最大</p>
<p>最小堆：顶最小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;数据类型,存储数据用的容器,自定义比较方法所在的类&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">顶堆（或最大堆）是一种特殊的二叉堆数据结构，其中每个节点的值都大于或等于其子节点的值。顶堆的根节点（顶部节点）是堆中的最大值。</span><br><span class="line"></span><br><span class="line">优先队列通过堆的性质，特别是顶堆的性质，来保证队列中元素的有序性。当你向优先队列插入元素时，它会根据一定的优先级规则将元素放置在适当的位置，以保持堆的顶部是最大元素。因此，通过使用顶堆，优先队列可以实现高效的元素插入和删除操作，并且始终能够快速地访问最大元素。</span><br><span class="line"></span><br><span class="line">适合求前k个高（低）频词</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 小顶堆，求前k个高频词</span><br><span class="line">   class mycomparison &#123;//通过重载operator方法来实现自定义排序</span><br><span class="line">   public:</span><br><span class="line">       bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123;//它会根据这个比较函数的逻辑来维护队列的顺序</span><br><span class="line">           return lhs.second &gt; rhs.second;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   // 定义一个小顶堆，大小为k</span><br><span class="line">   priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,mycomparison&gt; pri_que;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 C++ 中，priority_queue 默认使用的是大顶堆，如果你想要使用小顶堆，需要通过指定比较器来实现。在我之前的代码中，我使用了默认的 less 比较器来实现大顶堆，以获取最大元素。</span><br><span class="line"></span><br><span class="line">关于重载 operator() 的问题，对于优先队列（priority_queue）来说，并不需要重载 operator()。因为在优先队列中，需要比较元素大小的是队列中的元素，而不是比较器对象本身。所以你可以通过传递一个比较器对象来指定元素的比较方式，而不需要重载 operator()。</span><br></pre></td></tr></table></figure>

<h6 id="顶堆的使用和顺序的使用"><a href="#顶堆的使用和顺序的使用" class="headerlink" title="顶堆的使用和顺序的使用"></a>顶堆的使用和顺序的使用</h6><ol>
<li>小顶堆</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小顶堆：在小顶堆中，父节点的值小于或等于其子节点的值。因此，堆顶元素（根节点）是整个堆中的最小元素。小顶堆常被用于实现优先队列，使得优先级最高的元素能够快速地被访问和弹出。</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>  代码实现：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class MyCMP&#123;</span><br><span class="line">	public:</span><br><span class="line">		bool operator()(int x,int y)&#123; //从小到大 </span><br><span class="line">			return x &gt; y;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int num[10] = &#123;1,2,4,5,13,5,12,58,-1,-8&#125;;</span><br><span class="line">	int k=4;</span><br><span class="line">	priority_queue&lt;int,vector&lt;int&gt;,MyCMP&gt; q1; </span><br><span class="line">	for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">		q1.push(num[i]);</span><br><span class="line">		if(i &gt; k-1)</span><br><span class="line">			q1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(!q1.empty())&#123;</span><br><span class="line">		int x = q1.top();</span><br><span class="line">		q1.pop();</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h6 id="省略写法"><a href="#省略写法" class="headerlink" title="省略写法"></a>省略写法</h6>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	int num[10] = &#123;1,2,4,5,13,5,12,58,-1,-8&#125;;</span><br><span class="line">	int k=4;</span><br><span class="line">	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q1; </span><br><span class="line">	for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">		q1.push(num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(!q1.empty())&#123;</span><br><span class="line">		int x = q1.top();</span><br><span class="line">		q1.pop();</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不加k限制，堆内元素为</span><br><span class="line">堆顶 -&gt; 堆底</span><br><span class="line">-8 -1 1 2 4 5 （5 12 13 58）前k个</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>大顶堆</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大顶堆：在大顶堆中，父节点的值大于或等于其子节点的值。因此，堆顶元素（根节点）是整个堆中的最大元素。大顶堆常被用于解决一些与最大值相关的问题，如求解数组中的第 K 大元素等。</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  4   3</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>  代码实现：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyCMP&#123;</span><br><span class="line">	public:</span><br><span class="line">		bool operator()(int x,int y)&#123; //从大到小 不可省略</span><br><span class="line">			return x &lt; y;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int num[10] = &#123;1,2,4,5,13,5,12,58,-1,-8&#125;;</span><br><span class="line">	int k=4;</span><br><span class="line">	priority_queue&lt;int,vector&lt;int&gt;,MyCMP&gt; q1; </span><br><span class="line">	for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">		q1.push(num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(!q1.empty())&#123;</span><br><span class="line">		int x = q1.top();</span><br><span class="line">		q1.pop();</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不加k限制，堆内元素为</span><br><span class="line">堆顶 -&gt; 堆底</span><br><span class="line">58 13 12 5 5 4 (2 1 -1 -8) 前k个</span><br></pre></td></tr></table></figure>

<p>ps：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在实际应用 当中，应该注意究竟是用小顶还是大顶，往往会是相反的使用</span><br><span class="line">比如前k个高频元素，我们反而使用小顶堆，将顶上小的不断弹出直到只剩k个元素，剩下来的就是前k个高频元素，如果采用大顶堆，反倒是会剩下最小的几个</span><br></pre></td></tr></table></figure>



<h4 id="例题、力扣-347-前K个高频元素"><a href="#例题、力扣-347-前K个高频元素" class="headerlink" title="例题、力扣 347 前K个高频元素"></a>例题、力扣 347 前K个高频元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>使用哈希表记录出现的频率</p>
<p>使用优先队列（小顶堆）找出频率最高的前k个数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 小顶堆，求前k个高频词</span><br><span class="line">    class mycomparison &#123;</span><br><span class="line">    public:</span><br><span class="line">        bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123;</span><br><span class="line">            return lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;int, int&gt; map;// 要统计元素出现频率 </span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            map[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 定义一个小顶堆，大小为k</span><br><span class="line">        priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        // 用固定大小为k的小顶堆，扫面所有频率的数值</span><br><span class="line">        for(auto it = map.begin();it!=map.end();it++) &#123;</span><br><span class="line">            pri_que.push(*it);</span><br><span class="line">            if (pri_que.size() &gt; k)&#123; // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br><span class="line">                pri_que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br><span class="line">        vector&lt;int&gt; result(k);</span><br><span class="line">        for (int i = k - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            result[i] = pri_que.top().first;</span><br><span class="line">            pri_que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、串"><a href="#四、串" class="headerlink" title="四、串"></a>四、串</h1><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">length() 或者 size()</span><br><span class="line">append(str) : 末尾添加另一个字符串</span><br><span class="line">insert(index,str) :指定位置添加字符串</span><br><span class="line">erase(index,len) :指定位置删除长度为len的字符串</span><br><span class="line">substr(index,len) : 返回从指定位置开始的子串</span><br><span class="line">find(str,index): 从指定位置开始寻找子串</span><br><span class="line">replace(index,len,str): 从指定位置开始替换长度为n的字符串</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">reverse(s.begin(),s.end())：反转字符串</span><br></pre></td></tr></table></figure>

<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>求Next数组（1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void getNext(vector&lt;int&gt;&amp; next, const string&amp; s, int n) &#123;</span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        int j = next[i - 1];</span><br><span class="line">        while (j != -1 &amp;&amp; s[j + 1] != s[i]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[j + 1] == s[i]) &#123;</span><br><span class="line">            next[i] = j + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求Next数组（2）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void getNext(vector&lt;int&gt;&amp; next,string s)&#123;</span><br><span class="line">	int i=0,j=-1;</span><br><span class="line">	while(i&lt;s.size())&#123;</span><br><span class="line">		if(j==-1 || s[i] == s[j])&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			j=next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KMP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getNext(next,s2);</span><br><span class="line">int i=0,j=-1;</span><br><span class="line">while(i&lt;s1.size())&#123;</span><br><span class="line">	if(j==-1||s1[i] == s2[j])&#123;</span><br><span class="line">		i++;</span><br><span class="line">		j++;</span><br><span class="line">		if(j == s2.size()) return i-j;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		j= next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><h4 id="1-力扣-344-反转字符串"><a href="#1-力扣-344-反转字符串" class="headerlink" title="1.力扣 344 反转字符串"></a>1.力扣 344 反转字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</span><br><span class="line"></span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>双指针，一头一尾交换就是了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        int head = 0;</span><br><span class="line">        int tail = s.size()-1;</span><br><span class="line">        while(head &lt; tail)&#123;</span><br><span class="line">            char temp = s[head];</span><br><span class="line">            s[head] = s[tail];</span><br><span class="line">            s[tail] = temp;</span><br><span class="line">            head++;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>单指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">       int len = s.size();</span><br><span class="line">       for(int i=0;i&lt;len/2;i++)&#123;</span><br><span class="line">           char ch = s[i];</span><br><span class="line">           s[i] = s[len-i-1];</span><br><span class="line">           s[len-i-1] = ch;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-力扣-541-反转字符串Ⅱ"><a href="#2-力扣-541-反转字符串Ⅱ" class="headerlink" title="2.力扣 541 反转字符串Ⅱ"></a>2.力扣 541 反转字符串Ⅱ</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</span><br><span class="line"></span><br><span class="line">如果剩余字符少于 k 个，则将剩余字符全部反转。</span><br><span class="line">如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;bacd&quot;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>这题需要思维反转一下，不是到2k开始对0-k的元素反转，而是对2k到k的元素进行反转</p>
<p>所以</p>
<p>2*k是下次需要反转时的起始坐标<br>每次反转的内容就是起始坐标到 i+k的距离<br>如果i+k大于n，就取n</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        //2*k是下次需要反转时的起始坐标</span><br><span class="line">        //每次反转的内容就是起始坐标到 i+k的距离</span><br><span class="line">        //如果i+k大于n，就取n</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i+= (2 * k))</span><br><span class="line">        &#123;</span><br><span class="line">            if(i + k &lt; s.size())</span><br><span class="line">                reverse(s.begin() + i, s.begin() + i + k);</span><br><span class="line">            else</span><br><span class="line">                reverse(s.begin() + i, s.end());</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>双指针法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string reverseStr(string s, int k) &#123;</span><br><span class="line">        int start=0;</span><br><span class="line">        int fast=0;</span><br><span class="line">        int len = s.size();</span><br><span class="line"></span><br><span class="line">        while(fast+2*k &lt;= len)&#123;</span><br><span class="line">            fast = start + 2*k;</span><br><span class="line">            reverse(s.begin()+start,s.begin()+start + k);</span><br><span class="line">            start = fast;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        len - fast &lt; k ? reverse(s.begin()+fast,s.end()) : reverse(s.begin()+start,s.begin()+start + k);</span><br><span class="line">        </span><br><span class="line">        return s;</span><br></pre></td></tr></table></figure>

<h4 id="3-卡玛-53-替换数字"><a href="#3-卡玛-53-替换数字" class="headerlink" title="3.卡玛 53 替换数字"></a>3.卡玛 53 替换数字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目描述</span><br><span class="line">给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 &quot;a1b2c3&quot;，函数应该将其转换为 &quot;anumberbnumbercnumber&quot;。</span><br><span class="line">输入描述</span><br><span class="line">输入一个字符串 s,s 仅包含小写字母和数字字符。</span><br><span class="line">输出描述</span><br><span class="line">打印一个新的字符串，其中每个数字字符都被替换为了number</span><br><span class="line">输入示例</span><br><span class="line">a1b2c3</span><br><span class="line">输出示例</span><br><span class="line">anumberbnumbercnumber</span><br><span class="line">提示信息</span><br><span class="line">数据范围：</span><br><span class="line">1 &lt;= s.length &lt; 10000。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>定义一个字符串，遍历存放，遇到数字换就是了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    string ans;</span><br><span class="line">    for(char ch:s)&#123;</span><br><span class="line">        if(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">            ans+=&quot;number&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else ans+=ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-力扣-151-翻转字符串里的单词"><a href="#4-力扣-151-翻转字符串里的单词" class="headerlink" title="4.力扣 151 翻转字符串里的单词"></a>4.力扣 151 翻转字符串里的单词</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s ，请你反转字符串中 单词 的顺序。</span><br><span class="line"></span><br><span class="line">单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</span><br><span class="line"></span><br><span class="line">返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</span><br><span class="line"></span><br><span class="line">注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>其实反转也可以看成先进后出，所以可以用栈的思维来转换</p>
<p>先遍历字符串将单词入栈</p>
<p>随后再挨个弹出就行了，注意加空格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;//先进后出，用栈</span><br><span class="line">        stack&lt;string&gt; st;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;s.size();i++)&#123;//分割单词存入栈中</span><br><span class="line">            if(s[i]!=&#x27; &#x27;)&#123;</span><br><span class="line">                string temp;</span><br><span class="line">                while(s[i]!=&#x27;\0&#x27; &amp;&amp; s[i]!=&#x27; &#x27;)&#123;</span><br><span class="line">                    temp +=s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        while(!st.empty())&#123;//栈不为空就输出栈</span><br><span class="line">            ans += st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            if(!st.empty()) ans+=&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双指针法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string reverseWords(string s) &#123;</span><br><span class="line">        int slow =0;</span><br><span class="line">	    for(int fast=0;fast &lt; s.size();fast++)&#123;</span><br><span class="line">            if(s[fast]!=&#x27; &#x27;) s[slow++] =s[fast];</span><br><span class="line">            else if(s[fast] == &#x27; &#x27; &amp;&amp; fast&gt;0 &amp;&amp; s[fast-1] !=&#x27; &#x27;) s[slow++]=&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[slow-1] == &#x27; &#x27;) slow--;</span><br><span class="line">	    s.resize(slow);</span><br><span class="line">	    reverse(s.begin(),s.end());</span><br><span class="line">        int start =0;</span><br><span class="line">        int end =0;</span><br><span class="line">    </span><br><span class="line">        while(end &lt; s.size())&#123;</span><br><span class="line">            while(end &lt; s.size() &amp;&amp; s[end]!=&#x27; &#x27;) &#123;</span><br><span class="line">        	    end++;</span><br><span class="line">		    &#125;</span><br><span class="line">            reverse(s.begin()+start,s.begin()+end);</span><br><span class="line">            end++;</span><br><span class="line">		    start = end;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-卡玛-55-右旋转字符串"><a href="#5-卡玛-55-右旋转字符串" class="headerlink" title="5.卡玛 55 右旋转字符串"></a>5.卡玛 55 右旋转字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 </span><br><span class="line"></span><br><span class="line">例如，对于输入字符串 &quot;abcdefg&quot; 和整数 2，函数应该将其转换为 &quot;fgabcde&quot;。</span><br><span class="line"></span><br><span class="line">输入描述</span><br><span class="line">输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</span><br><span class="line">输出描述</span><br><span class="line">输出共一行，为进行了右旋转操作后的字符串。</span><br><span class="line">输入示例</span><br><span class="line">2</span><br><span class="line">abcdefg</span><br><span class="line">输出示例</span><br><span class="line">fgabcde</span><br><span class="line">提示信息</span><br><span class="line">数据范围：</span><br><span class="line">1 &lt;= k &lt; 10000,</span><br><span class="line">1 &lt;= s.length &lt; 10000;</span><br></pre></td></tr></table></figure>

<p>题解：利用栈很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    string s;</span><br><span class="line">    string ans;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    stack&lt;char&gt; st;</span><br><span class="line">    int len = s.size();</span><br><span class="line">    int i;</span><br><span class="line">    for(i = len-1;i&gt;len-n-1;i--)&#123;</span><br><span class="line">        st.push(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    while(!st.empty())&#123;</span><br><span class="line">        ans+=st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;len-n;i++)&#123;</span><br><span class="line">        ans+=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-力扣-459-重复的子字符串"><a href="#6-力扣-459-重复的子字符串" class="headerlink" title="6.力扣 459 重复的子字符串"></a>6.力扣 459 重复的子字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;abcabcabcabc&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure>

<p>题解：巧用next数组求最大重复的前缀长度</p>
<p>再用n除以前缀长度，看看能否整除；</p>
<p>next一种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    void getNext(vector&lt;int&gt;&amp; next,const string&amp; s,int n)&#123;</span><br><span class="line">         for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            int j = next[i - 1];</span><br><span class="line">            while (j != -1 &amp;&amp; s[j + 1] != s[i]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[j + 1] == s[i]) &#123;</span><br><span class="line">                next[i] = j + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool repeatedSubstringPattern(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;int&gt; next(n, -1);</span><br><span class="line">        getNext(next,s,n);</span><br><span class="line">        return next[n - 1] != -1 &amp;&amp; n % (n - next[n - 1] - 1) == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种next</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    void getNext(vector&lt;int&gt;&amp; next,const string&amp; s,int n)&#123;</span><br><span class="line">         int i=0,j=-1;</span><br><span class="line">        while(i&lt;n)&#123;</span><br><span class="line">            if(j == -1 || s[i] == s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                next[i]= j;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">                j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool repeatedSubstringPattern(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;int&gt; next(n+1, -1);</span><br><span class="line">        getNext(next,s,n);</span><br><span class="line">        return next[n] != 0 &amp;&amp; ((n % (n-next[n])) == 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="五、哈希表"><a href="#五、哈希表" class="headerlink" title="五、哈希表"></a>五、哈希表</h1><h2 id="1、无序表"><a href="#1、无序表" class="headerlink" title="1、无序表"></a>1、无序表</h2><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int,int&gt;map;</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert(key, value)：向哈希映射中插入键值对。</span><br><span class="line">erase(key)：从哈希映射中删除指定键对应的键值对。</span><br><span class="line">find(key)：查找指定键对应的值。</span><br><span class="line">size()：返回哈希映射中键值对的数量。</span><br><span class="line">empty()：检查哈希映射是否为空。</span><br></pre></td></tr></table></figure>

<h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><h4 id="1、力扣-242-有效的字母异位词"><a href="#1、力扣-242-有效的字母异位词" class="headerlink" title="1、力扣 242 有效的字母异位词"></a>1、力扣 242 有效的字母异位词</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</span><br><span class="line"></span><br><span class="line">注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>因为本题范围只有26个字母，所以可以采用数组代替hash表，用下标代表a-z的字母</p>
<p>判断异位词，换句话说就是判断他们两个之间的字符是否完全相同</p>
<p>遍历第一个字符串，将每个元素出现次数记录下来。</p>
<p>再遍历第二个字符串，将每个元素出现一次减少一次</p>
<p>如果最后数组中有非0元素，那说明有元素没有出现（多出现了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if(s.size()!=t.size()) return false;</span><br><span class="line">        int check[27] = &#123;0&#125;;</span><br><span class="line">        for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">            check[s[i]-&#x27;a&#x27;]++;</span><br><span class="line">            check[t[i]-&#x27;a&#x27;]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i : check)&#123;</span><br><span class="line">            if(i != 0 )return false;</span><br><span class="line">        &#125;</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="2、力扣-349-两个数组的交集"><a href="#2、力扣-349-两个数组的交集" class="headerlink" title="2、力扣 349 两个数组的交集"></a>2、力扣 349 两个数组的交集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>先将两个数组都排序，定义两个下标分别指向两个数组首地址</p>
<p>因为不允许重复，所以可以判定当index不为头元素的时候，前一个元素和当前元素相同，那就直接下标++后continue</p>
<p>当遇到两个数组中相等的元素时把他加入ans</p>
<p>并且因为答案的不可重复，可以直接全部++</p>
<p>如果数组1的元素大于数组二的元素，因为数组是排序过的，所以只要让数组二的下标++就行</p>
<p>小于同理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if(nums1.size() == 0 || nums2.size() == 0) return ans;</span><br><span class="line">        sort(nums1.begin(),nums1.end());</span><br><span class="line">        sort(nums2.begin(),nums2.end());</span><br><span class="line">        int index1=0,index2=0;</span><br><span class="line">        </span><br><span class="line">        while(index1&lt;nums1.size() &amp;&amp; index2&lt;nums2.size())&#123;</span><br><span class="line">            if(index1!=0&amp;&amp;nums1[index1] == nums1[index1-1]) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(index2!=0&amp;&amp;nums2[index2] == nums2[index2-1]) &#123;</span><br><span class="line">                index2++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(nums1[index1] == nums2[index2]) &#123;</span><br><span class="line">                ans.push_back(nums1[index1]);</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums1[index1] &lt; nums2[index2]) index1++;</span><br><span class="line">            else   index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双哈希表法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt;map1;</span><br><span class="line">        unordered_map&lt;int,int&gt;map2;</span><br><span class="line"></span><br><span class="line">        for(int i:nums1) map1[i] = i;</span><br><span class="line">        for(int i:nums2)&#123;</span><br><span class="line">            if(map1.count(i) &gt; 0 )</span><br><span class="line">                map2[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;ans;</span><br><span class="line">        for(auto it:map2)&#123;</span><br><span class="line">            ans.push_back(it.first);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、力扣-1-两数之和"><a href="#3、力扣-1-两数之和" class="headerlink" title="3、力扣 1 两数之和"></a>3、力扣 1 两数之和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>很简单，将数据都存入hashmap中后，将指针指向第一个元素</p>
<p>我们需要找的目标就是target-第一个元素</p>
<p>向hashmap中找有没有这个元素，有就返回，没有继续</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; check_map;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            // 记录每个数字的索引</span><br><span class="line">            check_map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            int temp = target - nums[i];</span><br><span class="line">            // 检查是否存在配对</span><br><span class="line">            if (check_map.count(temp) &amp;&amp; check_map[temp] != i) &#123;</span><br><span class="line">                return &#123;i, check_map[temp]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>双指针法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        multimap&lt;int,int&gt;index1;//允许重复值存在的map</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            index1.emplace(nums[i], i);//插入</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        auto left = index1.begin();</span><br><span class="line">        auto right = index1.end();</span><br><span class="line">        right--;</span><br><span class="line">        </span><br><span class="line">        while(left-&gt;first &lt;= right-&gt;first)&#123;</span><br><span class="line">            int sum = left-&gt;first + right-&gt;first;     </span><br><span class="line">            if (sum &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else if(sum &lt; target)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return &#123;left-&gt;second,right-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、力扣-15三数之和（双指针）"><a href="#4、力扣-15三数之和（双指针）" class="headerlink" title="4、力扣 15三数之和（双指针）"></a>4、力扣 15三数之和（双指针）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span><br><span class="line"></span><br><span class="line">你返回所有和为 0 且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>其实这题可以用回溯做，但是会超时，剪枝剪不了一点</p>
<p>首先我们将数组排序</p>
<p>需要一个指针i从头到倒数第三个元素遍历（三元组，保证有两个元素空余）</p>
<p>因为数组是有序的 那么 i和后两个元素相加如果已经大于target了的话，那说明已经不存在符合条件的组合了，直接break</p>
<p>如果i和数组末尾的两个元素相加还小于target的话，那说明当前的i不可能符合条件，向后寻找更大的i，continue</p>
<p>我们假设（i）和末尾的元素（right）就是我们需要的元素之一，</p>
<p>那么我们需要的第三个元素就是0-i-right</p>
<p>我们设一个left，他从i的后一个元素开始遍历</p>
<p>那么right就是决定sum的最大值，left就是决定sum的最小值</p>
<p>那我们只需要移动left就可以找到目标的元素</p>
<p>当left&gt;right的时候，组合就不存在了，可以继续下一个循环了</p>
<p>当sum比traget小的时候，left就得++</p>
<p>当sum大于traget的时候，right就得–</p>
<p>当sum等于traget的时候，我们就可以存放一个组合了。</p>
<p>注意题目要求不重复，那么如果left右边的元素&#x2F;right左边的元素和当前的left&#x2F;right相同，那就继续移动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());//数组变成单调增</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        for(int left=0;left&lt;nums.size()-2;left++)&#123;</span><br><span class="line">            if(nums[left] &gt; 0) break;</span><br><span class="line">            //nums[left] == nums[left-1] 1 1 2 i 和 j 两个1都能取到</span><br><span class="line">            //nums[left] == nums[left+1] 1 1 2 i 只能取到第二个1</span><br><span class="line">            if(left&gt;0 &amp;&amp; nums[left] == nums[left-1]) continue;</span><br><span class="line">            </span><br><span class="line">            int right = nums.size()-1;</span><br><span class="line">            int find = left + 1;</span><br><span class="line">            int target = 0-nums[left];</span><br><span class="line">            if(nums[left]+nums[find] &gt; target) break;</span><br><span class="line">            if(nums[right] + nums[right-1] &lt; target) continue;</span><br><span class="line"></span><br><span class="line">            while(find &lt; right)&#123;</span><br><span class="line">                int sum = nums[right] + nums[find];</span><br><span class="line">                if(sum == target)&#123;</span><br><span class="line">                    ans.push_back(&#123;nums[left],nums[find],nums[right]&#125;);</span><br><span class="line">                    while(find &lt; right &amp;&amp; nums[find] == nums[find+1]) find++;</span><br><span class="line">                    while(find &lt; right &amp;&amp; nums[right] == nums[right-1]) right--;</span><br><span class="line">                    find++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else if(sum &lt; target)&#123;</span><br><span class="line">                    find++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、力扣-18四数之和"><a href="#5、力扣-18四数之和" class="headerlink" title="5、力扣 18四数之和"></a>5、力扣 18四数之和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</span><br><span class="line"></span><br><span class="line">0 &lt;= a, b, c, d &lt; n</span><br><span class="line">a、b、c 和 d 互不相同</span><br><span class="line">nums[a] + nums[b] + nums[c] + nums[d] == target</span><br><span class="line">你可以按 任意顺序 返回答案 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>

<p>题解：这题和三数之和相比就是多嵌套了一层</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0; i &lt; n - 3; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;</span><br><span class="line"></span><br><span class="line">            if ((long)nums[i] + nums[i+1] + nums[i+2] + nums[i+3] &gt; target) break;//前4个元素就是最小的了，如果4个最小加起来还大于目标值，那就没必要看了</span><br><span class="line"></span><br><span class="line">            if ((long)nums[i] + nums[n-1] + nums[n-2] + nums[n-3] &lt; target) continue;//最后三个一定是最大的，如果当前元素加上最后三个还是小于目标值，那就直接continue</span><br><span class="line"></span><br><span class="line">            for(int j = i + 1; j &lt; n - 2; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; //去除重复</span><br><span class="line">                </span><br><span class="line">                int newTarget = target - nums[i] - nums[j]; //目标值是减去i,j后的元素</span><br><span class="line">                if (nums[j+1] + nums[j+2] &gt; newTarget) break;//前两个元素就是最小的了，如果两个最小加起来还大于目标值，那就没必要看了</span><br><span class="line">                if (nums[n-2] + nums[n-1] &lt; newTarget) continue;//最后两个一定是最大的，如果当前元素加上最后两个还是小于目标值，那就直接continue</span><br><span class="line">                </span><br><span class="line">                int left = j + 1, right = n - 1;//下面和仨数之和一样</span><br><span class="line">                while (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    long value = (long)nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    if(value == target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        while(left &lt; right &amp;&amp; nums[left] == nums[left+1]) left++;</span><br><span class="line">                        while(left &lt; right &amp;&amp; nums[right] == nums[right-1]) right--;</span><br><span class="line">                        left ++ ;</span><br><span class="line">                        right -- ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (value &lt; target ) left++;</span><br><span class="line">                    else right -- ;</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6、力扣-454四数相加"><a href="#6、力扣-454四数相加" class="headerlink" title="6、力扣 454四数相加"></a>6、力扣 454四数相加</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</span><br><span class="line"></span><br><span class="line">0 &lt;= i, j, k, l &lt; n</span><br><span class="line">nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>这题我们要将问题换过来思考</p>
<p>abcd四个数相加，可以看成是 (a+b) + (c+d)</p>
<p>分开归纳</p>
<p>用两层循环遍历a，b相加的和的所有可能，存入哈希表中</p>
<p>同样用两层循环遍历c，d相加的和的所有可能，和哈希表中的数值对比</p>
<p>因为target是0，所以看看有没有相反数</p>
<p>有的话就ans++</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;</span><br><span class="line">            int ans=0;</span><br><span class="line">            unordered_map&lt;int,int&gt; A_B_Sum;</span><br><span class="line">            //将nums1和nums2数组中的所有和可能，计数存入哈希表中</span><br><span class="line">            for(int i:nums1)&#123;</span><br><span class="line">                for(int j :nums2)&#123;</span><br><span class="line">                    ++A_B_Sum[i+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //将所有nums3nums4和的可能的相反数，去哈希表中找，即可找到所有和为0的可能</span><br><span class="line">            for(int i:nums3)&#123;</span><br><span class="line">                for(int j:nums4)&#123;</span><br><span class="line">                    if(A_B_Sum.count(-i-j))&#123;</span><br><span class="line">                        ans+=A_B_Sum[-i-j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7、力扣-202快乐数"><a href="#7、力扣-202快乐数" class="headerlink" title="7、力扣 202快乐数"></a>7、力扣 202快乐数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">编写一个算法来判断一个数 n 是不是快乐数。</span><br><span class="line"></span><br><span class="line">「快乐数」 定义为：</span><br><span class="line"></span><br><span class="line">对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</span><br><span class="line">然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</span><br><span class="line">如果这个过程 结果为 1，那么这个数就是快乐数。</span><br><span class="line">如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>这题的关键在于重复</p>
<p>当sum的重复为1时，就为真</p>
<p>当sum的重复为其他时，就为假</p>
<p>用一个哈希记录所有sum可能</p>
<p>如果在哈希中遇到一样的，就看时什么</p>
<p>如果没遇到过就加入到哈希中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int n_sum(int n)&#123;</span><br><span class="line">       int sum =0;</span><br><span class="line">       while(n)&#123;</span><br><span class="line">           sum += (n%10)* (n%10);</span><br><span class="line">           n/=10;</span><br><span class="line">       &#125;</span><br><span class="line">       return sum;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   bool isHappy(int n) &#123;</span><br><span class="line">       unordered_map&lt;int,int&gt;check;</span><br><span class="line">       while(true)&#123;</span><br><span class="line">           int sum = n_sum(n);</span><br><span class="line">           if(check.empty() || check.count(sum) == 0)&#123;</span><br><span class="line">               ++check[sum];</span><br><span class="line">           &#125;else if(check.count(sum) != 0 &amp;&amp; sum==1) </span><br><span class="line">               return true;</span><br><span class="line">           else if(check.count(sum) != 0 &amp;&amp; sum!=1) </span><br><span class="line">               return false;</span><br><span class="line">           n=sum;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="8、力扣-383赎金信"><a href="#8、力扣-383赎金信" class="headerlink" title="8、力扣 383赎金信"></a>8、力扣 383赎金信</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</span><br><span class="line"></span><br><span class="line">如果可以，返回 true ；否则返回 false 。</span><br><span class="line"></span><br><span class="line">magazine 中的每个字符只能在 ransomNote 中使用一次。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>题解：因为有个条件：magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<p>所以这题就变成了，ransomNote 中出现的字符，是不是都在magazine中出现的过</p>
<p>和异位词有异曲同工之处。先记录magazine 中每个字符出现的次数</p>
<p>然后遍历ransomNote，开始进行删减</p>
<p>如果哈希数组中出现了负数值，那么说明ransomNote中有magazine没有的字符</p>
<p>return false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">        int cheak[27] = &#123;0&#125;;</span><br><span class="line">        for(char ch:magazine)&#123;</span><br><span class="line">            cheak[ch-&#x27;a&#x27;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(char ch : ransomNote)&#123;</span><br><span class="line">            cheak[ch-&#x27;a&#x27;]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i: cheak)&#123;</span><br><span class="line">            if(i &lt; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2、有序表"><a href="#2、有序表" class="headerlink" title="2、有序表"></a>2、有序表</h2><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt;map</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同上</span><br></pre></td></tr></table></figure>

<p>判断元素是否在表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.count(val) &gt; 0 ? true:false</span><br></pre></td></tr></table></figure>



<h1 id="六、并查集"><a href="#六、并查集" class="headerlink" title="六、并查集"></a>六、并查集</h1><p>并查集用于处理不相交集合的合并和查询操作。它主要支持两种操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查找（Find）：查找元素所属的集合（或者称为根节点）。这个操作通常用于确定两个元素是否属于同一个集合，即检查它们的根节点是否相同。</span><br><span class="line"></span><br><span class="line">合并（Union）：将两个集合合并为一个集合。这个操作通常在查找操作之后进行，如果发现两个元素属于不同的集合，则将它们所在的两个集合合并为一个。</span><br></pre></td></tr></table></figure>

<p>并查集通常使用一个数组来实现，数组的每个元素代表一个节点，数组的值代表该节点的父节点（或者根节点）。通过路径压缩（Path Compression）和按秩合并（Union by Rank）等优化技术，可以使得查找和合并操作的时间复杂度接近于常数。</p>
<p>并查集在解决一些图论和连通性问题时非常有用</p>
<h6 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br></pre></td></tr></table></figure>

<p>成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent; // 存储每个节点的父节点</span><br><span class="line">    int count; // 集合数量</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>

<p>  &#x2F;&#x2F;构造函数：初始化并查集，每个节点都是一个单独的集合，初始时父节点指向自身</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UnionFind(int n) &#123;</span><br><span class="line">      count = n;</span><br><span class="line">      parent.resize(n);</span><br><span class="line">      for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">          parent[i] = i;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    &#x2F;&#x2F; 查找函数：找到节点 p 所在集合的根节点，并进行路径压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int find(int p) &#123;</span><br><span class="line">        while (p != parent[p]) &#123;</span><br><span class="line">            parent[p] = parent[parent[p]]; // 路径压缩：将节点 p 的父节点指向父节点的父节点</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    &#x2F;&#x2F; 合并函数：将节点 p 和节点 q 所在的集合进行合并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void unite(int p, int q) &#123;</span><br><span class="line">       int rootP = find(p); // 找到节点 p 的根节点</span><br><span class="line">       int rootQ = find(q); // 找到节点 q 的根节点</span><br><span class="line">       if (rootP == rootQ) return; // 如果节点 p 和节点 q 已经在同一个集合中，则不进行合并操作</span><br><span class="line">       parent[rootP] = rootQ; // 将节点 p 的根节点的父节点指向节点 q 的根节点</span><br><span class="line">       count--; // 集合数量减少一个</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    &#x2F;&#x2F; 获取当前集合数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int getCount() &#123;</span><br><span class="line">       return count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="七、二叉树"><a href="#七、二叉树" class="headerlink" title="七、二叉树"></a>七、二叉树</h1><h2 id="Ⅰ、种类"><a href="#Ⅰ、种类" class="headerlink" title="Ⅰ、种类"></a>Ⅰ、种类</h2><h4 id="1、满二叉树"><a href="#1、满二叉树" class="headerlink" title="1、满二叉树"></a>1、满二叉树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		root</span><br><span class="line">left  / 	\ right</span><br><span class="line">	node    node</span><br><span class="line">	/  \    /  \</span><br><span class="line">node  node node node</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">深度为k的满二叉树，结点数量为</span><br><span class="line">2^k - 1；</span><br></pre></td></tr></table></figure>

<h3 id="2、完全二叉树"><a href="#2、完全二叉树" class="headerlink" title="2、完全二叉树"></a>2、完全二叉树</h3><p>除了底层没满，其他都满，并且底层必须从左到右连续</p>
<p>满二叉树 是 完全二叉树</p>
<p>堆也是通过完全二叉树实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		root</span><br><span class="line">left  / 	\ right</span><br><span class="line">	node    node</span><br><span class="line">	/  \    /  \</span><br><span class="line">node  node </span><br></pre></td></tr></table></figure>

<h3 id="3、二叉搜索树"><a href="#3、二叉搜索树" class="headerlink" title="3、二叉搜索树"></a>3、二叉搜索树</h3><p>有顺序</p>
<p>所有结点都满足 ：一个结点的左子树都小于它，右子树都大于它</p>
<p>搜索一个结点的时间复杂度是 log n</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		6</span><br><span class="line">left  / 	</span><br><span class="line">	  3      </span><br><span class="line">	/  \    </span><br><span class="line">   1   4   </span><br></pre></td></tr></table></figure>

<h3 id="4、平衡二叉搜索树"><a href="#4、平衡二叉搜索树" class="headerlink" title="4、平衡二叉搜索树"></a>4、平衡二叉搜索树</h3><p>左子树和右子树的高度绝对值不超过 <strong>1</strong></p>
<p>常见使用平衡二叉搜索树的数据结构 ：map 、set 、multimap 、multiset</p>
<p>使用平衡二叉搜索树的数据结构 插入搜索的时间复杂度都是 log n</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">		root</span><br><span class="line">left  / 	\ right</span><br><span class="line">	node    node</span><br><span class="line">	/  \    /  \</span><br><span class="line">node  node </span><br><span class="line">/</span><br><span class="line">node</span><br></pre></td></tr></table></figure>

<h2 id="Ⅱ、存储方式"><a href="#Ⅱ、存储方式" class="headerlink" title="Ⅱ、存储方式"></a>Ⅱ、存储方式</h2><h3 id="1、链式存储"><a href="#1、链式存储" class="headerlink" title="1、链式存储"></a>1、链式存储</h3><p>用链表实现</p>
<h3 id="2、线性存储"><a href="#2、线性存储" class="headerlink" title="2、线性存储"></a>2、线性存储</h3><p>用数组实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">		a(0)</span><br><span class="line">left  / 	\ right</span><br><span class="line">	b(1)    c(2)</span><br><span class="line">	/  \    /  \</span><br><span class="line">d(3)  e(4) f(5) g(6)</span><br><span class="line"></span><br><span class="line">num[] =&quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">某个结点的左子树</span><br><span class="line">2*i+1</span><br><span class="line"></span><br><span class="line">某个结点的右子树</span><br><span class="line">2*i+2</span><br></pre></td></tr></table></figure>

<h2 id="Ⅲ、二叉树的遍历"><a href="#Ⅲ、二叉树的遍历" class="headerlink" title="Ⅲ、二叉树的遍历"></a>Ⅲ、二叉树的遍历</h2><h3 id="1、深度优先遍历"><a href="#1、深度优先遍历" class="headerlink" title="1、深度优先遍历"></a>1、深度优先遍历</h3><h6 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h6><p>根左右</p>
<h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><p>左根右</p>
<h6 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h6><p>左右根</p>
<p>递归 &#x2F;迭代（用栈来模拟递归）</p>
<h3 id="2、广度优先遍历"><a href="#2、广度优先遍历" class="headerlink" title="2、广度优先遍历"></a>2、广度优先遍历</h3><p>层次遍历（用队列来模拟）</p>
<h2 id="Ⅳ、定义"><a href="#Ⅳ、定义" class="headerlink" title="Ⅳ、定义"></a>Ⅳ、定义</h2><h6 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	TreeNode(int x): val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="递归前序遍历（中后遍历就是换个顺序）"><a href="#递归前序遍历（中后遍历就是换个顺序）" class="headerlink" title="递归前序遍历（中后遍历就是换个顺序）"></a>递归前序遍历（中后遍历就是换个顺序）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 递归前序遍历二叉树	深度优先搜索</span><br><span class="line">void firstTravel(TreeNode *root,vector&lt;int&gt;&amp; ans)&#123;</span><br><span class="line">        if(root == nullptr) return;</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        firstTravel(root-&gt;left,ans);</span><br><span class="line">        firstTravel(root-&gt;right,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代前序遍历"><a href="#迭代前序遍历" class="headerlink" title="迭代前序遍历"></a>迭代前序遍历</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        if(root) st.push(root); </span><br><span class="line">        while(!st.empty())&#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            ans.push_back(node-&gt;val);</span><br><span class="line">            if(node-&gt;right) st.push(node-&gt;right);</span><br><span class="line">            if(node-&gt;left) st.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代中序遍历"><a href="#迭代中序遍历" class="headerlink" title="迭代中序遍历"></a>迭代中序遍历</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        while(curr||!st.empty())&#123;</span><br><span class="line">            while(curr)&#123;	//先遍历左子树</span><br><span class="line">                st.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = st.top();//获得根</span><br><span class="line">            st.pop();</span><br><span class="line">            ans.push_back(curr-&gt;val);</span><br><span class="line">            </span><br><span class="line">            curr = curr-&gt;right;//遍历右子树</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="迭代后序遍历"><a href="#迭代后序遍历" class="headerlink" title="迭代后序遍历"></a>迭代后序遍历</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* prev = nullptr; //prev 的作用是用来追踪上一个访问的节点。它主要用于判断当前节点的右子节点是否已经被访问过。</span><br><span class="line">        while (root || !st.empty()) &#123;</span><br><span class="line">            while (root) &#123;	//遍历左子树</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            root = st.top();//遍历右子树</span><br><span class="line">            if (root-&gt;right &amp;&amp; root-&gt;right != prev) &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; else &#123;//没有右子树,或者右子树已经遍历过了，再获取根</span><br><span class="line">                ans.push_back(root-&gt;val);</span><br><span class="line">                st.pop();</span><br><span class="line">                prev = root;</span><br><span class="line">                root = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        if(root == nullptr) return ans;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!q1.empty())&#123;</span><br><span class="line">            int len = q1.size();	//每一层的结点数，就是当前队列里的元素数量</span><br><span class="line">            ans.push_back(vector &lt;int&gt; ());//这一行代码创建了一个空的向量，并将其添加到结果数组 当前层的节点值创建了一个新的分组</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                auto node = q1.front(); q1.pop();</span><br><span class="line">                ans.back().push_back(node-&gt;val);	//将当前节点的值添加到这个刚刚添加的向量中</span><br><span class="line">                if (node-&gt;left) q1.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q1.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Ⅴ、例题"><a href="#Ⅴ、例题" class="headerlink" title="Ⅴ、例题"></a>Ⅴ、例题</h2><h3 id="1、-力扣-226-翻转二叉树"><a href="#1、-力扣-226-翻转二叉树" class="headerlink" title="1、 力扣 226 翻转二叉树"></a>1、 力扣 226 翻转二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>从根节点开始左右互换，递归往下，直到根结点为空</p>
<p>根左右，所以是<strong>前序遍历</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        //交换,处理中间结点</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        node = root-&gt;left;</span><br><span class="line">        root -&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = root-&gt;left;</span><br><span class="line">        //遍历左右子树</span><br><span class="line">        if(root-&gt;left) invertTree(root-&gt;left);</span><br><span class="line">        if(root-&gt;right) invertTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、-力扣-101-对称二叉树"><a href="#2、-力扣-101-对称二叉树" class="headerlink" title="2、 力扣 101 对称二叉树"></a>2、 力扣 101 对称二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给你一个二叉树的根节点 root ， 检查它是否轴对称。</span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br><span class="line">提示：</span><br><span class="line">树中节点数目在范围 [1, 1000] 内</span><br><span class="line">-100 &lt;= Node.val &lt;= 100</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>本题也可以看成两个二叉树是否可以翻转后相等</p>
<p>也可以看成是同时遍历两个二叉树</p>
<p>因为本题我们需要收割子树，最后再判断根，所以用<strong>后序遍历</strong></p>
<p>递归-后序遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool compare(TreeNode* root1, TreeNode* root2)&#123;//对比两个结点是否相同</span><br><span class="line">        if(root1 == nullptr &amp;&amp; root2 !=nullptr) return false;</span><br><span class="line">        else if(root1 != nullptr &amp;&amp; root2 ==nullptr) return false;</span><br><span class="line">        else if(!root1 &amp;&amp; !root2) return true;//两个都为空肯定相同</span><br><span class="line">        else if(root1-&gt;val != root2-&gt;val) return false;</span><br><span class="line">        </span><br><span class="line">        return compare(root1-&gt;left,root2-&gt;right) &amp;&amp; compare(root1-&gt;right,root2-&gt;left);//注意对称二叉树需要对比的是内外对应</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        return compare(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>迭代</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化时我们把根节点入队两次。</span><br><span class="line">每次提取两个结点并比较它们的值</span><br><span class="line">然后将两个结点的左右子结点按相反的顺序插入队列中。</span><br><span class="line">当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">       queue&lt;TreeNode*&gt;q1;</span><br><span class="line">       q1.push(root);</span><br><span class="line">       q1.push(root);</span><br><span class="line">       while(!q1.empty())&#123;</span><br><span class="line">            TreeNode* node1 = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            TreeNode* node2 = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line"></span><br><span class="line">            if(!node1 &amp;&amp; !node2) continue;</span><br><span class="line">            if(!node1 || !node2) return false;</span><br><span class="line">            if(node1-&gt;val != node2-&gt;val) return false;</span><br><span class="line"></span><br><span class="line">            q1.push(node1-&gt;left);q1.push(node2-&gt;right);</span><br><span class="line">            q1.push(node1-&gt;right);q1.push(node2-&gt;left);</span><br><span class="line">       &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、-力扣104-二叉树的最大深度"><a href="#3、-力扣104-二叉树的最大深度" class="headerlink" title="3、 力扣104 二叉树的最大深度"></a>3、 力扣104 二叉树的最大深度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树 root ，返回其最大深度。</span><br><span class="line"></span><br><span class="line">二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数</span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<h6 id="什么是深度？什么是高度？"><a href="#什么是深度？什么是高度？" class="headerlink" title="什么是深度？什么是高度？"></a>什么是深度？什么是高度？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">深度是二叉树里从根节点到某个节点的唯一路径的长度	（先序遍历求）</span><br><span class="line"></span><br><span class="line">高度是二叉树种任意一个结点到叶子节点的最长距离 （后序遍历求）</span><br></pre></td></tr></table></figure>

<p>本题求的虽然是二叉树的最大深度</p>
<p>但其实是求根节点的最大高度</p>
<p>所以用<strong>后序遍历</strong></p>
<p>递归去求左子树和右子树最大深度</p>
<p>根的深度就是子树最大深度+1；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode* root) &#123;</span><br><span class="line">    if (!root) return 0;</span><br><span class="line">       return 1+max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、-力扣-111-二叉树的最小深度"><a href="#4、-力扣-111-二叉树的最小深度" class="headerlink" title="4、 力扣 111 二叉树的最小深度"></a>4、 力扣 111 二叉树的最小深度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，找出其最小深度。</span><br><span class="line"></span><br><span class="line">最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span><br><span class="line"></span><br><span class="line">说明：叶子节点是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p>本题用迭代法更简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        int deep =1;</span><br><span class="line">        while(!q1.empty())&#123;</span><br><span class="line">            int len = q1.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode* node = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                if(node-&gt;left) q1.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right) q1.push(node-&gt;right);</span><br><span class="line">                if(!node-&gt;left &amp;&amp; !node-&gt;right) return deep;</span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">        return deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然递归也能做，加两个如果左右有一个为空，那么就返回不为空的那个子树长度＋1</p>
<p>本体时从下往上，<strong>后序遍历</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right) return 1+minDepth(root-&gt;right);</span><br><span class="line">        if(root-&gt;left &amp;&amp; root-&gt;right == nullptr) return 1+minDepth(root-&gt;left);</span><br><span class="line">        return min(minDepth(root-&gt;left),minDepth(root-&gt;right))+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、-力扣-222-完全二叉树的结点个数"><a href="#5、-力扣-222-完全二叉树的结点个数" class="headerlink" title="5、 力扣 222 完全二叉树的结点个数"></a>5、 力扣 222 完全二叉树的结点个数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</span><br><span class="line"></span><br><span class="line">完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：0</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：root = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>普通二叉树直接遍历计数就行，此处用的是<strong>后序遍历</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(!root) return 0;</span><br><span class="line">return countNodes(root-&gt;left) + countNodes(root-&gt;right) +1;</span><br></pre></td></tr></table></figure>

<p>但这题是完全二叉树，我们可以利用他的性质</p>
<p>一个深度为k的满二叉树，结点数量为2^k-1</p>
<p>而完全二叉树是底层从右往左缺少结点的二叉树。所以如果可以证明左子树是满二叉树，能快一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int countNodes(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        TreeNode* left = root;</span><br><span class="line">        TreeNode* right =root;</span><br><span class="line">        int deep=0;</span><br><span class="line">        while(left &amp;&amp; right)&#123;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!left &amp;&amp; !right) return pow(2,deep)-1;</span><br><span class="line">        else</span><br><span class="line">            return countNodes(root-&gt;left) + countNodes(root-&gt;right) +1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、力扣-110-平衡二叉树"><a href="#6、力扣-110-平衡二叉树" class="headerlink" title="6、力扣 110 平衡二叉树"></a>6、力扣 110 平衡二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，判断它是否是 </span><br><span class="line">平衡二叉树</span><br><span class="line">  </span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>计算每个结点的左右子树高度，其差值的绝对值超过1的就返回-1</p>
<p>如果已经有一个为-1，那这棵树就不是平衡二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int getHeight(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line"></span><br><span class="line">        int left,right;</span><br><span class="line">        left = getHeight(root-&gt;left);</span><br><span class="line">        if(left == -1) return -1;</span><br><span class="line"></span><br><span class="line">        right = getHeight(root-&gt;right);</span><br><span class="line">        if(right == -1) return -1;</span><br><span class="line"></span><br><span class="line">        return abs(left-right) &gt; 1 ?  -1 : 1+max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return getHeight(root) == -1 ? false : true;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-、-力扣-257-二叉树的所有路径"><a href="#7-、-力扣-257-二叉树的所有路径" class="headerlink" title="7 、 力扣 257 二叉树的所有路径"></a>7 、 力扣 257 二叉树的所有路径</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</span><br><span class="line"></span><br><span class="line">叶子节点 是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [1]</span><br><span class="line">输出：[&quot;1&quot;]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>深度优先算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void dfs(TreeNode* root,string path,vector&lt;string&gt;&amp; ans)&#123;</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            path += to_string(root-&gt;val);</span><br><span class="line">            if(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">                ans.push_back(path);</span><br><span class="line">            else&#123;</span><br><span class="line">                path+=&quot;-&gt;&quot;;</span><br><span class="line">                dfs(root-&gt;left,path,ans);</span><br><span class="line">                dfs(root-&gt;right,path,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;string&gt;ans;</span><br><span class="line">        string s=&quot;&quot;;</span><br><span class="line">        dfs(root,s,ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、力扣-404-左叶子之和"><a href="#8、力扣-404-左叶子之和" class="headerlink" title="8、力扣 404 左叶子之和"></a>8、力扣 404 左叶子之和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树的根节点 root ，返回所有左叶子之和。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: root = [3,9,20,null,null,15,7] </span><br><span class="line">输出: 24 </span><br><span class="line">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>​	所谓左叶子，就是每一层最左边的叶子结点。用层序遍历更简单。</p>
<p>（1）深搜解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ans=0;</span><br><span class="line">void dfs(TreeNode* root,bool is_left)&#123;</span><br><span class="line">    if(root)&#123;</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; is_left)&#123;</span><br><span class="line">            ans+=root-&gt;val;</span><br><span class="line">        &#125;else if(root-&gt;left || root-&gt;right)&#123;</span><br><span class="line">            dfs(root-&gt;left,true);</span><br><span class="line">            dfs(root-&gt;right,false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">    dfs(root,false);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) return 0;</span><br><span class="line">        if (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) return 0;</span><br><span class="line"></span><br><span class="line">        int leftValue = sumOfLeftLeaves(root-&gt;left);    // 左</span><br><span class="line">        if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; // 左子树就是一个左叶子的情况</span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        int rightValue = sumOfLeftLeaves(root-&gt;right);  // 右</span><br><span class="line"></span><br><span class="line">        int sum = leftValue + rightValue;               // 中</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（3）、迭代法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        int ans=0;</span><br><span class="line">        while(!q1.empty())&#123;</span><br><span class="line">            int len = q1.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;    </span><br><span class="line">                TreeNode* node = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                if(node-&gt;left)&#123;</span><br><span class="line">                    q1.push(node-&gt;left);</span><br><span class="line">                    if(!node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)</span><br><span class="line">                        ans+=node-&gt;left-&gt;val;</span><br><span class="line">                &#125; </span><br><span class="line">                if(node-&gt;right) q1.push(node-&gt;right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、力扣-513-找到树左下角的值"><a href="#9、力扣-513-找到树左下角的值" class="headerlink" title="9、力扣 513 找到树左下角的值"></a>9、力扣 513 找到树左下角的值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</span><br><span class="line">假设二叉树中至少有一个节点。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>本题用其他方法还需要考虑左右子树那边更高</p>
<p>还是迭代好</p>
<p>迭代法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt;q1;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        int ans;</span><br><span class="line">        while(!q1.empty())&#123;</span><br><span class="line">            int len=q1.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode* node = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                if(i==0) ans = node-&gt;val;</span><br><span class="line">                if(node-&gt;left) q1.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right) q1.push(node-&gt;right); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10、力扣-112-路径总和"><a href="#10、力扣-112-路径总和" class="headerlink" title="10、力扣 112 路径总和"></a>10、力扣 112 路径总和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</span><br><span class="line"></span><br><span class="line">叶子节点 是指没有子节点的节点。</span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>深度优先搜索，将每一条路径记录下来，左子树和右子树，有一个满足就可以了</p>
<p>如果到叶子节点或者根节点不存在，那就返回false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(TreeNode* root,int targetSum ,int sum)&#123;</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">            if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">              return  sum == targetSum ;</span><br><span class="line">            &#125;</span><br><span class="line">            return dfs(root-&gt;left,targetSum,sum) || dfs(root-&gt;right,targetSum,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        return dfs(root,targetSum,0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、-力扣-106-从中序与后序遍历序列构造二叉树"><a href="#11、-力扣-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="11、 力扣 106 从中序与后序遍历序列构造二叉树"></a>11、 力扣 106 从中序与后序遍历序列构造二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入：inorder = [-1], postorder = [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>利用后序遍历确定根节点</p>
<p>利用中序遍历确定左右子树范围</p>
<p>递归创建</p>
<p>注意vector截取数组是<strong>左闭右开</strong>区间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if (postorder.empty() || inorder.empty()) return nullptr;</span><br><span class="line"></span><br><span class="line">        int root_val = postorder.back();</span><br><span class="line">        TreeNode* node = new TreeNode(root_val);</span><br><span class="line">        </span><br><span class="line">        auto index = find(inorder.begin(),inorder.end(),root_val);</span><br><span class="line">        auto begin = inorder.begin();</span><br><span class="line">        int len = index - begin;</span><br><span class="line">        </span><br><span class="line">        //vcetor这个创建是左闭右开区间</span><br><span class="line">        vector&lt;int&gt; left_in(inorder.begin(), index);</span><br><span class="line">        vector&lt;int&gt; left_post(postorder.begin(), postorder.begin()+len);</span><br><span class="line">        </span><br><span class="line">        //右子树创建时要跳过root</span><br><span class="line">        vector&lt;int&gt; right_in(index+1, inorder.end());</span><br><span class="line">        vector&lt;int&gt; right_post(postorder.begin()+len, postorder.end()-1);</span><br><span class="line">        </span><br><span class="line">        node-&gt;left = buildTree(left_in, left_post);</span><br><span class="line">        node-&gt;right = buildTree(right_in, right_post);</span><br><span class="line">        </span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 下标法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int,int&gt;indexMap;</span><br><span class="line"></span><br><span class="line">    TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int start_in, int end_in, int start_post, int end_post) &#123;</span><br><span class="line">    if (start_in &gt; end_in) return nullptr;</span><br><span class="line"></span><br><span class="line">    int rootVal = postorder[end_post];</span><br><span class="line">    int rootIndex = indexMap[rootVal];</span><br><span class="line">    TreeNode* root = new TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">    // 构建左子树</span><br><span class="line">    int left_size = rootIndex - start_in;</span><br><span class="line">    root-&gt;left = build(inorder, postorder, start_in, rootIndex - 1, start_post, start_post + left_size - 1);</span><br><span class="line">    // 构建右子树</span><br><span class="line">    root-&gt;right = build(inorder, postorder, rootIndex + 1, end_in, start_post + left_size, end_post - 1);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        for(int i=0;i&lt;inorder.size();i++)</span><br><span class="line">            indexMap[inorder[i]] = i;</span><br><span class="line">        int index = postorder.size()-1;</span><br><span class="line">        return build(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">inorder   = [9,3,15,20,7]</span><br><span class="line">postorder = [9,15,7,20,3]</span><br><span class="line"></span><br><span class="line">start_in=0,end_in=4,start_post=0 ,end_post = 4</span><br><span class="line"></span><br><span class="line">rootVal = postorder[end_post] = 3 </span><br><span class="line">rootIndex = indexMap[rootVal] = 1</span><br><span class="line"></span><br><span class="line">leftsize =rootIndex - start_in = 1 - 0 = 1</span><br><span class="line"></span><br><span class="line">左子树 -&gt; 中序 [9] （start_in:start_in      end_in: rootIndex-1）</span><br><span class="line">	  -&gt; 后序 [9] (start_post:start_post  end_post:start_post + left_size - 1)</span><br><span class="line">右子树 -&gt; 中序 [15,20,7]	(start_in:rootIndex+1 end_in:end_in)</span><br><span class="line">	  -&gt; 后序 [15,7,20] (start_post:start_post+left_size,end_post:end_post-1)</span><br><span class="line">	  </span><br><span class="line">	  inorder [9]</span><br><span class="line">	  postorder[9]</span><br><span class="line">	  inorder [15,20,7]</span><br><span class="line">	  postorder [15,7,20]</span><br><span class="line">..............</span><br></pre></td></tr></table></figure>

<h3 id="12、-力扣-654-最大二叉树"><a href="#12、-力扣-654-最大二叉树" class="headerlink" title="12、 力扣 654 最大二叉树"></a>12、 力扣 654 最大二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</span><br><span class="line"></span><br><span class="line">创建一个根节点，其值为 nums 中的最大值。</span><br><span class="line">递归地在最大值 左边 的 子数组前缀上 构建左子树。</span><br><span class="line">递归地在最大值 右边 的 子数组后缀上 构建右子树。</span><br><span class="line">返回 nums 构建的 最大二叉树 。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>和上题类似，不过根结点是数组中最大的数，根节点左右两边的子数组为左右子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    int find_max(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(nums[i] &gt; nums[max]) max = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty()) return nullptr;</span><br><span class="line">        int index = find_max(nums);</span><br><span class="line">        TreeNode* node = new TreeNode(nums[index]);</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt;left(nums.begin(),nums.begin()+index);</span><br><span class="line">        vector&lt;int&gt;right(nums.begin()+index+1,nums.end());</span><br><span class="line">        </span><br><span class="line">        node-&gt;left = constructMaximumBinaryTree(left);</span><br><span class="line">        node-&gt;right =  constructMaximumBinaryTree(right);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        TreeNode* root = new TreeNode(nums[0]);</span><br><span class="line">        for(int i=1;i&lt;nums.size();i++)&#123;</span><br><span class="line">            TreeNode* node = new TreeNode(nums[i]);</span><br><span class="line"></span><br><span class="line">            if(nums[i] &lt; root-&gt;val)&#123;</span><br><span class="line">                TreeNode* pre = root;</span><br><span class="line">                while(pre-&gt;right &amp;&amp; pre-&gt;right-&gt;val &gt; nums[i]) pre = pre-&gt;right;</span><br><span class="line">                </span><br><span class="line">                if(!pre-&gt;right)&#123;</span><br><span class="line">                    pre-&gt;right = node;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    node-&gt;left = pre-&gt;right;</span><br><span class="line">                    pre-&gt;right = node;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                   node-&gt;left = root;</span><br><span class="line">                   root = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>单调栈解法</p>
<p>栈顶元素永远是根节点</p>
<p>如果新元素比栈顶元素大，那栈顶元素就是他的左结点</p>
<p>如果栈顶元素比它大，那它就是栈顶元素的右结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">当我们遇到元素 3 时，我们将其作为根节点，放入单调栈中。</span><br><span class="line"></span><br><span class="line">Stack: [3]</span><br><span class="line">当我们遇到元素 2 时，我们发现其比栈顶元素 3 小，因此 2 应该是 3 的右子节点。我们将 2 放入栈中。</span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">Stack: [3, 2]</span><br><span class="line"></span><br><span class="line">当我们遇到元素 1 时，我们发现其比栈顶元素 2 小，1 应该是 2 的右子节点。因此，我们需要将 1 放入栈中</span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    1</span><br><span class="line"></span><br><span class="line">Stack: [3,2,1]</span><br><span class="line"></span><br><span class="line">当我们遇到元素 6 时，我们发现其比栈顶元素 1 大，不断弹出栈内比6小的元素直到栈空，将他们变成6的左子树</span><br><span class="line">6-&gt;left = 1 -&gt; =2 -&gt; =3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line">   /</span><br><span class="line">  3</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">Stack: [6]</span><br><span class="line"></span><br><span class="line">然后我们继续遍历数组，当遇到元素 0 时，我们发现其比栈顶元素 6 小，因此 0 应该是 6 的右子节点。</span><br><span class="line"></span><br><span class="line">     6</span><br><span class="line">   /   \</span><br><span class="line">  3     0</span><br><span class="line">   \     </span><br><span class="line">    2   </span><br><span class="line">     \   </span><br><span class="line">      1 </span><br><span class="line">Stack: [6,0]</span><br><span class="line"></span><br><span class="line">最后，当遇到元素 5 时，我们发现其比栈顶元素 0 大，因此 5 应该是 0 的父亲节点，0变成5的左节点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     6</span><br><span class="line">   /   \</span><br><span class="line">  3     5</span><br><span class="line">   \   /   </span><br><span class="line">    2 0   </span><br><span class="line">     \   </span><br><span class="line">      1 </span><br><span class="line">Stack: []</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        for(int i:nums)&#123;</span><br><span class="line">            TreeNode* node = new TreeNode(i);</span><br><span class="line">            while(!st.empty() &amp;&amp; st.top()-&gt;val &lt; i)&#123;//确保栈顶是根</span><br><span class="line">                node-&gt;left = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if(!st.empty())&#123;</span><br><span class="line">                st.top()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = nullptr; </span><br><span class="line">        while (!st.empty()) &#123; //栈顶元素是根节点</span><br><span class="line">            root = st.top(); </span><br><span class="line">            st.pop(); </span><br><span class="line">        &#125;</span><br><span class="line">        return root; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、-力扣-617-合并二叉树"><a href="#13、-力扣-617-合并二叉树" class="headerlink" title="13、 力扣 617 合并二叉树"></a>13、 力扣 617 合并二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</span><br><span class="line"></span><br><span class="line">返回合并后的二叉树。</span><br><span class="line"></span><br><span class="line">注意: 合并过程必须从两个树的根节点开始。</span><br><span class="line">示例 1：</span><br><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：root1 = [1], root2 = [1,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>同时操控两个二叉树，当左右子树都存在的时候，把2数的值加到1树上</p>
<p>如果有任何一颗子树存在，而另一颗不存在，返回对应的子树就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        if(!root1) return root2;//如果该位置root1为空，就链接root2</span><br><span class="line">        if(!root2) return root1;//同上</span><br><span class="line">        </span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        </span><br><span class="line">        root1-&gt;left = mergeTrees(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root1-&gt;right = mergeTrees(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        </span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="14、-力扣-700-二叉树中的搜索"><a href="#14、-力扣-700-二叉树中的搜索" class="headerlink" title="14、 力扣 700 二叉树中的搜索"></a>14、 力扣 700 二叉树中的搜索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</span><br><span class="line"></span><br><span class="line">你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：root = [4,2,7,1,3], val = 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>利用二叉搜索树的性质，左子树必定小于根节点，右子树必定大于根结点，并且对于所有结点生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if(!root || root-&gt;val == val) return root;</span><br><span class="line">        </span><br><span class="line">        while( root &amp;&amp; (root-&gt;left  || root-&gt;right))&#123;</span><br><span class="line">            root = root-&gt; val &gt; val ? root-&gt;left : root-&gt;right;</span><br><span class="line">            if(root &amp;&amp; root-&gt;val == val) return root;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="15、力扣-98-验证二叉搜索树"><a href="#15、力扣-98-验证二叉搜索树" class="headerlink" title="15、力扣 98 验证二叉搜索树"></a>15、力扣 98 验证二叉搜索树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</span><br><span class="line"></span><br><span class="line">有效 二叉搜索树定义如下：</span><br><span class="line"></span><br><span class="line">节点的左</span><br><span class="line">子树</span><br><span class="line">只包含 小于 当前节点的数。</span><br><span class="line">节点的右子树只包含 大于 当前节点的数。</span><br><span class="line">所有左子树和右子树自身必须也是二叉搜索树。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>利用二叉搜索树的另一个性质：二叉搜索树的中序遍历应该是单调递增的序列</p>
<p>1、利用数组存储二叉搜索树的<strong>中序遍历</strong>，然后确认数组是否是单调递增</p>
<p>2、利用双指针，一个用来记录上一个结点（中序左右根），也就是左子树的结点，在根处判断，如果根小于左子树，那必然不是二叉搜索树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //中序遍历应该是单调增</span><br><span class="line">    TreeNode * pre=nullptr;//双指针法，pre记录上一个节点</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        bool left =isValidBST(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        if(pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false;//如果当前节点比上一个节点大</span><br><span class="line">        pre = root;</span><br><span class="line">        </span><br><span class="line">        bool right =isValidBST(root-&gt;right);</span><br><span class="line">        return left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="16、-力扣-530-二叉搜索树的最小绝对差"><a href="#16、-力扣-530-二叉搜索树的最小绝对差" class="headerlink" title="16、 力扣 530 二叉搜索树的最小绝对差"></a>16、 力扣 530 二叉搜索树的最小绝对差</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</span><br><span class="line"></span><br><span class="line">差值是一个正数，其数值等于两值之差的绝对值。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>利用一个指针记录上一个结点，同时用一个min记录最小差值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int min_c=INT_MAX;</span><br><span class="line">    TreeNode* pre=nullptr;</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        getMinimumDifference(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        if(pre) min_c = min((root-&gt;val - pre-&gt;val) , min_c);</span><br><span class="line">        </span><br><span class="line">        pre =root;</span><br><span class="line">        getMinimumDifference(root-&gt;right);</span><br><span class="line">        return min_c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="17、力扣-501-二叉搜索树中的众数"><a href="#17、力扣-501-二叉搜索树中的众数" class="headerlink" title="17、力扣 501  二叉搜索树中的众数"></a>17、力扣 501  二叉搜索树中的众数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</span><br><span class="line">如果树中有不止一个众数，可以按 任意顺序 返回。</span><br><span class="line">假定 BST 满足如下定义：</span><br><span class="line">结点左子树中所含节点的值 小于等于 当前节点的值</span><br><span class="line">结点右子树中所含节点的值 大于等于 当前节点的值</span><br><span class="line">左子树和右子树都是二叉搜索树</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [1,null,2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>这边要引入用指针求数组中的最大众数集合方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">首先将数组排序，确保一样的数会连续在一起</span><br><span class="line"></span><br><span class="line">然后用一个指针向前移动，相等于上一个元素（nums[i] == nums[i-1]）那就计数++（count++)</span><br><span class="line"></span><br><span class="line">直到不等于当前元素。我们把count置一。同时记录下来最大的出现频率（maxcount）</span><br><span class="line"></span><br><span class="line">先假设当前元素为出现频率最大，放入结果集</span><br><span class="line"></span><br><span class="line">当下一个元素出现频率统计出来后，和maxcount进行对比</span><br><span class="line"></span><br><span class="line">&lt;  maxcount 舍弃不管</span><br><span class="line"></span><br><span class="line">== maxcount	加入结果集合</span><br><span class="line"></span><br><span class="line">&gt;  maxcoutnt	将结果集合清空，并且maxcount == count</span><br></pre></td></tr></table></figure>

<p>同理</p>
<p>二叉搜索树的中序本身就是一个递增的顺序结构，照着改就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    int count = 0;</span><br><span class="line">    int maxCount = 0;</span><br><span class="line">    TreeNode* pre = nullptr;	//指向上一个结点</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    void getZS(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">       	//遍历左子树</span><br><span class="line">        getZS(root-&gt;left);</span><br><span class="line">		//处理中间结点</span><br><span class="line">        if (pre &amp;&amp; (root-&gt;val != pre-&gt;val)) &#123;</span><br><span class="line">            count = 1; // 重置 count</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &gt; maxCount) &#123; // 更新众数</span><br><span class="line">            maxCount = count;</span><br><span class="line">            ans.clear();</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">        &#125; else if (count == maxCount) &#123;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        //处理右子树</span><br><span class="line">        getZS(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        getZS(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="18、-力扣-236-二叉树的最近公共祖先"><a href="#18、-力扣-236-二叉树的最近公共祖先" class="headerlink" title="18、 力扣 236 二叉树的最近公共祖先"></a>18、 力扣 236 二叉树的最近公共祖先</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>首先本题我们需要先找到子树再反过头找根</p>
<p>所以使用<strong>后序遍历</strong></p>
<p>分类讨论</p>
<p>后序遍历树（左右根）</p>
<p>当我左右子树都找不到结点了，那就返回root（此时root为 nullptr）</p>
<p>当我找到的结点等于q或者p，意味着找到了目标结点，那就返回q，p；</p>
<p>左子树找完了，去右子树找</p>
<p>右子树找完了，去左子树找</p>
<p>如果都找到了就返回结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        if(root == q) return q;</span><br><span class="line">        if(root == p) return p;</span><br><span class="line"></span><br><span class="line">        TreeNode* L = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* R = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">        if(!L) return R;</span><br><span class="line">        if(!R) return L;</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="19、力扣-235-二叉搜索树的最近公共祖先"><a href="#19、力扣-235-二叉搜索树的最近公共祖先" class="headerlink" title="19、力扣 235 二叉搜索树的最近公共祖先"></a>19、力扣 235 二叉搜索树的最近公共祖先</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line">例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>因为二叉搜索树是有序的，所以从头开始遍历，如果当前结点大于两个值，那说明在当前结点的左子树中，反之在右子树中</p>
<p>当结点值在两个数之间的时候，那他必然是最小公共祖先</p>
<p>迭代法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        </span><br><span class="line">        while(root)&#123;</span><br><span class="line">            if(root-&gt;val &gt;p-&gt;val &amp;&amp; root-&gt;val &gt;q-&gt;val) </span><br><span class="line">            	root = root-&gt;left;</span><br><span class="line">            else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) </span><br><span class="line">            	root = root -&gt;right;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>递归法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">       if(!root) return root;</span><br><span class="line">       if(root == p) return p;</span><br><span class="line">       if(root == q) return q;</span><br><span class="line"></span><br><span class="line">        if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">           return lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">            return lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="20、-力扣-701-二叉搜索树中的插入操作"><a href="#20、-力扣-701-二叉搜索树中的插入操作" class="headerlink" title="20、 力扣 701 二叉搜索树中的插入操作"></a>20、 力扣 701 二叉搜索树中的插入操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</span><br><span class="line"></span><br><span class="line">注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>按顺序插就行，顺着大小顺序寻找结点</p>
<p>迭代法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        TreeNode* node = new TreeNode(val);</span><br><span class="line">        if(!root) return node;</span><br><span class="line">        </span><br><span class="line">        TreeNode* pre = root; </span><br><span class="line">        TreeNode* cur =pre;//指向上一个结点</span><br><span class="line">        while(pre) &#123;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = pre -&gt;val &gt; val ? pre-&gt;left : pre-&gt;right;</span><br><span class="line">            if(!pre)&#123;</span><br><span class="line">                cur-&gt;val &gt; val ? cur-&gt;left = node : cur-&gt;right = node;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>递归法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        TreeNode* node = new TreeNode(val);</span><br><span class="line">        if(!root) return node;</span><br><span class="line">        if(root -&gt; val &gt; val) </span><br><span class="line">        	root -&gt;left = insertIntoBST(root-&gt;left,val);</span><br><span class="line">        else </span><br><span class="line">        	root-&gt;right = insertIntoBST(root-&gt;right,val);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="21、-力扣-450-删除二叉搜索树中的结点"><a href="#21、-力扣-450-删除二叉搜索树中的结点" class="headerlink" title="21、 力扣 450 删除二叉搜索树中的结点"></a>21、 力扣 450 删除二叉搜索树中的结点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</span><br><span class="line"></span><br><span class="line">一般来说，删除节点可分为两个步骤：</span><br><span class="line"></span><br><span class="line">首先找到需要删除的节点；</span><br><span class="line">如果找到了，删除它。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>要想明白可能的情况</p>
<p>第一种：找不到要删除的结点 -&gt; return root</p>
<p>第二种：当前结点为叶子结点 -&gt;直接删除</p>
<p>第三种 ：当前结点只有右孩子，没有左孩子，让当前结点变成右孩子</p>
<p>第四种 ：当前结点只有左孩子，没有右孩子，让当前结点变成左孩子</p>
<p>第五种：两个子树均不为空，选择让其左子树全连到右子树的左下角中，或者右子树连接到左子树的右下角中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">       if (!root) return root;//第一种情况：没有找到要删除的结点</span><br><span class="line">       if(root-&gt;val == key)&#123;</span><br><span class="line">            if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">                delete root; //第二种情况: 要删除的结点为叶子节点</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!root-&gt;left &amp;&amp; root-&gt;right)&#123;//第三种情况，左子树为空，右子树不为空， 让当前节点变成他的右孩子</span><br><span class="line">                TreeNode* node = root-&gt;right;</span><br><span class="line">                delete root;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">            if(root-&gt;left &amp;&amp; !root-&gt;right)&#123;//第四种情况，右子树为空，左子树不为空， 让当前节点变成他的左孩子</span><br><span class="line">                TreeNode* node = root-&gt;left;</span><br><span class="line">                delete root;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">            if(root-&gt;left &amp;&amp; root-&gt;right)&#123;//第五种情况，两个子树均不为空，选择让其左子树全连到右子树的左下角中，或者右子树连接到左子树的右下角中</span><br><span class="line">                TreeNode* pre = root-&gt;right;</span><br><span class="line">                while(pre-&gt;left) pre = pre-&gt;left;</span><br><span class="line">                pre-&gt;left = root-&gt;left;</span><br><span class="line">                TreeNode* node = root-&gt;right;</span><br><span class="line">                delete root;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left,key);</span><br><span class="line">       if(root-&gt;val &lt; key) root-&gt;right =deleteNode(root-&gt;right,key);</span><br><span class="line">       return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="22、力扣-669-修剪二叉搜索树"><a href="#22、力扣-669-修剪二叉搜索树" class="headerlink" title="22、力扣 669 修剪二叉搜索树"></a>22、力扣 669 修剪二叉搜索树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</span><br><span class="line"></span><br><span class="line">所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>​	如果根节点为空，那就返回空</p>
<p>​	如果结点值小于low，跳过它，连接他的右子树</p>
<p>​	如果节点值大于high，跳过它，连接他的左子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (!root) return nullptr;</span><br><span class="line">        </span><br><span class="line">        // 如果根节点的值小于范围最小值，则修剪右子树</span><br><span class="line">        if (root-&gt;val &lt; low) &#123;</span><br><span class="line">            return trimBST(root-&gt;right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果根节点的值大于范围最大值，则修剪左子树</span><br><span class="line">        if (root-&gt;val &gt; high) &#123;</span><br><span class="line">            return trimBST(root-&gt;left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 递归修剪左右子树</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ps：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在递归方法中，通常情况下不需要手动释放节点的内存，因为递归函数会在递归的过程中动态地创建和销毁节点。当递归函数返回时，栈上的局部变量会自动被销毁，包括每次递归创建的节点，因此不会造成内存泄漏问题</span><br></pre></td></tr></table></figure>

<h3 id="23、-力扣-108-将有序数组转换成二叉搜索树"><a href="#23、-力扣-108-将有序数组转换成二叉搜索树" class="headerlink" title="23、 力扣 108 将有序数组转换成二叉搜索树"></a>23、 力扣 108 将有序数组转换成二叉搜索树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">108. 将有序数组转换为二叉搜索树</span><br><span class="line">简单</span><br><span class="line">相关标签</span><br><span class="line">相关企业</span><br><span class="line">给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 </span><br><span class="line">平衡</span><br><span class="line"> 二叉搜索树。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>每次的根节点是中间的那个数</p>
<p>左右子树是左边界到数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* createTree(vector&lt;int&gt;&amp;nums,int left,int right)&#123;</span><br><span class="line">        if(left &gt; right) return nullptr;</span><br><span class="line"></span><br><span class="line">        int mid = (left+right)/2;</span><br><span class="line">        TreeNode* node = new TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        node-&gt;left = createTree(nums,left,mid-1);</span><br><span class="line">        node-&gt;right = createTree(nums,mid+1,right);</span><br><span class="line">        </span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        return createTree(nums,0,nums.size()-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="24、力扣-538-把二叉搜索树转为累加树"><a href="#24、力扣-538-把二叉搜索树转为累加树" class="headerlink" title="24、力扣 538 把二叉搜索树转为累加树"></a>24、力扣 538 把二叉搜索树转为累加树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</span><br><span class="line">提醒一下，二叉搜索树满足下列约束条件：</span><br><span class="line">节点的左子树仅包含键 小于 节点键的节点。</span><br><span class="line">节点的右子树仅包含键 大于 节点键的节点。</span><br><span class="line">左右子树也必须是二叉搜索树。</span><br><span class="line">注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：root = [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure>

<p>题解</p>
<p>用一个指针记录上一个结点的值</p>
<p>通过右中左的方式遍历，每次根结点加上指针值就可以了</p>
<p>递归法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* pre = nullptr;</span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        if(root-&gt;right) convertBST(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        if(pre)</span><br><span class="line">            root-&gt;val += pre-&gt;val;</span><br><span class="line">            pre = root;</span><br><span class="line">        if(root-&gt;left) convertBST(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>迭代法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        int pre=0;</span><br><span class="line">        while(node || !st.empty())&#123;</span><br><span class="line">            while(node)&#123;</span><br><span class="line">                st.push(node);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            node-&gt;val +=pre;</span><br><span class="line">            pre = node-&gt;val;</span><br><span class="line"></span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8A%9B%E6%89%A3/" rel="tag"># 力扣</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/20/C%20%E7%BB%93%E6%9E%84%E4%BD%93/" rel="prev" title="C 结构体">
      <i class="fa fa-chevron-left"></i> C 结构体
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/" rel="next" title="数据结构（ACwing）">
      数据结构（ACwing） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">常见数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E3%80%81%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">特殊、数组&#x2F;集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.0.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">2.0.2.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#set"><span class="nav-number">2.0.2.0.0.1.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#multiset"><span class="nav-number">2.0.2.0.0.2.</span> <span class="nav-text">multiset</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8A%9B%E6%89%A3704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、力扣	704 二分查找（双指针）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%8A%9B%E6%89%A3-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、力扣 27 移除元素（双指针）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%8A%9B%E6%89%A3-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、力扣 977 有序数组的平方（双指针）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81-%E5%8A%9B%E6%89%A3-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="nav-number">2.1.4.</span> <span class="nav-text">4、 力扣 209 长度最小的子数组（滑动窗口）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%8A%9B%E6%89%A3-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88%E6%A8%A1%E6%8B%9F%E9%81%8D%E5%8E%86%EF%BC%89"><span class="nav-number">2.1.5.</span> <span class="nav-text">5、力扣 54 螺旋矩阵（模拟遍历）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">一、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%88c-%E4%B8%AD%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">实现（c++中需要手动实现）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">在指定位置插入链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="nav-number">3.2.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8A%9B%E6%89%A3-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">3.2.1.</span> <span class="nav-text">1、力扣 203 移除链表元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81-%E5%8A%9B%E6%89%A3-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-number">3.2.2.</span> <span class="nav-text">2、 力扣 707 设计链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81-%E5%8A%9B%E6%89%A3-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">3.2.3.</span> <span class="nav-text">3、 力扣 206 反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81-%E5%8A%9B%E6%89%A3-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">3.2.4.</span> <span class="nav-text">4、 力扣 24 两两交换链表中的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%8A%9B%E6%89%A3-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">3.2.5.</span> <span class="nav-text">5、力扣 19 删除链表的倒数第N个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E3%80%81%E5%8A%9B%E6%89%A3-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-%E2%85%A1"><span class="nav-number">3.2.6.</span> <span class="nav-text">6 、力扣 142 环形链表 Ⅱ</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%A0%88"><span class="nav-number">4.</span> <span class="nav-text">二、栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="nav-number">4.1.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8A%9B%E6%89%A3-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">4.1.1.</span> <span class="nav-text">1、力扣 232 用栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%8A%9B%E6%89%A3-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.1.2.</span> <span class="nav-text">2、力扣 20 有效的括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%8A%9B%E6%89%A3-1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">4.1.3.</span> <span class="nav-text">3、力扣 1047 删除字符串中的所有相邻重复项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%8A%9B%E6%89%A3-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">4.1.4.</span> <span class="nav-text">4、力扣 150 逆波兰表达式求值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8D%E7%94%9F%E7%BB%93%E6%9E%84%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">4.2.</span> <span class="nav-text">衍生结构：单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="nav-number">4.2.1.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8A%9B%E6%89%A3-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">1、力扣 739.每日温度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8A%9B%E6%89%A3-84-%E7%9F%A9%E5%BD%A2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">2、力扣 84.矩形中最大的面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%8A%9B%E6%89%A3-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%E2%85%A0"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">3、力扣 496 下一个更大的元素Ⅰ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%8A%9B%E6%89%A3503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%E2%85%A1"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">4、力扣503 下一个更大的元素Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%8A%9B%E6%89%A342-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">5、力扣42 接雨水</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">三、队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">5.1.</span> <span class="nav-text">1、单端队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%E3%80%81%E5%8A%9B%E6%89%A3-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">5.1.0.1.</span> <span class="nav-text">例题、力扣 225 用队列实现栈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">5.2.</span> <span class="nav-text">2、双端队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8D%E7%94%9F%E7%B1%BB%E5%9E%8B1%EF%BC%9A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">5.2.1.</span> <span class="nav-text">衍生类型1：单调队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%E3%80%81%E5%8A%9B%E6%89%A3-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">例题、力扣 239 滑动窗口最大值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8D%E7%94%9F%E7%B1%BB%E5%9E%8B2%EF%BC%9A%E9%A1%B6%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">5.2.2.</span> <span class="nav-text">衍生类型2：顶堆（优先队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B6%E5%A0%86%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.2.2.0.0.1.</span> <span class="nav-text">顶堆的使用和顺序的使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%9C%81%E7%95%A5%E5%86%99%E6%B3%95"><span class="nav-number">5.2.2.0.0.2.</span> <span class="nav-text">省略写法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%E3%80%81%E5%8A%9B%E6%89%A3-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">例题、力扣 347 前K个高频元素</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%B2"><span class="nav-number">6.</span> <span class="nav-text">四、串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">6.0.1.</span> <span class="nav-text">KMP算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="nav-number">6.0.2.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8A%9B%E6%89%A3-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.0.2.1.</span> <span class="nav-text">1.力扣 344 反转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8A%9B%E6%89%A3-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1"><span class="nav-number">6.0.2.2.</span> <span class="nav-text">2.力扣 541 反转字符串Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8D%A1%E7%8E%9B-53-%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97"><span class="nav-number">6.0.2.3.</span> <span class="nav-text">3.卡玛 53 替换数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%8A%9B%E6%89%A3-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">6.0.2.4.</span> <span class="nav-text">4.力扣 151 翻转字符串里的单词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%8D%A1%E7%8E%9B-55-%E5%8F%B3%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.0.2.5.</span> <span class="nav-text">5.卡玛 55 右旋转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%8A%9B%E6%89%A3-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.0.2.6.</span> <span class="nav-text">6.力扣 459 重复的子字符串</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">7.</span> <span class="nav-text">五、哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%97%A0%E5%BA%8F%E8%A1%A8"><span class="nav-number">7.1.</span> <span class="nav-text">1、无序表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="nav-number">7.1.1.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8A%9B%E6%89%A3-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">1、力扣 242 有效的字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8A%9B%E6%89%A3-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">2、力扣 349 两个数组的交集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%8A%9B%E6%89%A3-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">3、力扣 1 两数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%8A%9B%E6%89%A3-15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">7.1.1.4.</span> <span class="nav-text">4、力扣 15三数之和（双指针）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%8A%9B%E6%89%A3-18%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">7.1.1.5.</span> <span class="nav-text">5、力扣 18四数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%8A%9B%E6%89%A3-454%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">7.1.1.6.</span> <span class="nav-text">6、力扣 454四数相加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%8A%9B%E6%89%A3-202%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-number">7.1.1.7.</span> <span class="nav-text">7、力扣 202快乐数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E5%8A%9B%E6%89%A3-383%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="nav-number">7.1.1.8.</span> <span class="nav-text">8、力扣 383赎金信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="nav-number">7.2.</span> <span class="nav-text">2、有序表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">8.</span> <span class="nav-text">六、并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">8.0.0.0.0.1.</span> <span class="nav-text">实现：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.</span> <span class="nav-text">七、二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%85%A0%E3%80%81%E7%A7%8D%E7%B1%BB"><span class="nav-number">9.1.</span> <span class="nav-text">Ⅰ、种类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.1.0.1.</span> <span class="nav-text">1、满二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.1.1.</span> <span class="nav-text">2、完全二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">9.1.2.</span> <span class="nav-text">3、二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">9.1.3.</span> <span class="nav-text">4、平衡二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%85%A1%E3%80%81%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">9.2.</span> <span class="nav-text">Ⅱ、存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">9.2.1.</span> <span class="nav-text">1、链式存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8"><span class="nav-number">9.2.2.</span> <span class="nav-text">2、线性存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%85%A2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.</span> <span class="nav-text">Ⅲ、二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.1.</span> <span class="nav-text">1、深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.1.0.0.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.1.0.0.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.1.0.0.3.</span> <span class="nav-text">后序遍历</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.2.</span> <span class="nav-text">2、广度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%85%A3%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">9.4.</span> <span class="nav-text">Ⅳ、定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">9.4.0.0.0.1.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86%E5%B0%B1%E6%98%AF%E6%8D%A2%E4%B8%AA%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="nav-number">9.4.0.0.0.2.</span> <span class="nav-text">递归前序遍历（中后遍历就是换个顺序）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">9.4.0.0.0.3.</span> <span class="nav-text">迭代前序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">9.4.0.0.0.4.</span> <span class="nav-text">迭代中序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">9.4.0.0.0.5.</span> <span class="nav-text">迭代后序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">9.4.0.0.0.6.</span> <span class="nav-text">层次遍历</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%85%A4%E3%80%81%E4%BE%8B%E9%A2%98"><span class="nav-number">9.5.</span> <span class="nav-text">Ⅴ、例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81-%E5%8A%9B%E6%89%A3-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.5.1.</span> <span class="nav-text">1、 力扣 226 翻转二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81-%E5%8A%9B%E6%89%A3-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.5.2.</span> <span class="nav-text">2、 力扣 101 对称二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81-%E5%8A%9B%E6%89%A3104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">9.5.3.</span> <span class="nav-text">3、 力扣104 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E5%BA%A6%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%BA%A6%EF%BC%9F"><span class="nav-number">9.5.3.0.0.1.</span> <span class="nav-text">什么是深度？什么是高度？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81-%E5%8A%9B%E6%89%A3-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">9.5.4.</span> <span class="nav-text">4、 力扣 111 二叉树的最小深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81-%E5%8A%9B%E6%89%A3-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-number">9.5.5.</span> <span class="nav-text">5、 力扣 222 完全二叉树的结点个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E5%8A%9B%E6%89%A3-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.5.6.</span> <span class="nav-text">6、力扣 110 平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E3%80%81-%E5%8A%9B%E6%89%A3-257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-number">9.5.7.</span> <span class="nav-text">7 、 力扣 257 二叉树的所有路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E5%8A%9B%E6%89%A3-404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-number">9.5.8.</span> <span class="nav-text">8、力扣 404 左叶子之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E5%8A%9B%E6%89%A3-513-%E6%89%BE%E5%88%B0%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="nav-number">9.5.9.</span> <span class="nav-text">9、力扣 513 找到树左下角的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E5%8A%9B%E6%89%A3-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-number">9.5.10.</span> <span class="nav-text">10、力扣 112 路径总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81-%E5%8A%9B%E6%89%A3-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.5.11.</span> <span class="nav-text">11、 力扣 106 从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81-%E5%8A%9B%E6%89%A3-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.5.12.</span> <span class="nav-text">12、 力扣 654 最大二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81-%E5%8A%9B%E6%89%A3-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.5.13.</span> <span class="nav-text">13、 力扣 617 合并二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81-%E5%8A%9B%E6%89%A3-700-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-number">9.5.14.</span> <span class="nav-text">14、 力扣 700 二叉树中的搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E3%80%81%E5%8A%9B%E6%89%A3-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">9.5.15.</span> <span class="nav-text">15、力扣 98 验证二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E3%80%81-%E5%8A%9B%E6%89%A3-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-number">9.5.16.</span> <span class="nav-text">16、 力扣 530 二叉搜索树的最小绝对差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E3%80%81%E5%8A%9B%E6%89%A3-501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-number">9.5.17.</span> <span class="nav-text">17、力扣 501  二叉搜索树中的众数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%E3%80%81-%E5%8A%9B%E6%89%A3-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">9.5.18.</span> <span class="nav-text">18、 力扣 236 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19%E3%80%81%E5%8A%9B%E6%89%A3-235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">9.5.19.</span> <span class="nav-text">19、力扣 235 二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20%E3%80%81-%E5%8A%9B%E6%89%A3-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">9.5.20.</span> <span class="nav-text">20、 力扣 701 二叉搜索树中的插入操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21%E3%80%81-%E5%8A%9B%E6%89%A3-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9"><span class="nav-number">9.5.21.</span> <span class="nav-text">21、 力扣 450 删除二叉搜索树中的结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22%E3%80%81%E5%8A%9B%E6%89%A3-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">9.5.22.</span> <span class="nav-text">22、力扣 669 修剪二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23%E3%80%81-%E5%8A%9B%E6%89%A3-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">9.5.23.</span> <span class="nav-text">23、 力扣 108 将有序数组转换成二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24%E3%80%81%E5%8A%9B%E6%89%A3-538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">9.5.24.</span> <span class="nav-text">24、力扣 538 把二叉搜索树转为累加树</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AlexQFMM"
      src="/images/Avatar.jpg">
  <p class="site-author-name" itemprop="name">AlexQFMM</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://qexo-ten-roan.vercel.app/" title="控制中心 → https:&#x2F;&#x2F;qexo-ten-roan.vercel.app&#x2F;" rel="noopener" target="_blank">控制中心</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AlexQFMM</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'UaEUwcYLlkREnSn9jPNe0oRf-gzGzoHsz',
      appKey     : '5d7KwGdf31jiCBxBobH0wVk6',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/miku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
