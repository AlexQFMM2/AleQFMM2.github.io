<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="结构型模式">
<meta property="og:type" content="article">
<meta property="og:title" content="结构型模式">
<meta property="og:url" content="http://example.com/2024/10/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="AlexHome">
<meta property="og:description" content="结构型模式">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-04T10:20:45.000Z">
<meta property="article:modified_time" content="2024-12-01T13:58:43.022Z">
<meta property="article:author" content="AlexQFMM">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/10/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>结构型模式 | AlexHome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">AlexHome</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
        <li class="menu-item menu-item-mypage">

    <a href="/MYHTML/test/index.html" rel="section"><i class="fas fa-file-user fa-fw"></i>myPage</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.jpg">
      <meta itemprop="name" content="AlexQFMM">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AlexHome">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          结构型模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-04 10:20:45" itemprop="dateCreated datePublished" datetime="2024-10-04T10:20:45+00:00">2024-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-01 13:58:43" itemprop="dateModified" datetime="2024-12-01T13:58:43+00:00">2024-12-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
            </span>

          
            <span id="/2024/10/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="post-meta-item leancloud_visitors" data-flag-title="结构型模式" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/10/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/10/04/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a><strong>结构型模式</strong></h1><span id="more"></span>

<h2 id="适配器（Adapter）模式"><a href="#适配器（Adapter）模式" class="headerlink" title="适配器（Adapter）模式"></a>适配器（Adapter）模式</h2><p><strong>适配器模式（Adapter Pattern）</strong> 是一种结构型设计模式，它的主要作用是将一个类的接口转换成客户端期望的另一个接口，从而使原本接口不兼容的类可以一起工作。适配器模式使得那些由于接口不兼容而不能一起工作的类可以协同作用。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;vector&gt;  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;memory&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">// 目标接口  </span><br><span class="line">class ListView &#123;  </span><br><span class="line">public:  </span><br><span class="line">    void setData(const vector&lt;string&gt;&amp; data) &#123;  </span><br><span class="line">        data_ = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">    void display() &#123;  </span><br><span class="line">        for (const auto&amp; str : data_) &#123;  </span><br><span class="line">            cout &lt;&lt; &quot; - &quot; &lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">private:  </span><br><span class="line">    vector&lt;string&gt; data_;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// 物品基类  </span><br><span class="line">class Item &#123;  </span><br><span class="line">public:  </span><br><span class="line">    virtual string getContext() const = 0;  </span><br><span class="line">    virtual ~Item() = default;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// 适配器基类  </span><br><span class="line">class ItAdapter &#123;  </span><br><span class="line">public:  </span><br><span class="line">    virtual vector&lt;string&gt; getStringData() const = 0;  </span><br><span class="line">    virtual ~ItAdapter() = default;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// 被适配者的基类  </span><br><span class="line">class ItAdaptee &#123;  </span><br><span class="line">public:  </span><br><span class="line">    virtual vector&lt;shared_ptr&lt;Item&gt;&gt; getItems() const = 0;  // 返回共享指针的集合，表示 Item 对象  </span><br><span class="line">    virtual ~ItAdaptee() = default;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// 自定义物品类  </span><br><span class="line">class MyItem : public Item &#123;  </span><br><span class="line">public:  </span><br><span class="line">    MyItem(int icon, int id, const string&amp; context)  </span><br><span class="line">        : icon_(icon), id_(id), context_(context) &#123;&#125;  </span><br><span class="line">    int getIcon() const &#123; return icon_; &#125;  </span><br><span class="line">    int getId() const &#123; return id_; &#125;  </span><br><span class="line">    string getContext() const override &#123;  </span><br><span class="line">        return to_string(icon_) + &quot; &quot; + to_string(id_) + &quot; : &quot; + context_;  </span><br><span class="line">    &#125;  </span><br><span class="line">private:  </span><br><span class="line">    int icon_;  </span><br><span class="line">    int id_;  </span><br><span class="line">    string context_;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// 自定义被适配者  </span><br><span class="line">class MyAdaptee : public ItAdaptee &#123;  </span><br><span class="line">public:  </span><br><span class="line">    MyAdaptee(const vector&lt;int&gt;&amp; icons, const vector&lt;string&gt;&amp; contexts) &#123;  </span><br><span class="line">        size_t size = min(icons.size(), contexts.size());  </span><br><span class="line">        for (size_t i = 0; i &lt; size; ++i) &#123;  </span><br><span class="line">            items_.push_back(make_shared&lt;MyItem&gt;(icons[i], i + 1, contexts[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    vector&lt;shared_ptr&lt;Item&gt;&gt; getItems() const override &#123;  </span><br><span class="line">        return items_;  // 返回共享指针的拷贝，指向的对象不会被销毁  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">private:  </span><br><span class="line">    vector&lt;shared_ptr&lt;Item&gt;&gt; items_;  // 保存 Item 对象的共享指针  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// 自定义适配器  </span><br><span class="line">class MyAdapter : public ItAdapter &#123;  </span><br><span class="line">public:  </span><br><span class="line">    MyAdapter(shared_ptr&lt;ItAdaptee&gt; adaptee) : adaptee_(adaptee) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; getStringData() const override &#123;  </span><br><span class="line">        vector&lt;string&gt; res;  </span><br><span class="line">        auto items = adaptee_-&gt;getItems();  </span><br><span class="line">        for (const auto&amp; item : items) &#123;  </span><br><span class="line">            res.push_back(item-&gt;getContext());  </span><br><span class="line">        &#125;  </span><br><span class="line">        return res;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">private:  </span><br><span class="line">    shared_ptr&lt;ItAdaptee&gt; adaptee_;  // 持有被适配者的共享指针  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">int main() &#123;  </span><br><span class="line">    // 初始化图标和上下文  </span><br><span class="line">    vector&lt;int&gt; icons = &#123; 99, 98, 97, 96, 95 &#125;;  </span><br><span class="line">    vector&lt;string&gt; contexts = &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; &#125;;  </span><br><span class="line"></span><br><span class="line">    // 创建被适配者  </span><br><span class="line">    shared_ptr&lt;MyAdaptee&gt; adaptee = make_shared&lt;MyAdaptee&gt;(icons, contexts);  </span><br><span class="line"></span><br><span class="line">    // 使用适配器将被适配者的数据转换为 ListView 所需的数据格式  </span><br><span class="line">    MyAdapter adapter(adaptee);  </span><br><span class="line"></span><br><span class="line">    // 创建 ListView 并展示数据  </span><br><span class="line">    ListView listView;  </span><br><span class="line">    listView.setData(adapter.getStringData());  </span><br><span class="line">    listView.display();  </span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>目标接口（Target）：</strong> 客户端所期望的接口，适配器需要实现该接口。</li>
<li><strong>需要适配的类（Adaptee）：</strong> 需要被适配的类，其接口与目标接口不兼容。</li>
<li><strong>适配器（Adapter）：</strong> 通过包装一个需要适配的对象，把原接口转换成目标接口。</li>
</ul>
<p><strong>适配器模式有两种形式：</strong></p>
<ul>
<li><strong>类适配器模式（使用继承）：</strong> 适配器继承自需要适配的类，并实现目标接口。</li>
<li><strong>对象适配器模式（使用组合）：</strong> 适配器持有需要适配的类的实例，通过调用实例的方法来实现目标接口。</li>
</ul>
<hr>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li><strong>提高类的复用性：</strong> 通过适配器，原有的类可以在新的环境中被复用。</li>
<li><strong>提高了类的扩展性：</strong> 适配器模式使得我们可以很方便地添加新的适配器类，实现新的适配功能。</li>
<li><strong>解耦：</strong> 客户端可以通过适配器使用不兼容的类，无需修改现有的代码。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>额外的复杂度：</strong> 增加了系统的复杂度，特别是当应用过度时，可能会使系统变得臃肿。</li>
<li><strong>性能影响：</strong> 由于多了一层间接调用，可能会对性能有一定影响，特别是在使用对象适配器时。</li>
</ul>
<hr>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><strong>希望使用一个已经存在的类，但它的接口不符合你的需求。</strong></li>
<li><strong>创建能够复用的类，这些类可以与其他不相关的类或不可预见的类协同工作。</strong></li>
<li><strong>需要使用一些现有的子类，但是不可能对每一个都进行子类化以匹配其接口。对象适配器可以适配它的父类接口。</strong></li>
</ul>
<h2 id="桥接（Bridge）模式"><a href="#桥接（Bridge）模式" class="headerlink" title="桥接（Bridge）模式"></a>桥接（Bridge）模式</h2><blockquote>
<p><strong>桥接模式（Bridge Pattern）</strong>：将<strong>抽象部分</strong>与<strong>实现部分</strong>分离，使它们都可以独立地变化。</p>
</blockquote>
<p>换句话说，桥接模式通过提供一种方法，将接口（抽象）与其实现解耦，从而实现二者的独立变化。这有助于避免类的继承层次过深，减少代码的复杂度，提高系统的可扩展性和维护性。</p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//发送的方法</span><br><span class="line">class MessageSender &#123;</span><br><span class="line">public:</span><br><span class="line">	//= 0 用于定义纯虚函数，表示这个函数是抽象的，必须由派生类进行实现</span><br><span class="line">	virtual void sendMessage(const string&amp; message) = 0;</span><br><span class="line">	virtual ~MessageSender() = default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//发送普通信息的方法</span><br><span class="line">class NoteSender : public MessageSender &#123;</span><br><span class="line">public:</span><br><span class="line">	void sendMessage(const string&amp; message) override &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Sending note: &quot; &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//发送文件的方法</span><br><span class="line">class FileSender : public MessageSender &#123;</span><br><span class="line">public:</span><br><span class="line">	void sendMessage(const string&amp; message) override &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Sending File: &quot; &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//发送的消息类型</span><br><span class="line">class Message &#123;</span><br><span class="line">public:</span><br><span class="line">	Message(shared_ptr&lt;MessageSender&gt; sender) : sender_(sender) &#123;&#125;</span><br><span class="line">	virtual void send(const string&amp; message) = 0;</span><br><span class="line">	virtual ~Message() = default;</span><br><span class="line">protected:</span><br><span class="line">	shared_ptr&lt;MessageSender&gt; sender_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//普通信息</span><br><span class="line">class NormalMessage : public Message &#123;</span><br><span class="line">public:</span><br><span class="line">	NormalMessage(shared_ptr&lt;MessageSender&gt; sender) : Message(sender)&#123;&#125;</span><br><span class="line">	void send(const string&amp; message) override &#123;</span><br><span class="line">		sender_-&gt;sendMessage(&quot;Normal : &quot; + message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//加急信息</span><br><span class="line">class UrgentMessage : public Message &#123;</span><br><span class="line">public:</span><br><span class="line">	UrgentMessage(shared_ptr&lt;MessageSender&gt; sender) : Message(sender) &#123;&#125;</span><br><span class="line">	void send(const string&amp; message) override &#123;</span><br><span class="line">		sender_-&gt;sendMessage(&quot;Urgent : &quot; + message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	shared_ptr&lt;MessageSender&gt; noteSender = make_shared&lt;NoteSender&gt;();</span><br><span class="line">	shared_ptr&lt;MessageSender&gt; fileSender = make_shared&lt;FileSender&gt;();</span><br><span class="line"></span><br><span class="line">	shared_ptr&lt;Message&gt; normalNote = make_shared&lt;NormalMessage&gt;(noteSender);</span><br><span class="line">	shared_ptr&lt;Message&gt; urgentFile = make_shared&lt;UrgentMessage&gt;(fileSender);</span><br><span class="line"></span><br><span class="line">	shared_ptr&lt;Message&gt; normalFile = make_shared&lt;UrgentMessage&gt;(fileSender);</span><br><span class="line">	shared_ptr&lt;Message&gt; urgentNote = make_shared&lt;NormalMessage&gt;(noteSender);</span><br><span class="line">	</span><br><span class="line">	normalNote-&gt;send(&quot; Hello, World. &quot;);</span><br><span class="line">	urgentNote-&gt;send(&quot; Bye! &quot;);</span><br><span class="line"></span><br><span class="line">	urgentFile-&gt;send(&quot; File1.txt &quot;);</span><br><span class="line">	normalFile-&gt;send(&quot; File2.txt &quot;);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体分析-1"><a href="#具体分析-1" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="桥接模式的优点"><a href="#桥接模式的优点" class="headerlink" title="桥接模式的优点"></a>桥接模式的优点</h4><ol>
<li><strong>分离抽象接口及其实现部分</strong>：提高了系统的可扩展性，可以独立地扩展抽象部分和实现部分。</li>
<li><strong>更好的分层结构</strong>：遵循单一职责原则，每个类都有明确的职责。</li>
<li><strong>动态切换实现</strong>：在运行时可以动态地切换实现部分，例如更换颜色。</li>
<li><strong>减少类的数量</strong>：避免由于多维度扩展而导致类的数量呈指数增长。</li>
</ol>
<hr>
<h4 id="桥接模式的应用场景"><a href="#桥接模式的应用场景" class="headerlink" title="桥接模式的应用场景"></a>桥接模式的应用场景</h4><ol>
<li><strong>当一个系统需要在多个维度上扩展时</strong>：例如形状和颜色、图形和绘制方式等。</li>
<li><strong>当一个类存在两个独立变化的维度，且这两个维度都需要独立进行扩展</strong>。</li>
<li><strong>避免继承带来的类急剧增长</strong>：通过组合的方式替代继承。</li>
</ol>
<hr>
<h4 id="桥接模式的注意事项"><a href="#桥接模式的注意事项" class="headerlink" title="桥接模式的注意事项"></a><strong>桥接模式的注意事项</strong></h4><ul>
<li><strong>需要正确识别系统中可能存在的多个维度的变化</strong>，并将它们分离开来。</li>
<li><strong>实现者接口</strong>（Implementor）不一定要与抽象接口（Abstraction）完全一致，通常实现者接口提供更底层的操作，而抽象接口定义更高层的操作。</li>
<li><strong>桥接模式强调的是抽象和实现的分离</strong>，从而达到松耦合、可扩展的目的</li>
</ul>
<h2 id="组合（Composite）模式"><a href="#组合（Composite）模式" class="headerlink" title="组合（Composite）模式"></a>组合（Composite）模式</h2><p><strong>组合模式</strong>是一种结构型设计模式，它将对象组织成树形结构，以表示“部分-整体”的层次结构。组合模式使得客户端对单个对象和组合对象的使用具有一致性。</p>
<blockquote>
<p><strong>定义</strong>：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//抽象组件 文件系统 节点</span><br><span class="line">class FileSystemNode &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual ~FileSystemNode() = default;</span><br><span class="line">	virtual void display(int depth = 0) const = 0;</span><br><span class="line">	virtual int getSize() const = 0;</span><br><span class="line"></span><br><span class="line">	//管理结点，叶子节点可以选择不实现</span><br><span class="line">	virtual void add(shared_ptr&lt;FileSystemNode&gt; node) &#123;</span><br><span class="line">		throw runtime_error(&quot;Can not add to a leaf node&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void remove(shared_ptr&lt;FileSystemNode&gt; node) &#123;</span><br><span class="line">		throw runtime_error(&quot;Can not remove from a leaf node&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//定义叶子节点 : 文件</span><br><span class="line">class File : public FileSystemNode &#123;</span><br><span class="line">public:</span><br><span class="line">	File(const string&amp; filename , int filesize) : filename_(filename) , filesize_(filesize)&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	void display(int depth = 0) const override &#123;</span><br><span class="line">		cout &lt;&lt; string(depth, &#x27; &#x27;) &lt;&lt; &quot;- File: &quot; &lt;&lt; filename_ &lt;&lt; &quot; (&quot; &lt;&lt; filesize_ &lt;&lt; &quot;KB) &quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int getSize() const override &#123;</span><br><span class="line">		return filesize_;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	string filename_;</span><br><span class="line">	int filesize_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//实现组合结点 : 目录</span><br><span class="line">class Directory : public FileSystemNode &#123;</span><br><span class="line">public:</span><br><span class="line">	Directory(const string&amp; dirname) : dirname_ (dirname) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	void add(shared_ptr&lt;FileSystemNode&gt; node) override &#123;</span><br><span class="line">		children_.push_back(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void remove(shared_ptr&lt;FileSystemNode&gt; node) override &#123;</span><br><span class="line">		//remove : 逻辑上移除 并没有改变容器大小</span><br><span class="line">		//erase : 真正删除元素的操作</span><br><span class="line">		//因此，组合使用 std::remove 和 erase 实现了“移除并删除”的功能。</span><br><span class="line">		children_.erase(</span><br><span class="line">			std::remove(children_.begin(), children_.end(), node)</span><br><span class="line">			, children_.end());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void display(int depth = 0) const override &#123;</span><br><span class="line">		cout &lt;&lt; string(depth, &#x27; &#x27;) &lt;&lt; &quot;+ Directory: &quot; &lt;&lt; dirname_ &lt;&lt; endl;</span><br><span class="line">		for (const auto&amp; child : children_) &#123;</span><br><span class="line">			child-&gt;display(depth + 2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int getSize() const override &#123;</span><br><span class="line">		int totalSize = 0;</span><br><span class="line">		for (const auto&amp; child : children_) &#123;</span><br><span class="line">			totalSize += child-&gt;getSize();</span><br><span class="line">		&#125;</span><br><span class="line">		return totalSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	string dirname_;</span><br><span class="line">	vector&lt;shared_ptr&lt;FileSystemNode&gt;&gt; children_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	// 创建文件  </span><br><span class="line">	auto file1 = std::make_shared&lt;File&gt;(&quot;file1.txt&quot;, 10);</span><br><span class="line">	auto file2 = std::make_shared&lt;File&gt;(&quot;file2.txt&quot;, 20);</span><br><span class="line">	auto file3 = std::make_shared&lt;File&gt;(&quot;file3.txt&quot;, 30);</span><br><span class="line"></span><br><span class="line">	// 创建目录  </span><br><span class="line">	auto dir1 = std::make_shared&lt;Directory&gt;(&quot;dir1&quot;);</span><br><span class="line">	auto dir2 = std::make_shared&lt;Directory&gt;(&quot;dir2&quot;);</span><br><span class="line"></span><br><span class="line">	// 组装文件系统  </span><br><span class="line">	dir1-&gt;add(file1);</span><br><span class="line">	dir1-&gt;add(file2);</span><br><span class="line"></span><br><span class="line">	dir2-&gt;add(file3);</span><br><span class="line">	dir2-&gt;add(dir1);</span><br><span class="line"></span><br><span class="line">	// 显示文件系统结构  </span><br><span class="line">	dir2-&gt;display();</span><br><span class="line"></span><br><span class="line">	// 计算总大小  </span><br><span class="line">	std::cout &lt;&lt; &quot;Total size: &quot; &lt;&lt; dir2-&gt;getSize() &lt;&lt; &quot;KB&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体分析-2"><a href="#具体分析-2" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="组合模式的优点"><a href="#组合模式的优点" class="headerlink" title="组合模式的优点"></a>组合模式的优点</h4><ol>
<li><strong>统一性</strong>：客户端可以一致地使用组合结构和单个对象，无需关心它们的具体类型。</li>
<li><strong>简化客户端代码</strong>：客户端可以忽略组合对象和叶子对象之间的差异，简化了代码逻辑。</li>
<li><strong>容易扩展</strong>：可以很方便地增加新的组件类型，只需保证它们实现了组件接口。</li>
<li><strong>符合开闭原则</strong>：对扩展开放，对修改关闭。</li>
</ol>
<hr>
<h4 id="组合模式的适用场景"><a href="#组合模式的适用场景" class="headerlink" title="组合模式的适用场景"></a><strong>组合模式的适用场景</strong></h4><ul>
<li><strong>需要表示对象的部分-整体层次结构</strong>：如文件系统、公司组织架构、GUI 组件树形结构等。</li>
<li><strong>希望客户端忽略组合对象和叶子对象的差异</strong>：统一地使用组合结构中的所有对象。</li>
<li><strong>需要在一个树形结构中操作部分对象和整体对象</strong>。</li>
</ul>
<hr>
<h4 id="组合模式的注意事项"><a href="#组合模式的注意事项" class="headerlink" title="组合模式的注意事项"></a><strong>组合模式的注意事项</strong></h4><ul>
<li><strong>对子组件的管理方式</strong>：<ul>
<li><strong>透明方式</strong>：在抽象组件中声明所有用于管理子组件的方法（如 <code>add()</code>、<code>remove()</code>）。组合对象实现这些方法，叶子对象不实现或抛异常。</li>
<li><strong>安全方式</strong>：只在组合对象中声明用于管理子组件的方法，叶子对象不声明这些方法。这样更安全但客户端需要进行类型判断。</li>
</ul>
</li>
<li><strong>对子组件的遍历</strong>：可以结合<strong>迭代器模式</strong>来遍历组合结构。</li>
<li><strong>循环引用</strong>：在添加子组件时要注意避免循环引用，防止出现无限递归或栈溢出。</li>
</ul>
<h2 id="装饰（Decorator）模式"><a href="#装饰（Decorator）模式" class="headerlink" title="装饰（Decorator）模式"></a>装饰（Decorator）模式</h2><p>装饰模式是一种结构型设计模式，它允许在不改变原有对象结构的情况下，动态地给对象添加新的功能。装饰模式将功能划分成一个个可独立复用的装饰类，通过将原始对象嵌入到装饰对象中，实现功能的层层叠加，从而增强对象的行为。</p>
<p>主要角色：</p>
<ul>
<li><strong>抽象组件（Component）</strong>：定义对象的接口，可以给这些对象动态地添加职责。</li>
<li><strong>具体组件（ConcreteComponent）</strong>：实现抽象组件接口的类，代表被装饰的原始对象。</li>
<li><strong>装饰抽象类（Decorator）</strong>：持有一个组件对象的引用，并定义与抽象组件一致的接口。</li>
<li><strong>具体装饰类（ConcreteDecorator）</strong>：继承装饰抽象类，负责给组件添加新的职责。</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;memory&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 抽象饮料类  </span><br><span class="line">class Drink &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual string getDrinkName() const = 0;</span><br><span class="line">    virtual int getCost() const = 0;</span><br><span class="line">    virtual ~Drink() = default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 具体的茶类  </span><br><span class="line">class Tea : public Drink &#123;</span><br><span class="line">public:</span><br><span class="line">    Tea() &#123;</span><br><span class="line">        drinkname_ = &quot;Tea&quot;;</span><br><span class="line">        cost_ = 10;</span><br><span class="line">    &#125;</span><br><span class="line">    string getDrinkName() const override &#123;</span><br><span class="line">        return drinkname_;</span><br><span class="line">    &#125;</span><br><span class="line">    int getCost() const override &#123;</span><br><span class="line">        return cost_;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string drinkname_;</span><br><span class="line">    int cost_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 具体的咖啡类  </span><br><span class="line">class Coffee : public Drink &#123;</span><br><span class="line">public:</span><br><span class="line">    Coffee() &#123;</span><br><span class="line">        drinkname_ = &quot;Coffee&quot;;</span><br><span class="line">        cost_ = 15;</span><br><span class="line">    &#125;</span><br><span class="line">    string getDrinkName() const override &#123;</span><br><span class="line">        return drinkname_;</span><br><span class="line">    &#125;</span><br><span class="line">    int getCost() const override &#123;</span><br><span class="line">        return cost_;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string drinkname_;</span><br><span class="line">    int cost_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 调料抽象类（装饰者）  </span><br><span class="line">class Flavour : public Drink &#123;</span><br><span class="line">public:</span><br><span class="line">    Flavour(unique_ptr&lt;Drink&gt; baseDrink) : baseDrink_(move(baseDrink)) &#123;&#125;</span><br><span class="line">    string getDrinkName() const override &#123;</span><br><span class="line">        return baseDrink_-&gt;getDrinkName();</span><br><span class="line">    &#125;</span><br><span class="line">    int getCost() const override &#123;</span><br><span class="line">        return baseDrink_-&gt;getCost();</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    unique_ptr&lt;Drink&gt; baseDrink_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 糖类（具体装饰者）  </span><br><span class="line">class Sugar : public Flavour &#123;</span><br><span class="line">public:</span><br><span class="line">    Sugar(unique_ptr&lt;Drink&gt; baseDrink) : Flavour(move(baseDrink)) &#123;&#125;</span><br><span class="line">    string getDrinkName() const override &#123;</span><br><span class="line">        return Flavour::getDrinkName() + &quot; + Sugar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    int getCost() const override &#123;</span><br><span class="line">        return Flavour::getCost() + 2;  // 加糖增加2元  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 牛奶类（具体装饰者）  </span><br><span class="line">class Milk : public Flavour &#123;</span><br><span class="line">public:</span><br><span class="line">    Milk(unique_ptr&lt;Drink&gt; baseDrink) : Flavour(move(baseDrink)) &#123;&#125;</span><br><span class="line">    string getDrinkName() const override &#123;</span><br><span class="line">        return Flavour::getDrinkName() + &quot; + Milk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    int getCost() const override &#123;</span><br><span class="line">        return Flavour::getCost() + 3;  // 加牛奶增加3元  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一杯茶  </span><br><span class="line">    unique_ptr&lt;Drink&gt; myDrink = make_unique&lt;Tea&gt;();</span><br><span class="line">    cout &lt;&lt; &quot;Drink: &quot; &lt;&lt; myDrink-&gt;getDrinkName() &lt;&lt; &quot;, Cost: &quot; &lt;&lt; myDrink-&gt;getCost() &lt;&lt; &quot; USD&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 加糖  </span><br><span class="line">    myDrink = make_unique&lt;Sugar&gt;(move(myDrink));</span><br><span class="line">    cout &lt;&lt; &quot;Drink: &quot; &lt;&lt; myDrink-&gt;getDrinkName() &lt;&lt; &quot;, Cost: &quot; &lt;&lt; myDrink-&gt;getCost() &lt;&lt; &quot; USD&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 加牛奶  </span><br><span class="line">    myDrink = make_unique&lt;Milk&gt;(move(myDrink));</span><br><span class="line">    cout &lt;&lt; &quot;Drink: &quot; &lt;&lt; myDrink-&gt;getDrinkName() &lt;&lt; &quot;, Cost: &quot; &lt;&lt; myDrink-&gt;getCost() &lt;&lt; &quot; USD&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体分析-3"><a href="#具体分析-3" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>灵活性高</strong>：可以在运行时动态地添加和组合对象的行为，而不影响其他对象。</li>
<li><strong>符合开闭原则</strong>：可以通过创建新的装饰类来扩展功能，而不修改已有代码。</li>
<li><strong>细粒度控制</strong>：通过装饰类，可以对具体组件的功能进行细致的控制和扩展。</li>
</ul>
<hr>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<ul>
<li><strong>扩展性好</strong>：无需修改原有代码，就能为对象添加新的功能。</li>
<li><strong>装饰类和被装饰类可以独立发展</strong>：装饰类可以根据需要增加或更改，而不影响被装饰类。</li>
<li><strong>灵活组合</strong>：可以对一个对象进行多次装饰，形成一个功能叠加的效果。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>产生过多的小对象</strong>：大量使用装饰模式会产生很多类似的小对象，增加了系统的复杂性。</li>
<li><strong>调试困难</strong>：因为功能是通过一层层的装饰叠加的，定位问题可能需要追踪多个对象的调用。</li>
</ul>
<hr>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><strong>需要动态地为对象添加职责</strong>，而且职责可以动态撤销。</li>
<li><strong>不能采用继承</strong>的方式对系统进行扩充或者采用继承不利于系统的扩展和维护。</li>
<li><strong>需要对一些对象进行细致的划分和控制</strong>，以便在运行时根据需要对其进行功能的扩展。</li>
</ul>
<h2 id="外观（Facade）模式"><a href="#外观（Facade）模式" class="headerlink" title="外观（Facade）模式"></a>外观（Facade）模式</h2><p>外观模式（Facade Pattern）是一种结构型设计模式，提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。</p>
<p>通过引入一个外观类，客户端与复杂系统的内部子系统之间建立了一个简洁的接口，使得客户端不需要了解系统的详细实现，也不用与多个子系统交互，简化了客户端的操作。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// DVD播放器</span><br><span class="line">class DVDPlayer &#123;</span><br><span class="line">public:</span><br><span class="line">    static DVDPlayer&amp; getInstance() &#123;</span><br><span class="line">        static DVDPlayer instance; // 使用局部静态变量确保只有一个实例</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void on() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;DVD Player is ON.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void off() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;DVD Player is OFF.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;DVD Player is playing....&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pause() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;DVD Player is paused.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DVDPlayer() = default; // 私有构造函数</span><br><span class="line">    DVDPlayer(const DVDPlayer&amp;) = delete; // 禁止复制构造</span><br><span class="line">    DVDPlayer&amp; operator=(const DVDPlayer&amp;) = delete; // 禁止赋值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 投影仪</span><br><span class="line">class Projector &#123;</span><br><span class="line">public:</span><br><span class="line">    static Projector&amp; getInstance() &#123;</span><br><span class="line">        static Projector instance; // 使用局部静态变量确保只有一个实例</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void on() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Projector is ON.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void off() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Projector is OFF.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void display() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Projector is displaying....&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Projector() = default; // 私有构造函数</span><br><span class="line">    Projector(const Projector&amp;) = delete; // 禁止复制构造</span><br><span class="line">    Projector&amp; operator=(const Projector&amp;) = delete; // 禁止赋值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 音响</span><br><span class="line">class Stereo &#123;</span><br><span class="line">public:</span><br><span class="line">    static Stereo&amp; getInstance() &#123;</span><br><span class="line">        static Stereo instance; // 使用局部静态变量确保只有一个实例</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void on() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Stereo is ON.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void off() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Stereo is OFF.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setVolume(int volume) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Stereo volume set to &quot; &lt;&lt; volume &lt;&lt; &quot;.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Stereo() = default; // 私有构造函数</span><br><span class="line">    Stereo(const Stereo&amp;) = delete; // 禁止复制构造</span><br><span class="line">    Stereo&amp; operator=(const Stereo&amp;) = delete; // 禁止赋值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 灯光</span><br><span class="line">class Lights &#123;</span><br><span class="line">public:</span><br><span class="line">    static Lights&amp; getInstance() &#123;</span><br><span class="line">        static Lights instance; // 使用局部静态变量确保只有一个实例</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dim() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Lights are dimmed.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void bright() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Lights are brightened.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Lights() = default; // 私有构造函数</span><br><span class="line">    Lights(const Lights&amp;) = delete; // 禁止复制构造</span><br><span class="line">    Lights&amp; operator=(const Lights&amp;) = delete; // 禁止赋值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 屏幕</span><br><span class="line">class Screen &#123;</span><br><span class="line">public:</span><br><span class="line">    static Screen&amp; getInstance() &#123;</span><br><span class="line">        static Screen instance; // 使用局部静态变量确保只有一个实例</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void down() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Screen is down.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void up() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Screen is up.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Screen() = default; // 私有构造函数</span><br><span class="line">    Screen(const Screen&amp;) = delete; // 禁止复制构造</span><br><span class="line">    Screen&amp; operator=(const Screen&amp;) = delete; // 禁止赋值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 外观 ： 放映厅</span><br><span class="line">class VideoHall &#123;</span><br><span class="line">public:</span><br><span class="line">    static VideoHall&amp; getInstance() &#123;</span><br><span class="line">        static VideoHall instance; // 使用局部静态变量确保只有一个实例</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void movieStart() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Starting the movie...&quot; &lt;&lt; endl;</span><br><span class="line">        Lights::getInstance().dim();</span><br><span class="line">        Screen::getInstance().down();</span><br><span class="line">        Projector::getInstance().on();</span><br><span class="line">        Projector::getInstance().display();</span><br><span class="line">        Stereo::getInstance().on();</span><br><span class="line">        Stereo::getInstance().setVolume(5);</span><br><span class="line">        DVDPlayer::getInstance().on();</span><br><span class="line">        DVDPlayer::getInstance().play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void movieEnd() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Ending the movie...&quot; &lt;&lt; endl;</span><br><span class="line">        DVDPlayer::getInstance().pause();</span><br><span class="line">        DVDPlayer::getInstance().off();</span><br><span class="line">        Projector::getInstance().off();</span><br><span class="line">        Screen::getInstance().up();</span><br><span class="line">        Lights::getInstance().bright();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    VideoHall() = default; // 私有构造函数</span><br><span class="line">    VideoHall(const VideoHall&amp;) = delete; // 禁止复制构造</span><br><span class="line">    VideoHall&amp; operator=(const VideoHall&amp;) = delete; // 禁止赋值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    VideoHall::getInstance().movieStart(); // 开始放映电影</span><br><span class="line">    </span><br><span class="line">    VideoHall::getInstance().movieEnd();   // 结束放映电影</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="具体分析-4"><a href="#具体分析-4" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>简化接口</strong>：外观模式对外提供了一个简单易用的接口，隐藏了系统的复杂性。</li>
<li><strong>降低耦合度</strong>：客户端与子系统之间的耦合度降低，客户端不需要了解子系统的实现细节。</li>
<li><strong>更好的分层</strong>：有助于建立分层结构，使得子系统之间相互独立。</li>
</ul>
<hr>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<ul>
<li><strong>简化客户端使用</strong>：客户端可以更加容易地使用复杂系统。</li>
<li><strong>减少依赖</strong>：客户端与子系统之间的耦合减少，有利于松耦合设计。</li>
<li><strong>提高灵活性</strong>：子系统的变化不会影响到客户端，外观接口可以保持稳定。</li>
<li><strong>更好的封装性</strong>：隐藏了子系统的实现细节，保护了系统的安全。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>可能成为上帝对象</strong>：外观类可能过于庞大，承担过多职责，不符合单一职责原则。</li>
<li><strong>不易于扩展</strong>：若外观接口不够全面，可能需要修改外观类，违背开闭原则。</li>
</ul>
<hr>
<h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><strong>简化复杂系统的使用</strong>：当系统包含多个复杂的子系统，且客户端只需要与其中一部分交互时。</li>
<li><strong>构建分层系统</strong>：使用外观模式定义每层的入口点，简化层次间的依赖关系。</li>
<li><strong>遗留系统的封装</strong>：为已有的复杂系统提供一个简单的接口，方便客户端使用。</li>
</ul>
<h2 id="享元（Flyweight）模式"><a href="#享元（Flyweight）模式" class="headerlink" title="享元（Flyweight）模式"></a>享元（Flyweight）模式</h2><p><strong>享元模式</strong>是一种结构型设计模式，它通过共享大量细粒度对象中的公共部分，避免大量拥有相同内容对象的开销，节省内存空间，提高性能。</p>
<p>在享元模式中，将对象的可变部分（外部状态）和不可变部分（内部状态）分离，不可变部分可以共享，共享的对象称为<strong>享元对象（Flyweight）</strong>。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//享元类 ： 树的种类</span><br><span class="line">class TreeType &#123;</span><br><span class="line">public:</span><br><span class="line">	TreeType(const string&amp; name , const string&amp; color , const string texture)</span><br><span class="line">		:name_(name) , color_(color) , texture_(texture)&#123;&#125;</span><br><span class="line">	void draw(int x, int y) const &#123;</span><br><span class="line">		cout &lt;&lt; &quot; Drawing tree &quot; &lt;&lt; name_ &lt;&lt; &quot; of color &#x27;&quot; &lt;&lt; color_</span><br><span class="line">			&lt;&lt; &quot; &#x27; and texture &#x27;&quot; &lt;&lt; texture_ &lt;&lt; &quot; &#x27; at ( &quot;</span><br><span class="line">			&lt;&lt; x &lt;&lt; &quot; , &quot; &lt;&lt; y &lt;&lt; &quot; ) &quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	string name_;</span><br><span class="line">	string color_;</span><br><span class="line">	string texture_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//享元工厂类 ： 树工厂</span><br><span class="line">class TreeFactory &#123;</span><br><span class="line">public:</span><br><span class="line">    static std::shared_ptr&lt;TreeType&gt; getTreeType(const std::string&amp; name,</span><br><span class="line">        const std::string&amp; color,</span><br><span class="line">        const std::string&amp; texture) &#123;</span><br><span class="line">        std::string key = name + &quot;_&quot; + color + &quot;_&quot; + texture;</span><br><span class="line">        auto it = treeTypes_.find(key);</span><br><span class="line">        if (it != treeTypes_.end()) &#123;</span><br><span class="line">            return it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            auto treeType = std::make_shared&lt;TreeType&gt;(name, color, texture);</span><br><span class="line">            treeTypes_[key] = treeType;</span><br><span class="line">            return treeType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    static std::unordered_map&lt;std::string, std::shared_ptr&lt;TreeType&gt;&gt; treeTypes_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化静态成员变量  </span><br><span class="line">std::unordered_map&lt;std::string, std::shared_ptr&lt;TreeType&gt;&gt; TreeFactory::treeTypes_;</span><br><span class="line"></span><br><span class="line">class Tree &#123;</span><br><span class="line">public:</span><br><span class="line">    Tree(int x, int y, std::shared_ptr&lt;TreeType&gt; type)</span><br><span class="line">        : x_(x), y_(y), type_(type) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void draw() const &#123;</span><br><span class="line">        type_-&gt;draw(x_, y_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int x_;</span><br><span class="line">    int y_;</span><br><span class="line">    std::shared_ptr&lt;TreeType&gt; type_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Forest &#123;</span><br><span class="line">public:</span><br><span class="line">    void plantTree(int x, int y, const std::string&amp; name,</span><br><span class="line">        const std::string&amp; color, const std::string&amp; texture) &#123;</span><br><span class="line">        auto type = TreeFactory::getTreeType(name, color, texture);</span><br><span class="line">        auto tree = std::make_shared&lt;Tree&gt;(x, y, type);</span><br><span class="line">        trees_.push_back(tree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void draw() const &#123;</span><br><span class="line">        for (const auto&amp; tree : trees_) &#123;</span><br><span class="line">            tree-&gt;draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Tree&gt;&gt; trees_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Forest forest;</span><br><span class="line">    forest.plantTree(1, 2, &quot;Oak&quot;, &quot;Green&quot;, &quot;Rough&quot;);</span><br><span class="line">    forest.plantTree(3, 4, &quot;Pine&quot;, &quot;Dark Green&quot;, &quot;Smooth&quot;);</span><br><span class="line">    forest.plantTree(5, 6, &quot;Oak&quot;, &quot;Green&quot;, &quot;Rough&quot;);</span><br><span class="line">    forest.plantTree(7, 8, &quot;Pine&quot;, &quot;Dark Green&quot;, &quot;Smooth&quot;);</span><br><span class="line">    forest.plantTree(9, 10, &quot;Birch&quot;, &quot;Yellow&quot;, &quot;Striped&quot;);</span><br><span class="line"></span><br><span class="line">    forest.draw();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体分析-5"><a href="#具体分析-5" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<ul>
<li><strong>减少内存消耗</strong>：通过共享大部分相同的对象，极大地减少了系统中的对象数量，节省了内存。</li>
<li><strong>提高性能</strong>：减少了创建对象的时间和内存分配的开销。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>增加了系统复杂度</strong>：需要分离内部状态和外部状态，系统结构更加复杂。</li>
<li><strong>增加了开发难度</strong>：需要维护共享对象的生命周期，以及外部状态的管理。</li>
</ul>
<hr>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><strong>内部状态（Intrinsic State）</strong>：可以共享，不会随环境改变而改变的状态。</li>
<li><strong>外部状态（Extrinsic State）</strong>：不可以共享，会随环境改变，必须由客户端来外部化的状态。</li>
</ul>
<p>使用享元模式，需要确保对象的可变部分可以外部化，否则很难实现共享。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>享元模式通过共享相同或相似的对象，减少内存消耗，提高性能。适用于有大量细粒度对象的场景，是一种以时间换空间的优化方法。</p>
<p>**享元模式（Flyweight Pattern）**在游戏开发中非常常用，特别是在需要**大量创建相似对象**的情况下，例如大量的NPC（非玩家角色）、游戏场景中的树木、石头、建筑物、子弹、粒子特效等。</p>
<h2 id="代理（Proxy）模式"><a href="#代理（Proxy）模式" class="headerlink" title="代理（Proxy）模式"></a>代理（Proxy）模式</h2><p><strong>代理模式</strong>为其他对象提供一种<strong>代理</strong>以控制对这个对象的访问。换句话说，代理对象在客户端和目标对象之间起到了中介的作用，它可以在不改变目标对象的情况下，通过代理对象来控制对目标对象的访问</p>
<p>在某些情况下，一个对象不适合或不能直接访问另一个对象。这可能是由于多种原因，如：</p>
<ul>
<li><strong>远程代理（Remote Proxy）</strong>：对象位于不同的地址空间，需要通过网络通信。</li>
<li><strong>虚拟代理（Virtual Proxy）</strong>：对象的创建开销很大，只有在需要时才创建。</li>
<li><strong>保护代理（Protection Proxy）</strong>：控制对对象的访问权限。</li>
<li><strong>智能引用（Smart Reference）</strong>：当对象被访问时，进行一些额外的操作。</li>
</ul>
<p>通过引入代理对象，客户端可以透明地使用目标对象，而代理对象可以在访问目标对象之前进行一些控制或优化。</p>
<h3 id="1、远程代理"><a href="#1、远程代理" class="headerlink" title="1、远程代理"></a>1、远程代理</h3><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//数据库接口</span><br><span class="line">class Database &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual string queryData(const string&amp; query) = 0;</span><br><span class="line">	virtual ~Database() = default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//真实对象</span><br><span class="line">class RealDatabase : public Database &#123;</span><br><span class="line">public:</span><br><span class="line">	string queryData(const string&amp; query) override &#123;</span><br><span class="line">		return &quot;Data for &quot; + query;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//代理对象</span><br><span class="line">class DatabaseProxy : public Database &#123;</span><br><span class="line">public:</span><br><span class="line">	string queryData(const string&amp; query) override &#123;</span><br><span class="line">		if (cache_ == query) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;Return cached data for : &quot; &lt;&lt; query &lt;&lt; endl;</span><br><span class="line">			return cacheData_;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (!realDatabase_) &#123;</span><br><span class="line">				realDatabase_ = make_unique&lt;RealDatabase&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			string data = realDatabase_-&gt;queryData(query);</span><br><span class="line">			cache_ = query;</span><br><span class="line">			cacheData_ = data;</span><br><span class="line">			return data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	unique_ptr&lt;RealDatabase&gt; realDatabase_;</span><br><span class="line">	string cache_;//缓存指令</span><br><span class="line">	string cacheData_;//缓存指令的结果</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	unique_ptr&lt;Database&gt; db = make_unique&lt;DatabaseProxy&gt;();</span><br><span class="line"></span><br><span class="line">	string result1 = db-&gt;queryData(&quot;select * from uers&quot;);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string result2 = db-&gt;queryData(&quot;select * from uers&quot;);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用代理模式来隐藏网络通信的细节。</p>
<h3 id="2、虚拟代理"><a href="#2、虚拟代理" class="headerlink" title="2、虚拟代理"></a>2、虚拟代理</h3><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Image &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void display()  = 0;</span><br><span class="line">	virtual ~Image() = default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RealImage : public Image &#123;</span><br><span class="line">public:</span><br><span class="line">	RealImage(const string&amp; filename) : filename_(filename) &#123;</span><br><span class="line">		loadFromDisk(filename_);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void display() override &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Displaying &quot; &lt;&lt; filename_ &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	void loadFromDisk(const string&amp; filename) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;loading....&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string filename_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ProxyImage : public Image &#123;</span><br><span class="line">public:</span><br><span class="line">	ProxyImage(const std::string&amp; filename) : filename_(filename) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	void display() override &#123;</span><br><span class="line">		if (!realImage_) &#123;</span><br><span class="line">			realImage_ = std::make_unique&lt;RealImage&gt;(filename_);</span><br><span class="line">		&#125;</span><br><span class="line">		realImage_-&gt;display();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	std::string filename_;</span><br><span class="line">	std::unique_ptr&lt;RealImage&gt; realImage_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::unique_ptr&lt;Image&gt; image = std::make_unique&lt;ProxyImage&gt;(&quot;test_image.jpg&quot;);</span><br><span class="line"></span><br><span class="line">	// 图像将从磁盘加载  </span><br><span class="line">	std::cout &lt;&lt; &quot;First time display:&quot; &lt;&lt; std::endl;</span><br><span class="line">	image-&gt;display();</span><br><span class="line"></span><br><span class="line">	// 图像不需要再次从磁盘加载  </span><br><span class="line">	std::cout &lt;&lt; &quot;\nSecond time display:&quot; &lt;&lt; std::endl;</span><br><span class="line">	image-&gt;display();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、保护代理"><a href="#3、保护代理" class="headerlink" title="3、保护代理"></a>3、保护代理</h3><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class File &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void read() = 0;</span><br><span class="line">    virtual void write(const std::string&amp; data) = 0;</span><br><span class="line">    virtual ~File() = default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RealFile : public File &#123;</span><br><span class="line">public:</span><br><span class="line">    RealFile(const std::string&amp; filename) : filename_(filename) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void read() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Reading from file: &quot; &lt;&lt; filename_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void write(const std::string&amp; data) override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Writing &#x27;&quot; &lt;&lt; data &lt;&lt; &quot;&#x27; to file: &quot; &lt;&lt; filename_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::string filename_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum class Permission &#123;</span><br><span class="line">    READ_ONLY,</span><br><span class="line">    READ_WRITE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 用户类  </span><br><span class="line">class User &#123;</span><br><span class="line">public:</span><br><span class="line">    User(const std::string&amp; name, Permission permission)</span><br><span class="line">        : name_(name), permission_(permission) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    std::string getName() const &#123; return name_; &#125;</span><br><span class="line">    Permission getPermission() const &#123; return permission_; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::string name_;</span><br><span class="line">    Permission permission_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 保护代理  </span><br><span class="line">class ProtectedFileProxy : public File &#123;</span><br><span class="line">public:</span><br><span class="line">    ProtectedFileProxy(const std::string&amp; filename, const User&amp; user)</span><br><span class="line">        : filename_(filename), user_(user) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void read() override &#123;</span><br><span class="line">        if (hasReadPermission()) &#123;</span><br><span class="line">            getFile()-&gt;read();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Access denied: User &#x27;&quot; &lt;&lt; user_.getName()</span><br><span class="line">                &lt;&lt; &quot;&#x27; does not have read permission.&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void write(const std::string&amp; data) override &#123;</span><br><span class="line">        if (hasWritePermission()) &#123;</span><br><span class="line">            getFile()-&gt;write(data);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Access denied: User &#x27;&quot; &lt;&lt; user_.getName()</span><br><span class="line">                &lt;&lt; &quot;&#x27; does not have write permission.&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    bool hasReadPermission() const &#123;</span><br><span class="line">        return user_.getPermission() == Permission::READ_ONLY ||</span><br><span class="line">            user_.getPermission() == Permission::READ_WRITE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasWritePermission() const &#123;</span><br><span class="line">        return user_.getPermission() == Permission::READ_WRITE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RealFile* getFile() &#123;</span><br><span class="line">        if (!realFile_) &#123;</span><br><span class="line">            realFile_ = std::make_unique&lt;RealFile&gt;(filename_);</span><br><span class="line">        &#125;</span><br><span class="line">        return realFile_.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string filename_;</span><br><span class="line">    const User&amp; user_;</span><br><span class="line">    std::unique_ptr&lt;RealFile&gt; realFile_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    User alice(&quot;Alice&quot;, Permission::READ_ONLY);</span><br><span class="line">    User bob(&quot;Bob&quot;, Permission::READ_WRITE);</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;File&gt; fileForAlice = std::make_unique&lt;ProtectedFileProxy&gt;(&quot;data.txt&quot;, alice);</span><br><span class="line">    std::unique_ptr&lt;File&gt; fileForBob = std::make_unique&lt;ProtectedFileProxy&gt;(&quot;data.txt&quot;, bob);</span><br><span class="line"></span><br><span class="line">    // Alice 尝试读取文件  </span><br><span class="line">    fileForAlice-&gt;read();</span><br><span class="line"></span><br><span class="line">    // Alice 尝试写入文件  </span><br><span class="line">    fileForAlice-&gt;write(&quot;Hello World&quot;);</span><br><span class="line"></span><br><span class="line">    // Bob 尝试读取文件  </span><br><span class="line">    fileForBob-&gt;read();</span><br><span class="line"></span><br><span class="line">    // Bob 尝试写入文件  </span><br><span class="line">    fileForBob-&gt;write(&quot;Hello World&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、智能引用"><a href="#4、智能引用" class="headerlink" title="4、智能引用"></a>4、智能引用</h3><p><strong>智能引用（Smart Reference）**也称为**智能指引**，在代理对象中增加了额外的操作，以便在访问真实对象时执行一些</strong>附加行为**。</p>
<p>这些附加行为可能包括：</p>
<ul>
<li><strong>引用计数</strong>：自动管理对象的生命周期。</li>
<li><strong>记录日志</strong>：在访问对象时记录日志。</li>
<li><strong>调试</strong>：在访问对象时输出调试信息。</li>
<li><strong>线程安全</strong>：在访问对象时保证线程安全。</li>
</ul>
<p>智能引用在某种程度上类似于智能指针，它在对对象的引用上增加了额外的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Calculator &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int add(int a, int b) = 0;</span><br><span class="line">    virtual int subtract(int a, int b) = 0;</span><br><span class="line">    virtual ~Calculator() = default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RealCalculator : public Calculator &#123;</span><br><span class="line">public:</span><br><span class="line">    int add(int a, int b) override &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int subtract(int a, int b) override &#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LoggingCalculatorProxy : public Calculator &#123;</span><br><span class="line">public:</span><br><span class="line">    LoggingCalculatorProxy() &#123;</span><br><span class="line">        realCalculator_ = std::make_unique&lt;RealCalculator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int add(int a, int b) override &#123;</span><br><span class="line">        log(&quot;add&quot;, a, b);</span><br><span class="line">        auto start = std::chrono::high_resolution_clock::now();</span><br><span class="line">        int result = realCalculator_-&gt;add(a, b);</span><br><span class="line">        auto end = std::chrono::high_resolution_clock::now();</span><br><span class="line">        logExecutionTime(&quot;add&quot;, start, end);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int subtract(int a, int b) override &#123;</span><br><span class="line">        log(&quot;subtract&quot;, a, b);</span><br><span class="line">        auto start = std::chrono::high_resolution_clock::now();</span><br><span class="line">        int result = realCalculator_-&gt;subtract(a, b);</span><br><span class="line">        auto end = std::chrono::high_resolution_clock::now();</span><br><span class="line">        logExecutionTime(&quot;subtract&quot;, start, end);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void log(const std::string&amp; operation, int a, int b) const &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Executing &quot; &lt;&lt; operation &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void logExecutionTime(const std::string&amp; operation,</span><br><span class="line">        const std::chrono::high_resolution_clock::time_point&amp; start,</span><br><span class="line">        const std::chrono::high_resolution_clock::time_point&amp; end) const &#123;</span><br><span class="line">        auto duration = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();</span><br><span class="line">        std::cout &lt;&lt; &quot;Execution time of &quot; &lt;&lt; operation &lt;&lt; &quot;: &quot; &lt;&lt; duration &lt;&lt; &quot; nanoseconds&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;RealCalculator&gt; realCalculator_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::unique_ptr&lt;Calculator&gt; calculator = std::make_unique&lt;LoggingCalculatorProxy&gt;();</span><br><span class="line"></span><br><span class="line">    int sum = calculator-&gt;add(5, 3);</span><br><span class="line">    std::cout &lt;&lt; &quot;Result of add: &quot; &lt;&lt; sum &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    int difference = calculator-&gt;subtract(10, 4);</span><br><span class="line">    std::cout &lt;&lt; &quot;Result of subtract: &quot; &lt;&lt; difference &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总体回顾"><a href="#总体回顾" class="headerlink" title="总体回顾"></a><strong>总体回顾</strong></h3><h4 id="代理模式的四种类型"><a href="#代理模式的四种类型" class="headerlink" title="代理模式的四种类型"></a><strong>代理模式的四种类型</strong></h4><ol>
<li><strong>远程代理（Remote Proxy）</strong><ul>
<li>为远程的对象提供本地代理，隐藏网络通信细节。</li>
<li><strong>示例</strong>：分布式系统中访问远程服务。</li>
</ul>
</li>
<li><strong>虚拟代理（Virtual Proxy）</strong><ul>
<li>控制对象的实例化，在需要时才创建对象，节省资源。</li>
<li><strong>示例</strong>：延迟加载大型图片或大数据对象。</li>
</ul>
</li>
<li><strong>保护代理（Protection Proxy）</strong><ul>
<li>控制对对象的访问，根据权限进行操作。</li>
<li><strong>示例</strong>：文件系统中的权限控制，用户认证。</li>
</ul>
</li>
<li><strong>智能引用（Smart Reference）</strong><ul>
<li>在访问对象时，执行额外的操作，如日志、性能统计、引用计数等。</li>
<li><strong>示例</strong>：对象方法调用的日志记录，智能指针。</li>
</ul>
</li>
</ol>
<h4 id="代理模式的优点"><a href="#代理模式的优点" class="headerlink" title="代理模式的优点"></a><strong>代理模式的优点</strong></h4><ul>
<li><strong>灵活性</strong>：可以在不修改真实对象的情况下，控制对其的访问或增加功能。</li>
<li><strong>解耦</strong>：客户端无需关心对象的访问细节。</li>
<li><strong>扩展性</strong>：可以根据需要增加不同类型的代理，实现多种功能。</li>
</ul>
<h4 id="代理模式的缺点"><a href="#代理模式的缺点" class="headerlink" title="** 代理模式的缺点**"></a>** 代理模式的缺点**</h4><ul>
<li><strong>性能开销</strong>：增加了额外的代理对象，可能影响性能。</li>
<li><strong>复杂度增加</strong>：引入了额外的层次，增加了系统的复杂性。</li>
</ul>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><table>
<thead>
<tr>
<th><strong>设计模式</strong></th>
<th><strong>不同之处</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>适配器模式</strong> (Adapter)</td>
<td>将一个类的接口转换成客户希望的另一个接口，使原本接口不兼容的类可以一起工作。</td>
<td>- 让不兼容的类可以协同工作<br>- 提高了类的复用性</td>
<td>- 过多使用会使系统复杂化<br>- 可能更容易直接修改代码而非使用适配器</td>
<td>- 需要使用现有类但其接口不符合需求时<br>- 想创建可复用的类，用于与其他不相关的类协作</td>
</tr>
<tr>
<td><strong>桥接模式</strong> (Bridge)</td>
<td>将抽象部分与实现部分分离，使它们可以独立变化。</td>
<td>- 分离了接口与实现，降低了耦合<br>- 提高了系统的扩展性<br>- 符合开闭原则</td>
<td>- 增加了系统的理解与设计难度<br>- 需要正确地识别出系统中两个独立变化的维度</td>
<td>- 不希望在抽象与实现间有固定绑定关系时<br>- 抽象和实现都需要扩展时</td>
</tr>
<tr>
<td><strong>组合模式</strong> (Composite)</td>
<td>将对象组合成树形结构以表示部分-整体的层次结构，使客户对单个对象和组合对象的使用具有一致性。</td>
<td>- 定义了包含基本对象和组合对象的类层次结构<br>- 简化了客户端代码，客户端可以一致地使用组合对象和单个对象</td>
<td>- 使系统设计变得更加复杂<br>- 限制类型时会较困难</td>
<td>- 表示对象的部分-整体层次结构时<br>- 希望用户忽略组合对象与单个对象的差异，统一使用组合结构中的所有对象</td>
</tr>
<tr>
<td><strong>装饰模式</strong> (Decorator)</td>
<td>动态地给对象添加一些额外的职责，就增加功能而言，装饰模式比生成子类更为灵活。</td>
<td>- 比继承更加灵活<br>- 避免在类层次中添加过多功能，符合开闭原则<br>- 可以动态地增加对象的功能</td>
<td>- 会产生许多细小的对象，增加系统复杂性<br>- 多个装饰器组合时，调试困难</td>
<td>- 需要动态地为对象添加职责时<br>- 不能采用继承方式进行扩充时</td>
</tr>
<tr>
<td><strong>外观模式</strong> (Facade)</td>
<td>为子系统中的一组接口提供一个一致的界面，定义了一个高层接口，使子系统更易使用。</td>
<td>- 简化了客户端对系统的使用<br>- 降低了客户端与子系统间的耦合度<br>- 更好的分层，符合迪米特法则</td>
<td>- 增加了额外的外观对象，可能会掩盖子系统的真实功能<br>- 不易于进行子系统的细节控制</td>
<td>- 为复杂的子系统提供简单接口时<br>- 系统层次结构较复杂，需要分层次进行控制时</td>
</tr>
<tr>
<td><strong>享元模式</strong> (Flyweight)</td>
<td>运用共享技术有效地支持大量细粒度的对象，减少内存开销。</td>
<td>- 大大减少对象的数量，节省内存<br>- 提高性能，减少内存之外的其他资源占用</td>
<td>- 使系统逻辑复杂化<br>- 需要分离出内部状态和外部状态，且外部状态需要稳妥管理</td>
<td>- 系统中存在大量相似对象，造成内存开销过大时<br>- 对象的大部分状态都可外部化时</td>
</tr>
<tr>
<td><strong>代理模式</strong> (Proxy)</td>
<td>为其他对象提供一种代理以控制对这个对象的访问。</td>
<td>- 控制了真实对象的访问<br>- 可以在不修改目标对象的情况下添加额外的功能</td>
<td>- 增加了系统的复杂度<br>- 由于多了一层间接访问，可能会影响速度</td>
<td>- 需要在访问对象时增加额外的功能，如权限控制、远程访问等<br>- 需要为复杂对象提供一个简单的代理以降低系统开销</td>
</tr>
</tbody></table>
<ul>
<li><strong>适配器模式</strong>主要解决接口不兼容的问题，通过引入适配器类，实现转换。</li>
<li><strong>桥接模式</strong>关注抽象和实现的分离，适用于有多个维度变化的场景。</li>
<li><strong>组合模式</strong>适用于树形结构，方便对整体和部分进行一致性操作。</li>
<li><strong>装饰模式</strong>主要为了动态地为对象添加功能，并且可以随意组合这些功能。</li>
<li><strong>外观模式</strong>为子系统提供统一的入口，简化客户端的使用。</li>
<li><strong>享元模式</strong>通过共享技术来有效支持大量细粒度的对象，节省系统资源。</li>
<li><strong>代理模式</strong>为目标对象提供一个代理，以控制对目标对象的访问，可以在代理中加入额外的操作。</li>
</ul>
<p>ps:<strong>“细粒度”</strong>（fine-grained）的意思是把事物划分得非常细小、非常具体</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/10/04/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F(%E4%B8%8A)/" rel="prev" title="行为型模式（上）">
      <i class="fa fa-chevron-left"></i> 行为型模式（上）
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/08/shell%E8%84%9A%E6%9C%AC/" rel="next" title="linux查漏补缺">
      linux查漏补缺 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88Adapter%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">适配器（Adapter）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90"><span class="nav-number">1.1.2.</span> <span class="nav-text">具体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%EF%BC%88Bridge%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">桥接（Bridge）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">具体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">桥接模式的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">桥接模式的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">桥接模式的注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%EF%BC%88Composite%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">组合（Composite）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">具体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">组合模式的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">组合模式的适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">组合模式的注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%EF%BC%88Decorator%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">装饰（Decorator）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">具体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%EF%BC%88Facade%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.</span> <span class="nav-text">外观（Facade）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">1.5.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">具体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%EF%BC%88Flyweight%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">享元（Flyweight）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">1.6.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90-5"><span class="nav-number">1.6.2.</span> <span class="nav-text">具体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%EF%BC%88Proxy%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.7.</span> <span class="nav-text">代理（Proxy）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86"><span class="nav-number">1.7.1.</span> <span class="nav-text">1、远程代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86"><span class="nav-number">1.7.2.</span> <span class="nav-text">2、虚拟代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BF%9D%E6%8A%A4%E4%BB%A3%E7%90%86"><span class="nav-number">1.7.3.</span> <span class="nav-text">3、保护代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%99%BA%E8%83%BD%E5%BC%95%E7%94%A8"><span class="nav-number">1.7.4.</span> <span class="nav-text">4、智能引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.7.5.</span> <span class="nav-text">总体回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">代理模式的四种类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">代理模式的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.7.5.3.</span> <span class="nav-text">** 代理模式的缺点**</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%BC%E5%90%88"><span class="nav-number">1.8.</span> <span class="nav-text">综合</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AlexQFMM"
      src="/images/Avatar.jpg">
  <p class="site-author-name" itemprop="name">AlexQFMM</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://qexo-ten-roan.vercel.app/" title="控制中心 → https:&#x2F;&#x2F;qexo-ten-roan.vercel.app&#x2F;" rel="noopener" target="_blank">控制中心</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AlexQFMM</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'UaEUwcYLlkREnSn9jPNe0oRf-gzGzoHsz',
      appKey     : '5d7KwGdf31jiCBxBobH0wVk6',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/miku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
