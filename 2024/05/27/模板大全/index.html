<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="模板大全二分模板1本文档绝大多数程序都是洛谷模板题">
<meta property="og:type" content="article">
<meta property="og:title" content="模板大全">
<meta property="og:url" content="http://example.com/2024/05/27/%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8/index.html">
<meta property="og:site_name" content="AlexHome">
<meta property="og:description" content="模板大全二分模板1本文档绝大多数程序都是洛谷模板题">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-27T13:18:45.000Z">
<meta property="article:modified_time" content="2024-12-01T13:58:43.018Z">
<meta property="article:author" content="AlexQFMM">
<meta property="article:tag" content="算法基础">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/05/27/%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>模板大全 | AlexHome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">AlexHome</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
        <li class="menu-item menu-item-mypage">

    <a href="/MYHTML/test/index.html" rel="section"><i class="fas fa-file-user fa-fw"></i>myPage</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/27/%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.jpg">
      <meta itemprop="name" content="AlexQFMM">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AlexHome">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          模板大全
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-27 13:18:45" itemprop="dateCreated datePublished" datetime="2024-05-27T13:18:45+00:00">2024-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-01 13:58:43" itemprop="dateModified" datetime="2024-12-01T13:58:43+00:00">2024-12-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">算法专项</span></a>
                </span>
            </span>

          
            <span id="/2024/05/27/%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8/" class="post-meta-item leancloud_visitors" data-flag-title="模板大全" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/05/27/%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/05/27/%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="模板大全"><a href="#模板大全" class="headerlink" title="模板大全"></a>模板大全</h1><h1 id="二分模板"><a href="#二分模板" class="headerlink" title="二分模板"></a>二分模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文档绝大多数程序都是洛谷模板题</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基础二分（寻找x在有序数列中的下标，不存在返回-1）"><a href="#基础二分（寻找x在有序数列中的下标，不存在返回-1）" class="headerlink" title="基础二分（寻找x在有序数列中的下标，不存在返回-1）"></a>基础二分（寻找x在有序数列中的下标，不存在返回-1）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int search(int x)&#123;</span><br><span class="line">	int l=0,r=N-1;</span><br><span class="line">	while(l&lt;=r)&#123;</span><br><span class="line">		int mid = l+r &gt;&gt; 1;</span><br><span class="line">		if(a[mid] &gt; x) r = mid-1;</span><br><span class="line">		else if(a[mid] &lt; x) l=mid+1;</span><br><span class="line">		else return mid;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间二分（寻找重复值的左端点）"><a href="#区间二分（寻找重复值的左端点）" class="headerlink" title="区间二分（寻找重复值的左端点）"></a>区间二分（寻找重复值的左端点）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool check(int mid,int x)&#123;</span><br><span class="line">	return nums[mid] &gt;= x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int searchL(int x)&#123;</span><br><span class="line">	int l=0,r=N-1;</span><br><span class="line">	while(l&lt;r)&#123;</span><br><span class="line">		int mid = l+r &gt;&gt; 1;</span><br><span class="line">		if(check(mid,x)) r=mid;</span><br><span class="line">		else l=mid+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间二分（寻找重复值的右端点）"><a href="#区间二分（寻找重复值的右端点）" class="headerlink" title="区间二分（寻找重复值的右端点）"></a>区间二分（寻找重复值的右端点）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool check(int mid,int x)&#123;</span><br><span class="line">	return nums[mid] &lt;= x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int searchR(int x)&#123;</span><br><span class="line">	int l=0,r=N-1;</span><br><span class="line">	while(l&lt;r)&#123;</span><br><span class="line">		int mid = l+r+1 &gt;&gt; 1;//不加1会死循环</span><br><span class="line">		if(check(mid,x)) l=mid;</span><br><span class="line">		else r=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:根据实际情况修改check就是了</p>
<h1 id="前缀和模板"><a href="#前缀和模板" class="headerlink" title="前缀和模板"></a>前缀和模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">适用于简单的单点修改和查询、区间和查询、区间最值查询等，是最简单的数据结构之一，但不支持区间修改</span><br></pre></td></tr></table></figure>



<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">ll a[N],b[N],n,m;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i] += a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin &gt;&gt;  l &gt;&gt; r;</span><br><span class="line">		cout &lt;&lt; a[r] - a[l-1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用前缀和找无序数组分割线，让他两边差值最小（未验证）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line"></span><br><span class="line">const int N = 10;</span><br><span class="line"></span><br><span class="line">int nums[N] = &#123;0,1,3,5,7,9,2,4,6,8&#125;;//1-9</span><br><span class="line">int sum[N] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int getSum(int l,int r)&#123;</span><br><span class="line">	return sum[r] - sum[l-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	sum[1] = nums[1];</span><br><span class="line">	for(int i=2;i&lt;N;i++)&#123;</span><br><span class="line">		sum[i] = sum[i-1] + nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;N;i++)  cout &lt;&lt; sum[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	int ans = 2;//分割线在2前面 </span><br><span class="line">	int minDiff = getSum(2,N-1) - getSum(1,1); </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	for(int i = 3;i&lt;N;i++)&#123;</span><br><span class="line">		int diff = abs(getSum(i,N-1) - getSum(1,i));</span><br><span class="line"></span><br><span class="line">		if(diff &lt; minDiff)&#123;</span><br><span class="line">			minDiff = diff;</span><br><span class="line">			ans = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; &quot;:&quot; &lt;&lt; getSum(1,ans) &lt;&lt; &quot;-&quot; &lt;&lt; getSum(ans+1,N-1) &lt;&lt; &quot;=&quot; &lt;&lt; minDiff &lt;&lt;  endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e3+10;</span><br><span class="line">int metriax[N][N],row,col,q;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; row &gt;&gt; col &gt;&gt; q;</span><br><span class="line">    for(int i = 1; i &lt;= row; i++)&#123;</span><br><span class="line">        for(int j = 1; j &lt;= col; j++)&#123;</span><br><span class="line">            cin &gt;&gt; metriax[i][j];</span><br><span class="line">            metriax[i][j] = metriax[i][j] + metriax[i-1][j] + metriax[i][j-1] - metriax[i-1][j-1]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int x1, y1, x2, y2;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; metriax[x2][y2] - metriax[x1-1][y2] - metriax[x2][y1-1] + metriax[x1-1][y1-1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="差分模板"><a href="#差分模板" class="headerlink" title="差分模板"></a>差分模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">适用于高效实现区间修改和查询，构建和维护成本稍高，但是不支持复杂的区间操作</span><br></pre></td></tr></table></figure>

<h2 id="一维数组-1"><a href="#一维数组-1" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=5;</span><br><span class="line">int nums[N+1]=&#123;0,1,3,5,7,9&#125;;//原数组 </span><br><span class="line">int sub[N+1];//差分数组 </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	for(int i=1;i&lt;=N;i++)</span><br><span class="line">		sub[i] = nums[i] - nums[i-1];//差分预处理</span><br><span class="line">		 </span><br><span class="line">	int l=2,r=4,x=3;//[l,r]+x;</span><br><span class="line">	sub[l] += x;</span><br><span class="line">	sub[r+1] -= x;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=N;i++)&#123;//还原数组 </span><br><span class="line">		nums[i] = nums[i-1] + sub[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维矩阵"><a href="#二维矩阵" class="headerlink" title="二维矩阵"></a>二维矩阵</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e3+10;</span><br><span class="line">int nums[N][N],diff[N][N],row,col,q;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; row &gt;&gt; col &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= row; i++) &#123;// 读入原始矩阵</span><br><span class="line">        for (int j = 1; j &lt;= col; j++) &#123;</span><br><span class="line">            cin &gt;&gt; nums[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= row; i++) &#123;// 构建差分矩阵</span><br><span class="line">        for (int j = 1; j &lt;= col; j++) &#123;</span><br><span class="line">            diff[i][j] = nums[i][j] - nums[i - 1][j] - nums[i][j - 1] + nums[i - 1][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (q--) &#123;// 区间修改</span><br><span class="line">        int x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        </span><br><span class="line">        diff[x1][y1] += c;</span><br><span class="line">        diff[x2 + 1][y1] -= c;</span><br><span class="line">        diff[x1][y2 + 1] -= c;</span><br><span class="line">        diff[x2 + 1][y2 + 1] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= row; i++) &#123;// 构建最终的矩阵</span><br><span class="line">        for (int j = 1; j &lt;= col; j++) &#123;</span><br><span class="line">            nums[i][j] = diff[i][j] + nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= row; i++) &#123;// 输出最终矩阵</span><br><span class="line">        for (int j = 1; j &lt;= col; j++) &#123;</span><br><span class="line">            cout &lt;&lt; nums[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速幂模板"><a href="#快速幂模板" class="headerlink" title="快速幂模板"></a>快速幂模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line"></span><br><span class="line">ll power(ll a,ll b,ll p)&#123;</span><br><span class="line">	int ans=1;</span><br><span class="line">	while(b)&#123;</span><br><span class="line">		if(b&amp;1) ans = (ans*a)%p;</span><br><span class="line">		a = (a*(ll)a)%p;</span><br><span class="line">		b &gt;&gt;=1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	ll a,b,p;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	printf(&quot;%ld^%ld mod %ld=%ld&quot;,a,b,p,power(a,b,p));</span><br><span class="line">	return 0;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">求a*x 同余 1 (mod p)</span><br><span class="line"></span><br><span class="line">可以用费马小定理，快速幂解决</span><br><span class="line">即power(a,p-2,p);</span><br></pre></td></tr></table></figure>



<h1 id="筛选素数模板"><a href="#筛选素数模板" class="headerlink" title="筛选素数模板"></a>筛选素数模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const ll N = 1e8 + 10;</span><br><span class="line"></span><br><span class="line">vector&lt;bool&gt; isPrime(N, true);</span><br><span class="line">vector&lt;ll&gt; prime;</span><br><span class="line"></span><br><span class="line">void init(ll n) &#123;</span><br><span class="line">    isPrime[0] = isPrime[1] = false;</span><br><span class="line">    for (ll i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        if (isPrime[i]) &#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">            for (ll j = i * i; j &lt;= n; j += i)</span><br><span class="line">                isPrime[j] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    init(n);</span><br><span class="line">    while (q--) &#123;</span><br><span class="line">        ll k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; prime[k - 1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串hash模板"><a href="#字符串hash模板" class="headerlink" title="字符串hash模板"></a>字符串hash模板</h1><p>原理：将字符串映射成p进制数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int MOD = 1e9+7;//防止溢出</span><br><span class="line">const int P =131;//错误率最低</span><br><span class="line">const int N = 1010;</span><br><span class="line">ll checkhash(const string&amp; s)&#123;//计算hash值 </span><br><span class="line">	ll sum;</span><br><span class="line">	int n = s.size();</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		sum = (sum*P+s[i])%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isIn(vector&lt;ll&gt;ans,ll x)&#123;</span><br><span class="line">	for(ll i:ans) if(i==x) return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;ll&gt;ans;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;			</span><br><span class="line">		ll sv = checkhash(s);//计算hash值，如果已经存在那就不存了</span><br><span class="line">		if(isIn(ans,sv)) ans.push_back(sv);d</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ans.size() &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Floyd模板"><a href="#Floyd模板" class="headerlink" title="Floyd模板"></a>Floyd模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e4;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int grid[N][N],n,m;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	memset(grid,INF,sizeof(grid));</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++) grid[i][i] = 0;//到自己的距离为0 </span><br><span class="line">	</span><br><span class="line">	for(int i=1; i&lt;=m; i++) &#123;//输入边 </span><br><span class="line">		int x,y,v;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">		grid[x][y] = min(grid[x][y],v);</span><br><span class="line">		grid[y][x] = min(grid[y][x],v);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int k=1; k&lt;=n; k++) &#123;//核心代码 </span><br><span class="line">		for(int i=1; i&lt;=n; i++) &#123;</span><br><span class="line">			for(int j=1; j&lt;=n; j++) &#123;</span><br><span class="line">				if(grid[i][k]!=INF&amp;&amp;grid[k][j]!=INF) &#123;</span><br><span class="line">					grid[i][j] = min(grid[i][j],grid[i][k]+grid[k][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=1; i&lt;=n; i++) &#123;//输出处理后的矩阵 </span><br><span class="line">		for(int j=1; j&lt;=n; j++) &#123;</span><br><span class="line">			cout &lt;&lt; grid[i][j]&lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p>他也可以用来传递闭包-》也就是检查图的联通性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">int n;</span><br><span class="line">int a[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    for (int k = 1; k &lt;= n; k++)//Floyd </span><br><span class="line">        for (int i = 1; i &lt;= n; i++)</span><br><span class="line">            for (int j = 1; j &lt;= n; j++)</span><br><span class="line">                a[i][j] |= (a[i][k] &amp; a[k][j]); // 用逻辑与操作更新传递闭包</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="拓扑排序模板"><a href="#拓扑排序模板" class="headerlink" title="拓扑排序模板"></a>拓扑排序模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=110;</span><br><span class="line">int degree[N];</span><br><span class="line">vector&lt;int&gt;grid[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			int x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			if(x==0) break;</span><br><span class="line">			grid[i].push_back(x);</span><br><span class="line">			++degree[x];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;int&gt;q1;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">		if(degree[i] == 0) q1.push(i); </span><br><span class="line">	vector&lt;int&gt;ans;</span><br><span class="line">	</span><br><span class="line">	while(!q1.empty())&#123;</span><br><span class="line">		int u = q1.front();</span><br><span class="line">		q1.pop();</span><br><span class="line">		ans.push_back(u);</span><br><span class="line">		for(int v:grid[u])&#123;</span><br><span class="line">			if(--degree[v] == 0)&#123;</span><br><span class="line">				q1.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i:ans) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">ll nums[N];</span><br><span class="line">deque&lt;int&gt;dq;</span><br><span class="line">int n,k;</span><br><span class="line"></span><br><span class="line">bool op(ll x,ll y,bool flag)&#123;//true:找最大值，false：找最小值</span><br><span class="line">	if (flag)</span><br><span class="line">		return x &gt; y;</span><br><span class="line">	else</span><br><span class="line">		return x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; FindInWindows(bool flag)&#123;</span><br><span class="line"> 	vector&lt;ll&gt;ans;</span><br><span class="line"> 	</span><br><span class="line"> 	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line"> 		if(!dq.empty() &amp;&amp; dq.front() == i-k)&#123;//队首下标超出范围了</span><br><span class="line"> 			dq.pop_front();	</span><br><span class="line">		&#125;</span><br><span class="line">		while(!dq.empty() &amp;&amp; op(nums[i],nums[dq.back()],flag))&#123;//从队尾开始，不符合条件的都干掉</span><br><span class="line"> 			dq.pop_back();	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		dq.push_back(i);</span><br><span class="line">		</span><br><span class="line">		if(i &gt;= k+1)&#123;</span><br><span class="line">			ans.push_back(nums[dq.front()]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ans;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	for(int i=0;i&lt;n;i++) cin &gt;&gt; nums[i];</span><br><span class="line"></span><br><span class="line">	vector&lt;ll&gt;ans1 = FindInWindows(false);</span><br><span class="line">	dq.clear();</span><br><span class="line">	vector&lt;ll&gt;ans2 = FindInWindows(true);</span><br><span class="line">	</span><br><span class="line">	for(ll i:ans1) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for(ll i:ans2) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列解法"><a href="#优先队列解法" class="headerlink" title="优先队列解法"></a>优先队列解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using PILL = pair&lt;int,int&gt;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;PILL&gt;pq1;</span><br><span class="line">priority_queue&lt;PILL,vector&lt;PILL&gt;,greater&lt;PILL&gt;&gt;pq2;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	vector&lt;int&gt;ans1,ans2;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		pq1.push(&#123;x,i&#125;),pq2.push(&#123;x,i&#125;);</span><br><span class="line">		if(i&gt;=k)&#123;</span><br><span class="line">			while(i - pq1.top().second &gt;= k) pq1.pop();</span><br><span class="line">			ans2.push_back(pq1.top().first);</span><br><span class="line">			while(i - pq2.top().second &gt;= k) pq2.pop();</span><br><span class="line">			ans1.push_back(pq2.top().first);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i:ans1) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for(int i:ans2) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 $n$ 个元素的<strong>整数</strong>序列 $A$，记作 $A_1,A_2,A_3,…,A_n$。</p>
<p>求另一个包含 $n$ 个元素的待定<strong>整数</strong>序列 $X$，记 $S&#x3D;\sum\limits_{i&#x3D;1}^nA_i\times X_i$，使得 $S&gt;0$ 且 $S$ 尽可能的小。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$，表示序列元素个数。  </p>
<p>第二行 $n$ 个整数，表示序列 $A$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示 $S&gt;0$ 的前提下 $S$ 的最小值。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4059 -1782</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $100%$ 的数据，$1 \le n \le 20$，$|A_i| \le 10^5$，且 $A$ 序列不全为 $0$。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于任意给定的整数a和b，存在整数x和y，使得它们满足方程ax + by = gcd(a, b)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int gcd(int x,int y)&#123;</span><br><span class="line">	if(y==0) return x;</span><br><span class="line">	return gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;	</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int ans=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int tmp;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		if(tmp &lt;0) tmp =-tmp;</span><br><span class="line">		ans = gcd(ans,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 3e6+10;</span><br><span class="line">ll nums[N],ans[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;	</span><br><span class="line">	ll n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(int i=0;i&lt;n;i++) cin &gt;&gt; nums[i];</span><br><span class="line">	stack&lt;ll&gt;st1;</span><br><span class="line">	st1.push(0);</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		while(!st1.empty() &amp;&amp; nums[i] &gt; nums[st1.top()])&#123;</span><br><span class="line">			ans[st1.top()] = i+1;</span><br><span class="line">			st1.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		st1.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 1e4+10;</span><br><span class="line"></span><br><span class="line">int fa[N];</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!=fa[x])&#123;</span><br><span class="line">		fa[x] = find(fa[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) fa[i] = i;</span><br><span class="line">	</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		int op,x,y;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		int px =find(x),py=find(y);</span><br><span class="line">		if(op == 2)&#123;</span><br><span class="line">			if(px == py) cout &lt;&lt;&quot;Y&quot;&lt;&lt;endl;</span><br><span class="line">			else cout &lt;&lt; &quot;N&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			fa[py] = px;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="倍增法LCA模板"><a href="#倍增法LCA模板" class="headerlink" title="倍增法LCA模板"></a>倍增法LCA模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=5e5+10;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;tree[N];</span><br><span class="line">int depth[N];</span><br><span class="line">int fa[N][20];</span><br><span class="line">bool visited[N]=&#123;false&#125;;</span><br><span class="line"></span><br><span class="line">void bfs(int root)&#123;</span><br><span class="line">	queue&lt;int&gt;q1;</span><br><span class="line">	q1.push(root);</span><br><span class="line">	depth[root] = 1;</span><br><span class="line">	fa[root][0] = root;</span><br><span class="line">	</span><br><span class="line">	while(!q1.empty())&#123;</span><br><span class="line">		int par = q1.front();</span><br><span class="line">		q1.pop();</span><br><span class="line">		visited[par] = true;</span><br><span class="line">		for(int v:tree[par])&#123;</span><br><span class="line">			if(!visited[v])&#123;</span><br><span class="line">				depth[v] = depth[par]+1;</span><br><span class="line">				fa[v][0] = par;</span><br><span class="line">				for(int j=1;j&lt;20;j++)&#123;</span><br><span class="line">					fa[v][j] = fa[fa[v][j-1]][j-1];</span><br><span class="line">				&#125;</span><br><span class="line">				q1.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int x,int y)&#123;</span><br><span class="line">	if(depth[x] &gt; depth[y]) swap(x,y);</span><br><span class="line">	for(int i=19;i&gt;=0;i--)&#123;</span><br><span class="line">		if(depth[fa[y][i]] &gt;= depth[x])&#123;</span><br><span class="line">			y = fa[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(x == y) return x;</span><br><span class="line">	for(int i=19;i&gt;=0;i--)&#123;</span><br><span class="line">		if(fa[y][i]!=fa[x][i])&#123;</span><br><span class="line">			y = fa[y][i];</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return fa[x][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	ios_base::sync_with_stdio(false);//洛谷上的原题，不加会有一个点超时</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line">	int n,m,root;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; root;</span><br><span class="line">	for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">		int x,y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt;y;</span><br><span class="line">		tree[x].push_back(y);</span><br><span class="line">		tree[y].push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	bfs(root);</span><br><span class="line">	</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		int x,y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		cout &lt;&lt; lca(x,y) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="【模板】三分-函数"><a href="#【模板】三分-函数" class="headerlink" title="【模板】三分 | 函数"></a>【模板】三分 | 函数</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 $n$ 个二次函数 $f_1(x),f_2(x),\dots,f_n(x)$（均形如 $ax^2+bx+c$），设 $F(x)&#x3D;\max{f_1(x),f_2(x),…,f_n(x)}$，求 $F(x)$ 在区间 $[0,1000]$ 上的最小值。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行为正整数 $T$，表示有 $T$ 组数据。</p>
<p>每组数据第一行一个正整数 $n$，接着 $n$ 行，每行 $3$ 个整数 $a,b,c$，用来表示每个二次函数的 $3$ 个系数，注意二次函数有可能退化成一次。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>每组数据输出一行，表示 $F(x)$ 的在区间 $[0,1000]$ 上的最小值。答案精确到小数点后四位，四舍五入。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2 0 0</span><br><span class="line">2</span><br><span class="line">2 0 0</span><br><span class="line">2 -4 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.0000</span><br><span class="line">0.5000</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>对于 $50%$ 的数据，$n\le 100$。</p>
<p>对于 $100%$ 的数据，$T&lt;10$，$\ n\le 10^4$，$0\le a\le 100$，$|b| \le 5\times 10^3$，$|c| \le 5\times 10^3$。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=10010;</span><br><span class="line">const double INF=-2e9;</span><br><span class="line">const double EPS = 1e-10;</span><br><span class="line">int T,n;</span><br><span class="line">double a[N],b[N],c[N];</span><br><span class="line"></span><br><span class="line">inline double f(double x) &#123;</span><br><span class="line">	double ret=INF;</span><br><span class="line">	for(int i=0; i&lt;n; i++)</span><br><span class="line">		ret=max(ret,a[i]*x*x+b[i]*x+c[i]);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;//内置的计算F(x)函数的值的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void slove() &#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(int i=0; i&lt;n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i]; //读入</span><br><span class="line">	double l=0,r=1000;</span><br><span class="line">	while(r-l &gt; EPS) &#123;</span><br><span class="line">		double mid1=(l+l+r)/3,mid2=(l+r+r)/3;</span><br><span class="line">		double v1=f(l),v2=f(mid1),v3=f(mid2),v4=f(r);</span><br><span class="line">		</span><br><span class="line">		if(v1&lt;v2)r=mid1;</span><br><span class="line">		else if(v4&lt;v3)l=mid2;</span><br><span class="line">		else if(v1&gt;v2&amp;&amp;v2&lt;v3)r=mid2;</span><br><span class="line">		else if(v4&gt;v3&amp;&amp;v3&lt;v2)l=mid1;</span><br><span class="line">		else l=mid1,r=mid2;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%.4lf\n&quot;,f(l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	while(T--) &#123;</span><br><span class="line">		slove();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trie模板"><a href="#Trie模板" class="headerlink" title="Trie模板"></a>Trie模板</h1><p>核心部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int cnt[N], Trie[N][65], nodeCnt;</span><br><span class="line"></span><br><span class="line">int getNum(char ch) &#123;</span><br><span class="line">	if(ch &gt;=&#x27;A&#x27; &amp;&amp; ch&lt;=&#x27;Z&#x27;) return (ch-&#x27;A&#x27;);</span><br><span class="line">	else if(ch&gt;=&#x27;a&#x27; &amp;&amp; ch&lt;=&#x27;z&#x27;) return (ch-&#x27;a&#x27;+26);</span><br><span class="line">	else return (ch-&#x27;0&#x27;+52);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(const string&amp; s) &#123;</span><br><span class="line">	int d = 0;</span><br><span class="line">	for(char ch : s) &#123;</span><br><span class="line">		int idx = getNum(ch);</span><br><span class="line">		if(Trie[d][idx] == 0) Trie[d][idx] = ++nodeCnt;</span><br><span class="line">		d = Trie[d][idx];</span><br><span class="line">		++cnt[d];//前缀</span><br><span class="line">	&#125;</span><br><span class="line">	//++cnt[d] //完整</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getCnt(const string&amp; s) &#123;</span><br><span class="line">	int d = 0;</span><br><span class="line">	for(char ch : s) &#123;</span><br><span class="line">		int idx = getNum(ch);</span><br><span class="line">		if(Trie[d][idx] == 0) return 0;</span><br><span class="line">		d = Trie[d][idx];</span><br><span class="line">	&#125;</span><br><span class="line">	return cnt[d];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展-：-AC自动机"><a href="#扩展-：-AC自动机" class="headerlink" title="扩展 ： AC自动机"></a>扩展 ： AC自动机</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+10;</span><br><span class="line">const int M = 26;</span><br><span class="line">//flag: 记录以当前字符为结尾的字符串编号,ID,排序前的编号</span><br><span class="line">//vis:	记录了字符串编号为 u 的字符串在查询过程中出现的次数</span><br><span class="line">//cnt:	记录了以节点 u 结尾的字符串的数量</span><br><span class="line">//fail: 在 AC 自动机中与当前节点匹配失败时应跳转到的节点</span><br><span class="line">int trie[N][M],flag[N],fail[N],ID[N],in[N],cnt[N],vis[N],node;</span><br><span class="line">queue&lt;int&gt;q1;</span><br><span class="line">string strs[N];</span><br><span class="line"></span><br><span class="line">void insert(const string&amp; s,int id) &#123;</span><br><span class="line">	int u = 1;//根从1开始 </span><br><span class="line">	for(char ch:s) &#123;</span><br><span class="line">		int v = ch-&#x27;a&#x27;;//只有小写</span><br><span class="line">		if(!trie[u][v]) trie[u][v] = ++node;</span><br><span class="line">		u = trie[u][v];</span><br><span class="line">	&#125;</span><br><span class="line">	if(!flag[u]) flag[u] = id;</span><br><span class="line">	ID[id] = flag[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bfs() &#123;</span><br><span class="line">	for (int i=0;i&lt;26;++i) trie[0][i] = 1;</span><br><span class="line">	q1.push(1);</span><br><span class="line"></span><br><span class="line">	while (!q1.empty()) &#123;</span><br><span class="line">		int u = q1.front();</span><br><span class="line">		q1.pop();</span><br><span class="line"></span><br><span class="line">		for (int i=0;i&lt;26;++i) &#123;//遍历所有孩子 </span><br><span class="line">			int v = trie[u][i];//孩子 </span><br><span class="line">			if (v) &#123;//存在 </span><br><span class="line">				fail[v] = trie[fail[u]][i]; // 设置失败指针</span><br><span class="line">				++in[fail[v]];</span><br><span class="line">				q1.push(v); // 将子节点压入队列</span><br><span class="line">			&#125; else &#123;//不存在 </span><br><span class="line">				trie[u][i] = trie[fail[u]][i]; // 设置失配转移</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void topu()&#123;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=node;i++)&#123;</span><br><span class="line">		if(in[i] == 0) q1.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(!q1.empty())&#123;</span><br><span class="line">		int u = q1.front();q1.pop();</span><br><span class="line">		</span><br><span class="line">		vis[flag[u]] = cnt[u];//原数组下边对应值 </span><br><span class="line">		</span><br><span class="line">		int v = fail[u]; </span><br><span class="line">		--in[v];</span><br><span class="line">		cnt[v] += cnt[u];//次数累加 </span><br><span class="line">		</span><br><span class="line">		if(in[v] == 0) q1.push(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void query(const string&amp; s) &#123;</span><br><span class="line">    int u=1;//根从1开始 </span><br><span class="line">    for(char ch:s)&#123;</span><br><span class="line">    	int idx = ch-&#x27;a&#x27;;</span><br><span class="line">		u = trie[u][idx];</span><br><span class="line">		++cnt[u];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	node = 1;</span><br><span class="line">	for(int i=1; i&lt;=n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; strs[i];</span><br><span class="line">		insert(strs[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bfs();</span><br><span class="line">	</span><br><span class="line">	string s2;</span><br><span class="line">	cin &gt;&gt; s2;</span><br><span class="line">	query(s2);</span><br><span class="line">	topu();</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">		cout &lt;&lt; vis[ID[i]] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="树状数组模板"><a href="#树状数组模板" class="headerlink" title="树状数组模板"></a>树状数组模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">适用于单点修改和查询、区间和查询等简单操作，代码量小，操作高效，但不支持区间修改</span><br></pre></td></tr></table></figure>

<p>前缀和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 5e5+10;</span><br><span class="line">int tree[N],n,m;</span><br><span class="line"></span><br><span class="line">int lowbit(int x)&#123;//找最低位 </span><br><span class="line">	return x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int x,int k)&#123;//单点修改 </span><br><span class="line">	while(x&lt;=n)&#123;</span><br><span class="line">		tree[x]+=k;</span><br><span class="line">		x+=lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getSum(int x)&#123;//求单点的前缀和 </span><br><span class="line">	int ans =0;</span><br><span class="line">	while(x!=0)&#123;</span><br><span class="line">		ans+=tree[x];</span><br><span class="line">		x-=lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rangeAdd(int l, int r, int k) &#123;//差分</span><br><span class="line">    add(l, k);</span><br><span class="line">    add(r + 1, -k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		add(i,x);//第i个数加上x </span><br><span class="line">		//rangeAdd(i, i, x);// 差分</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		int op,x,y;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		if(op == 2) cout &lt;&lt; (getSum(y) - getSum(x-1)) &lt;&lt;endl;</span><br><span class="line">		else add(x,y);//第x个数加上y </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单源最短路径模板"><a href="#单源最短路径模板" class="headerlink" title="单源最短路径模板"></a>单源最短路径模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">using PILL = pair&lt;ll,ll&gt;;</span><br><span class="line"></span><br><span class="line">const int N = 1e6+5;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">ll n,m,dist[N],st;</span><br><span class="line">vector&lt;PILL&gt;grid[N];</span><br><span class="line">bool visited[N] = &#123;false&#125;;</span><br><span class="line"></span><br><span class="line">class MYCMP&#123;</span><br><span class="line">	public:</span><br><span class="line">		bool operator()(const PILL&amp; x,const PILL&amp; y)&#123;</span><br><span class="line">			return x.second &gt; y.second;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void minway()&#123;</span><br><span class="line">	priority_queue&lt;PILL,vector&lt;PILL&gt;,MYCMP&gt;pq;</span><br><span class="line">	pq.push(&#123;st,0&#125;);</span><br><span class="line">	dist[st] = 0;</span><br><span class="line">	</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		PILL u = pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		if(visited[u.first]) continue;</span><br><span class="line">			visited[u.first] = true;</span><br><span class="line">			</span><br><span class="line">		for(PILL v:grid[u.first])&#123;	</span><br><span class="line">			if(dist[v.first] &gt; dist[u.first]+v.second)&#123;</span><br><span class="line">				dist[v.first] = dist[u.first]+v.second;</span><br><span class="line">				pq.push(&#123;v.first,dist[v.first]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; st;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		ll x,y,z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		grid[x].push_back(&#123;y,z&#125;);</span><br><span class="line">		dist[i] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">	minway();</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">		if(dist[i] == INF) cout &lt;&lt; 2147483647 &lt;&lt; &quot; &quot;;//看题目要求</span><br><span class="line">		else cout &lt;&lt; dist[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小生成树模板"><a href="#最小生成树模板" class="headerlink" title="最小生成树模板"></a>最小生成树模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">struct way&#123;</span><br><span class="line">	int a,b,d;</span><br><span class="line">&#125;ways[N];</span><br><span class="line"></span><br><span class="line">bool mycmp(way x,way y)&#123;</span><br><span class="line">	return x.d  &lt; y.d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fa[N];</span><br><span class="line">int cnt;//集合数量 </span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!=fa[x])&#123;</span><br><span class="line">		fa[x] = find(fa[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cnt = n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) fa[i] = i;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		cin &gt;&gt; ways[i].a &gt;&gt; ways[i].b &gt;&gt; ways[i].d;</span><br><span class="line">	&#125; </span><br><span class="line">	sort(ways+1,ways+1+m,mycmp);</span><br><span class="line">	int ans =0;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		int x = ways[i].a,y=ways[i].b;</span><br><span class="line">		int px = find(x),py=find(y);</span><br><span class="line">		if(px!=py)&#123;</span><br><span class="line">			fa[py] = px;</span><br><span class="line">			--cnt;</span><br><span class="line">			ans += ways[i].d;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(cnt &gt; 1) cout &lt;&lt; &quot;orz&quot; &lt;&lt; endl;</span><br><span class="line">	else cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ST表模板"><a href="#ST表模板" class="headerlink" title="ST表模板"></a>ST表模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用倍增思想来缩短时间，快速求区间的状态,本题是求最大值</span><br><span class="line">范围</span><br><span class="line">[1,i+2^j-1]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+10;</span><br><span class="line"></span><br><span class="line">int n,m,x,y,lg[N],st[N][20];//倍增思想，本题中记录 i到i+2^j次方-1范围中的最大值 </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	ios_base::sync_with_stdio(false);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	lg[1]=0;//i小于等于2的lg[i]次方 </span><br><span class="line">	for(int i=2;i&lt;=n;i++) lg[i] = lg[i&gt;&gt;1]+1;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin &gt;&gt; st[i][0];</span><br><span class="line">	</span><br><span class="line">	for(int j=1;j&lt;=lg[n];j++)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123;//边界范围：[1,n-2^j+1] </span><br><span class="line">			st[i][j] = max(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		int l = lg[y-x+1];</span><br><span class="line">		cout &lt;&lt; max(st[x][l],st[y-(1&lt;&lt;l)+1][l]) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPFA模板"><a href="#SPFA模板" class="headerlink" title="SPFA模板"></a>SPFA模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断负环用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using PILL = pair&lt;int,int&gt;;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">const int N = 2e4;</span><br><span class="line">vector&lt;PILL&gt;grid[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool spfa(int start,int n)&#123;</span><br><span class="line">	queue&lt;int&gt;q1;</span><br><span class="line">	vector&lt;bool&gt;visited(n+1,false);</span><br><span class="line">	vector&lt;int&gt;dist(n+1,INF),cnt(n+1,0);//cnt:入队次数 </span><br><span class="line">	</span><br><span class="line">	q1.push(start);</span><br><span class="line">	dist[start] = 0;</span><br><span class="line">	++cnt[start];</span><br><span class="line">	visited[start] = true;</span><br><span class="line">	</span><br><span class="line">	while(!q1.empty())&#123;</span><br><span class="line">		int u = q1.front();</span><br><span class="line">		q1.pop();</span><br><span class="line">		visited[u] = false;</span><br><span class="line">		for(auto v:grid[u])&#123;</span><br><span class="line">			if(dist[u]+v.second &lt; dist[v.first])&#123;</span><br><span class="line">				dist[v.first] = dist[u]+v.second;</span><br><span class="line">				</span><br><span class="line">				if(!visited[v.first])&#123;</span><br><span class="line">					q1.push(v.first);</span><br><span class="line">					visited[v.first] = true;</span><br><span class="line">					if(++cnt[v.first] &gt;= n) return true;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		int u,v,t;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; t;</span><br><span class="line">		if(t &gt;= 0) grid[v].push_back(&#123;u,t&#125;);//看题目具体要求 </span><br><span class="line">		grid[u].push_back(&#123;v,t&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(spfa(1,n)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">	else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++) </span><br><span class="line">		grid[i].clear();//结束后清零 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="KMP模板"><a href="#KMP模板" class="headerlink" title="KMP模板"></a>KMP模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N =  1e6+5;</span><br><span class="line">int Next[N];</span><br><span class="line"></span><br><span class="line">void initNext(const string&amp; s)&#123;</span><br><span class="line">	int len = s.size(),j=0;</span><br><span class="line">	for(int i=1;i&lt;len;i++)&#123;</span><br><span class="line">		while(j&gt;0 &amp;&amp; s[i]!=s[j])&#123;</span><br><span class="line">			j=Next[j-1];</span><br><span class="line">		&#125;</span><br><span class="line">		if(s[i]==s[j]) j++;</span><br><span class="line">		Next[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void KMP(const string&amp; s1,const string&amp; s2)&#123;</span><br><span class="line">	int len1 = s1.size();</span><br><span class="line">	int len2 = s2.size();</span><br><span class="line">	int j=0;</span><br><span class="line">	for(int i=0;i&lt;len1;i++)&#123;</span><br><span class="line">		while(j&gt;0&amp;&amp;s1[i]!=s2[j])&#123;</span><br><span class="line">			j=Next[j-1];</span><br><span class="line">		&#125;</span><br><span class="line">		if(s1[i] == s2[j]) j++;</span><br><span class="line">		if(j==len2)&#123;</span><br><span class="line">			cout &lt;&lt; i-j+1+1 &lt;&lt; endl;//下标从1开始 </span><br><span class="line">			j = Next[j-1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;len2;i++) cout &lt;&lt; Next[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">	initNext(s2);</span><br><span class="line">	KMP(s1,s2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="线段树模板"><a href="#线段树模板" class="headerlink" title="线段树模板"></a>线段树模板</h1><p>区间和版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 1e6+1;</span><br><span class="line"></span><br><span class="line">ll tree[N&lt;&lt;1],lazy[N&lt;&lt;1],nums[N];</span><br><span class="line"></span><br><span class="line">ll lc(ll x) &#123;//左孩子(x*2) </span><br><span class="line">	return x&lt;&lt;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll rc(ll x) &#123;//右孩子(x*2+1) </span><br><span class="line">	return x&lt;&lt;1|1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(ll p ,ll l,ll r,ll k)&#123;//每次更新时的操作 </span><br><span class="line">	tree[p] += k*(r-l+1);//k*区间里的元素个数</span><br><span class="line">	//tree[p] += k;//最大值 </span><br><span class="line">	lazy[p] += k; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push_up(ll p)&#123;//区间状态等于左孩子的状态（op）右孩子的状态 </span><br><span class="line">	tree[p] = tree[lc(p)] + tree[rc(p)];</span><br><span class="line">	//tree[p] = max(tree[lc(p)] , tree[rc(p)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(ll p,ll l,ll r)&#123;//后序遍历建树 </span><br><span class="line">	lazy[p] = 0;</span><br><span class="line">	</span><br><span class="line">	if(l == r)&#123;</span><br><span class="line">		tree[p] = nums[l];</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ll mid = (l+r) &gt;&gt; 1;</span><br><span class="line">	build(lc(p),l,mid);</span><br><span class="line">	build(rc(p),mid+1,r);</span><br><span class="line">	push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push_down(ll p,ll l,ll r)&#123;//后序遍历传递lazy </span><br><span class="line">	ll mid = (l+r) &gt;&gt; 1;</span><br><span class="line">	fun(lc(p),l,mid,lazy[p]);</span><br><span class="line">	fun(rc(p),mid+1,r,lazy[p]);</span><br><span class="line">	lazy[p] = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll find(ll x,ll y,ll l,ll r,ll p)&#123;//后序查询，先序更新 </span><br><span class="line">	ll res = 0;</span><br><span class="line">	if(x&lt;=l&amp;&amp;r&lt;=y) return tree[p];</span><br><span class="line">	</span><br><span class="line">	push_down(p,l,r);//查询时先序遍历 更新lazy</span><br><span class="line">	ll mid = (l+r) &gt;&gt;1;</span><br><span class="line">	</span><br><span class="line">	//根据实际情况选择 </span><br><span class="line">	if(x&lt;=mid) res += find(x,y,l,mid,lc(p));//max(res,find(x,y,l,mid,lc(p)));</span><br><span class="line">	if(y &gt; mid) res += find(x,y,mid+1,r,rc(p));</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(ll x,ll y, ll l,ll r,ll p, ll k)&#123;//更新 </span><br><span class="line">	if(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">		fun(p,l,r,k);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	push_down(p,l,r);//先序更新</span><br><span class="line">	ll mid = (l+r) &gt;&gt; 1;</span><br><span class="line">	if(x &lt;= mid) update(x,y,l,mid,lc(p),k);</span><br><span class="line">	if(y &gt; mid) update(x,y,mid+1,r,rc(p),k);</span><br><span class="line">	push_up(p);//维护更新后的树 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	ios_base::sync_with_stdio(false);</span><br><span class="line">	cin.tie(nullptr);</span><br><span class="line">	ll n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin &gt;&gt; nums[i];</span><br><span class="line">	build(1,1,n);</span><br><span class="line">	</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		ll op,x,y,k;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		if(op == 1)&#123;//修改 </span><br><span class="line">			cin &gt;&gt; k;</span><br><span class="line">			update(x,y,1,n,1,k);</span><br><span class="line">		&#125;else&#123;//查询 </span><br><span class="line">			cout &lt;&lt; find(x,y,1,n,1) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//for(int i =1;i&lt;=(n&lt;&lt;1);i++) cout &lt;&lt; tree[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h6 id="多状态维护"><a href="#多状态维护" class="headerlink" title="多状态维护"></a>多状态维护</h6><p>（既有加法，又有乘法-》双lazy维护）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N =1e6+1;</span><br><span class="line"></span><br><span class="line">ll n,m,mod,tree[N&lt;&lt;1],add_lazy[N&lt;&lt;1],mul_lazy[N&lt;&lt;1],nums[N];</span><br><span class="line"></span><br><span class="line">ll lc(int x) &#123;</span><br><span class="line">	return x&lt;&lt;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll rc(int x) &#123;</span><br><span class="line">	return x&lt;&lt;1|1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push_up(ll p) &#123;</span><br><span class="line">	tree[p] = (tree[lc(p)] + tree[rc(p)])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(ll p ,ll l, ll r) &#123;</span><br><span class="line">	add_lazy[p] = 0;</span><br><span class="line">	mul_lazy[p] = 1;</span><br><span class="line"></span><br><span class="line">	if(l==r) &#123;</span><br><span class="line">		tree[p] = nums[l];</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll mid = (l+r) &gt;&gt; 1;</span><br><span class="line">	build(lc(p),l,mid);</span><br><span class="line">	build(rc(p),mid+1,r);</span><br><span class="line">	push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_fun(ll p,ll l,ll r,ll k) &#123; //加法</span><br><span class="line">	tree[p] = (tree[p] + k*(r-l+1))%mod;</span><br><span class="line">	add_lazy[p] = (add_lazy[p]+k)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mul_fun(ll p,ll x,ll y,ll k) &#123; //乘法</span><br><span class="line">	tree[p] = (tree[p] * k)%mod;</span><br><span class="line">	add_lazy[p] = (add_lazy[p] * k) % mod;</span><br><span class="line">	mul_lazy[p] = (mul_lazy[p] * k)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push_down(ll p, ll l, ll r) &#123; //传递lazy</span><br><span class="line">	if(mul_lazy[p]!=1) &#123;</span><br><span class="line">		ll mid = (l+r) &gt;&gt; 1;</span><br><span class="line">		mul_fun(lc(p),l,mid,mul_lazy[p]);</span><br><span class="line">		mul_fun(rc(p),mid+1,r,mul_lazy[p]);</span><br><span class="line">		mul_lazy[p] = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(add_lazy[p]!=0) &#123;</span><br><span class="line">		ll mid = (l+r) &gt;&gt; 1;</span><br><span class="line">		add_fun(lc(p),l,mid,add_lazy[p]);</span><br><span class="line">		add_fun(rc(p),mid+1,r,add_lazy[p]);</span><br><span class="line">		add_lazy[p] = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll find(ll x,ll y,ll l, ll r,ll p) &#123;</span><br><span class="line">	ll res=0;</span><br><span class="line">	if(x&lt;=l&amp;&amp;r&lt;=y) return tree[p];</span><br><span class="line"></span><br><span class="line">	push_down(p,l,r);//更新p</span><br><span class="line">	ll mid = (l+r) &gt;&gt; 1;</span><br><span class="line">	if(x&lt;=mid) res = (res+find(x,y,l,mid,lc(p)))%mod;</span><br><span class="line">	if(y&gt;mid) res = (res+find(x,y,mid+1,r,rc(p)))%mod;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(ll x,ll y,ll l,ll r,ll p,ll k,bool flag) &#123; //true:加法,flase：乘法</span><br><span class="line">	if(x&lt;=l&amp;&amp;r&lt;=y) &#123;</span><br><span class="line">		flag ? add_fun(p,l,r,k):mul_fun(p,l,r,k);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	push_down(p,l,r);</span><br><span class="line">	ll mid = (l+r) &gt;&gt; 1;</span><br><span class="line">	if(x&lt;=mid) update(x,y,l,mid,lc(p),k,flag);</span><br><span class="line">	if(y&gt;mid) update(x,y,mid+1,r,rc(p),k,flag);</span><br><span class="line">	push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	ios_base::sync_with_stdio(false);</span><br><span class="line">	cin.tie(nullptr);</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">	for(int i=1; i&lt;=n; i++) cin &gt;&gt; nums[i];</span><br><span class="line">	build(1,1,n);</span><br><span class="line"></span><br><span class="line">	while(m--) &#123;</span><br><span class="line">		ll op,x,y,k;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		if(op == 3) &#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			cout &lt;&lt; find(x,y,1,n,1) &lt;&lt; endl;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			if(op == 2) &#123;</span><br><span class="line">				update(x,y,1,n,1,k,true);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				update(x,y,1,n,1,k,false);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Tarjan相关"><a href="#Tarjan相关" class="headerlink" title="Tarjan相关"></a>Tarjan相关</h1><h2 id="1、缩点"><a href="#1、缩点" class="headerlink" title="1、缩点"></a>1、缩点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求一张有向图的最大权值，边点可重复利用，但不可重复计数</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+1;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;grid[N],scGrid[N],RScGrid[N];//测试图，强连通图</span><br><span class="line">int weight[N],degree[N],tp[N],tp_cnt,n,m;//权重，度，拓扑排序数组</span><br><span class="line"></span><br><span class="line">//dfn:记录每个节点的搜索序号</span><br><span class="line">//low:记录每个节点或其子树中能够追溯到的最早的栈中节点的次序号</span><br><span class="line">//scc:记录每个节点所属的强连通分量的编号</span><br><span class="line">//sc_dist:记录每个强连通分量中节点的权值总和</span><br><span class="line">//times:记录当前的搜索序号</span><br><span class="line">//scc_idx:记录当前的强连通分量的编号</span><br><span class="line">int dfn[N],low[N],scc[N],scc_wt[N],times,scc_idx;</span><br><span class="line">int st[N],top;//栈</span><br><span class="line">bool visited[N] = &#123;false&#125;;</span><br><span class="line"></span><br><span class="line">int dp[N];//动态规划求最大权值</span><br><span class="line"></span><br><span class="line">void tarjan(int u) &#123;//标记强连通分量 </span><br><span class="line"></span><br><span class="line">	low[u] = dfn[u] = ++times;</span><br><span class="line">	st[++top] = u;</span><br><span class="line">	visited[u] = true;</span><br><span class="line"></span><br><span class="line">	for(int v:grid[u]) &#123;</span><br><span class="line">		if(dfn[v] == 0) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[u] = min(low[u],low[v]);</span><br><span class="line">		&#125; else if(visited[v]) &#123;</span><br><span class="line">			low[u] = min(low[u],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(low[u]==dfn[u]) &#123;</span><br><span class="line">		++scc_idx;</span><br><span class="line">		while(true) &#123;</span><br><span class="line">			scc[st[top]] = scc_idx;</span><br><span class="line">			visited[st[top]] = false;</span><br><span class="line">			scc_wt[scc_idx] += weight[st[top]];</span><br><span class="line">			--top;</span><br><span class="line">			if(u==st[top+1]) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tpsort() &#123;//拓扑排序 </span><br><span class="line"></span><br><span class="line">	queue&lt;int&gt;q1;</span><br><span class="line">	for(int i=1; i&lt;=scc_idx; i++) &#123;</span><br><span class="line">		if(degree[i] == 0)</span><br><span class="line">			q1.push(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while(!q1.empty()) &#123;</span><br><span class="line">		int u = q1.front();</span><br><span class="line">		q1.pop();</span><br><span class="line">		tp[++tp_cnt] = u;</span><br><span class="line">		for(int v:scGrid[u]) &#123;</span><br><span class="line">			if(--degree[v]==0)</span><br><span class="line">				q1.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findMaxWeight() &#123; //动态规划</span><br><span class="line">	</span><br><span class="line">	for(int i = 1; i &lt;= scc_idx; i++) &#123; </span><br><span class="line">		int u = tp[i];</span><br><span class="line">		dp[u] = scc_wt[u];</span><br><span class="line">		for(int v:RScGrid[u]) &#123;</span><br><span class="line">			dp[u] = max(dp[u], dp[v] + scc_wt[u]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int ans = 0;	</span><br><span class="line">	for(int i = 1; i &lt;= scc_idx; i++) ans = max(ans, dp[i]);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void buildScc() &#123; //构造强连通图</span><br><span class="line">	for(int i=1; i&lt;=n; i++)</span><br><span class="line">		if(!dfn[i]) tarjan(i);</span><br><span class="line"></span><br><span class="line">	for(int u=1; u&lt;=n; u++) &#123; //强连通图</span><br><span class="line">		for(int v:grid[u]) &#123;</span><br><span class="line">			if(scc[u]!=scc[v]) &#123;</span><br><span class="line">				int x = scc[u],y=scc[v];</span><br><span class="line">				scGrid[x].push_back(y);//正连接表，用来拓扑排序 </span><br><span class="line">				RScGrid[y].push_back(x);//逆邻接表，用来动态规划求最大权值 </span><br><span class="line">				++degree[y];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read() &#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i=1; i&lt;=n; i++) cin &gt;&gt; weight[i];</span><br><span class="line">	for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">		int x,y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		grid[x].push_back(y);//有向图</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	read();//读数据</span><br><span class="line">	buildScc();//构建强连通图</span><br><span class="line">	tpsort();//拓扑排序</span><br><span class="line">	cout &lt;&lt; findMaxWeight() &lt;&lt;endl;//动态规划求最大值</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>为什么用逆邻接表？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逆邻接表记录了每个强连通分量的前驱节点，使得我们可以在动态规划的过程中方便地找到所有能到达当前节点的强连通分量。这样，在更新当前节点的最大权值时，可以同时考虑所有能到达该节点的强连通分量的权值，从而得到正确的最大权值。</span><br></pre></td></tr></table></figure>

<h2 id="2、割点"><a href="#2、割点" class="headerlink" title="2、割点"></a>2、割点</h2><p>什么是割点？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移除后图变成两个了</span><br></pre></td></tr></table></figure>

<p>怎么判断割点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一：其为根，有至少两个子树，那就是割点</span><br><span class="line"></span><br><span class="line">二：其不为根，但是他的在栈中的low值大于等于他父亲的访问顺序dfn</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+1;</span><br><span class="line">vector&lt;int&gt;grid[N];</span><br><span class="line">int dfn[N],low[N],times;</span><br><span class="line">//dfn:记录每个节点的搜索序号</span><br><span class="line">//low:某点可通过回溯到达的最早的点的时间戳</span><br><span class="line">bool isCut[N]=&#123;false&#125;;</span><br><span class="line"> </span><br><span class="line">void tarjan(int u,int fa)&#123;//求割点 </span><br><span class="line">	dfn[u] = low[u] = ++times;</span><br><span class="line">	int child = 0;</span><br><span class="line">	for(int v:grid[u])&#123;</span><br><span class="line">		if(!dfn[v])&#123;</span><br><span class="line">			tarjan(v,u);</span><br><span class="line">			low[u] = min(low[u],low[v]);</span><br><span class="line">			//若u不为根但是low[v] ≥dfn[u]则其为割点。</span><br><span class="line">			if(low[v]&gt;=dfn[u] &amp;&amp; u!=fa) isCut[u] = true;</span><br><span class="line">			if(u==fa) ++child;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			low[u] = min(low[u],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(child&gt;=2&amp;&amp;u==fa) isCut[u] = true;//若其为根，有至少两个子树，则其为割点 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		int x,y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		grid[x].push_back(y);</span><br><span class="line">		grid[y].push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(!dfn[i])</span><br><span class="line">			tarjan(i,i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int ans=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(isCut[i])</span><br><span class="line">			++ans;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(isCut[i])</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、桥-未试过"><a href="#3、桥-未试过" class="headerlink" title="3、桥(未试过)"></a>3、桥(未试过)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被删除后变成两个图的 边</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using PILL = pair&lt;int,int&gt;;</span><br><span class="line">const int N = 1e6 + 1;</span><br><span class="line">vector&lt;int&gt; grid[N];</span><br><span class="line">int dfn[N], low[N], times;</span><br><span class="line">map&lt;PILL,int&gt;cnt;</span><br><span class="line"></span><br><span class="line">void tarjan(int u, int fa) &#123;</span><br><span class="line">    dfn[u] = low[u] = ++times;</span><br><span class="line"></span><br><span class="line">    for (int v : grid[u]) &#123;</span><br><span class="line">        if (!dfn[v]) &#123; // v 未被访问，是树边</span><br><span class="line">            tarjan(v, u);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            // 如果 v 的 low 值大于 u 的 dfn 值，说明 (u, v) 是桥</span><br><span class="line">            if (low[v] &gt; dfn[u]&amp;&amp;cnt[&#123;u,v&#125;] == 1) </span><br><span class="line">                cout &lt;&lt; &quot;Bridge: &quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">        &#125; else if (v != fa) &#123; // v 已经被访问过，不是父节点，是后向边</span><br><span class="line">            low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ++cnt[&#123;x,y&#125;];</span><br><span class="line">        ++cnt[&#123;y,x&#125;];</span><br><span class="line">        grid[x].push_back(y);</span><br><span class="line">        grid[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (!dfn[i])</span><br><span class="line">            tarjan(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">4 4</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h1 id="双指针模板（求和-求乘积）"><a href="#双指针模板（求和-求乘积）" class="headerlink" title="双指针模板（求和&#x2F;求乘积）"></a>双指针模板（求和&#x2F;求乘积）</h1><h2 id="蓝桥杯-2023-国-B-双子数"><a href="#蓝桥杯-2023-国-B-双子数" class="headerlink" title="[蓝桥杯 2023 国 B]  双子数"></a>[蓝桥杯 2023 国 B]  双子数</h2><p>若一个正整数 $x$ 可以被表示为 $p^2 * q^2$，其中 $p$、$q$ 为质数且 $p ！&#x3D;q $，则 $x$ 是<br>一个 “双子数”。请计算区间 $[2333, 23333333333333]$ 内有多少个 “双子数”？</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 1e7; </span><br><span class="line">vector&lt;bool&gt;isPrime(N,true);</span><br><span class="line">vector&lt;ll&gt;Prime;</span><br><span class="line"></span><br><span class="line">const ll st = 2333;</span><br><span class="line">const ll ed = 23333333333333;</span><br><span class="line"></span><br><span class="line">void init()&#123;//快速筛素数 </span><br><span class="line">	</span><br><span class="line">	for(ll i = 2;i&lt;=N;i++)&#123;</span><br><span class="line">		if(isPrime[i])&#123;</span><br><span class="line">			Prime.push_back(i);</span><br><span class="line">			for(ll j=i*i;j&lt;=N;j+=i)</span><br><span class="line">				isPrime[j] = false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	</span><br><span class="line">	int l =0,r=Prime.size()-1;</span><br><span class="line">	ll ans = 0;</span><br><span class="line">	while(l&lt;r)&#123;</span><br><span class="line">		int k = l+1;</span><br><span class="line">		while(Prime[l]*Prime[l]*Prime[k]*Prime[k] &lt; st) k++;//起点 </span><br><span class="line">		while(Prime[r]*Prime[r]*Prime[l]*Prime[l] &gt; ed) r--;//终点 </span><br><span class="line">		if(k&lt;r) ans += (r-k+1);</span><br><span class="line">		l++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;ans &lt;&lt;  endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="BFS遍历图"><a href="#BFS遍历图" class="headerlink" title="BFS遍历图"></a>BFS遍历图</h1><h2 id="蓝桥杯-2023-国-B-AB-路线"><a href="#蓝桥杯-2023-国-B-AB-路线" class="headerlink" title="[蓝桥杯 2023 国 B] AB 路线"></a>[蓝桥杯 2023 国 B] AB 路线</h2><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个由 $N \times M$ 个方格组成的迷宫，每个方格写有一个字母 <code>A</code> 或者 <code>B</code>。小蓝站在迷宫左上角的方格，目标是走到右下角的方格。他每一步可以移动到上下左右相邻的方格去。</p>
<p>由于特殊的原因，小蓝的路线必须先走 $K$ 个 <code>A</code> 格子、再走 $K$ 个 <code>B</code> 格子、再走 $K$ 个 <code>A</code> 格子、再走 $K$ 个 <code>B</code> 格子……如此反复交替。</p>
<p>请你计算小蓝最少需要走多少步，才能到达右下角方格？</p>
<p>注意路线经过的格子数不必一定是 $K$ 的倍数，即最后一段 <code>A</code> 或 <code>B</code> 的格子可以不满 $K$ 个。起点保证是 <code>A</code> 格子。</p>
<p>例如 $K &#x3D; 3$ 时，以下 $3$ 种路线是合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AA</span><br><span class="line">AAAB</span><br><span class="line">AAABBBAAABBB</span><br></pre></td></tr></table></figure>

<p>以下 $3$ 种路线不合法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ABABAB</span><br><span class="line">ABBBAAABBB</span><br><span class="line">AAABBBBBBAAA</span><br></pre></td></tr></table></figure>

<h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><ul>
<li>对于 $20%$ 的数据，$1 \le N, M \le 4$。</li>
<li>对于另 $20%$ 的数据，$K &#x3D; 1$。</li>
<li>对于 $100%$ 的数据，$1 \le N, M \le 1000$，$1 \le K \le 10$。</li>
</ul>
<p>第十四届蓝桥杯大赛软件赛决赛 C&#x2F;C++ 大学 B 组 G 题</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e3+3;</span><br><span class="line">const int K = 31;</span><br><span class="line">char grid[N][N];</span><br><span class="line">char tmp[N];</span><br><span class="line">bool visited[N][N][K];</span><br><span class="line">int dir[4][2] = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;</span><br><span class="line">int row,col,k;</span><br><span class="line"></span><br><span class="line">void read()&#123;</span><br><span class="line">	cin &gt;&gt; row &gt;&gt; col &gt;&gt; k;</span><br><span class="line">	for(int i=1;i&lt;=row;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=col;j++)&#123;</span><br><span class="line">			cin &gt;&gt; grid[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;k;i++)tmp[i]=&#x27;A&#x27;,tmp[i+k]=&#x27;B&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int bfs()&#123;</span><br><span class="line">	queue&lt;int&gt;q1;</span><br><span class="line">	q1.push(1);</span><br><span class="line">	q1.push(1);</span><br><span class="line">	q1.push(0);//a/b的个数 </span><br><span class="line">	q1.push(0);//层数</span><br><span class="line">	</span><br><span class="line">	while(!q1.empty())&#123;</span><br><span class="line">		int x=q1.front();q1.pop();</span><br><span class="line">		int y=q1.front();q1.pop();</span><br><span class="line">		int cnt = q1.front();q1.pop();</span><br><span class="line">		int d = q1.front();q1.pop();</span><br><span class="line">		if(x==row&amp;&amp;y==col) return d;</span><br><span class="line">		</span><br><span class="line">		for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">			int nx = x + dir[i][0],ny= y + dir[i][1],ncnt=(cnt+1)%(2*k);</span><br><span class="line">			if(nx &lt;1||ny&lt;1||nx&gt;row||ny&gt;col) continue;</span><br><span class="line">			if(visited[nx][ny][ncnt]) continue;</span><br><span class="line">			if(grid[nx][ny]!=tmp[ncnt]) continue;</span><br><span class="line">			visited[nx][ny][ncnt] = true;</span><br><span class="line">			q1.push(nx);</span><br><span class="line">			q1.push(ny);</span><br><span class="line">			q1.push(ncnt);</span><br><span class="line">			q1.push(d+1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	read();</span><br><span class="line">	cout &lt;&lt; bfs() &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DFS遍历"><a href="#DFS遍历" class="headerlink" title="DFS遍历"></a>DFS遍历</h1><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; path,vector&lt;bool&gt;&amp; used)&#123;</span><br><span class="line">	if(path.size() == nums.size())&#123;</span><br><span class="line">		for(int i:path)&#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">		if(!used[i])&#123;</span><br><span class="line">			path.push_back(nums[i]);</span><br><span class="line">			used[i] = true;</span><br><span class="line">			dfs(nums,path,used);</span><br><span class="line">			used[i] = false;</span><br><span class="line">			path.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt;nums(n);</span><br><span class="line">	vector&lt;int&gt;path;</span><br><span class="line">	vector&lt;bool&gt;used(n,false);</span><br><span class="line">	for(int i=0;i&lt;n;i++) nums[i] = i+1;</span><br><span class="line">	dfs(nums,path,used);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; path,int k,int startIdx)&#123;</span><br><span class="line">	if(path.size() == k)&#123;</span><br><span class="line">		for(int i:path)&#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=startIdx;i&lt;nums.size();i++)&#123;</span><br><span class="line">		path.push_back(nums[i]);</span><br><span class="line">		dfs(nums,path,k,i+1);</span><br><span class="line">		path.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt;nums(n);</span><br><span class="line">	vector&lt;int&gt;path;</span><br><span class="line">	for(int i=0;i&lt;n;i++) nums[i] = i+1;</span><br><span class="line">	dfs(nums,path,3,0);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><table>
<thead>
<tr>
<th>背包问题类型</th>
<th>物品选择次数</th>
<th>物品遍历顺序</th>
<th>背包容量遍历方向</th>
<th>次数遍历方向</th>
<th>外层循环遍历</th>
<th>内层循环遍历</th>
<th>循环顺序是否可交换</th>
</tr>
</thead>
<tbody><tr>
<td>0-1 背包</td>
<td>0 或 1</td>
<td>正序</td>
<td>逆序</td>
<td>-</td>
<td>物品</td>
<td>背包容量</td>
<td>是</td>
</tr>
<tr>
<td>完全背包</td>
<td>0 到 无限次</td>
<td>正序</td>
<td>正序</td>
<td>-</td>
<td>物品</td>
<td>背包容量</td>
<td>是</td>
</tr>
<tr>
<td>多重背包</td>
<td>0 到 k 次</td>
<td>正序</td>
<td>正序</td>
<td>逆序</td>
<td>物品</td>
<td>背包</td>
<td>否</td>
</tr>
</tbody></table>
<p>最大价值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][w]=max(dp[i−1][w],dp[i−1][w−wi]+vi)</span><br></pre></td></tr></table></figure>

<p>可能性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]+=dp[i−1][j]+dp[i−1][j−num[i]]</span><br></pre></td></tr></table></figure>

<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="蓝桥杯-2022-国-B-搬砖"><a href="#蓝桥杯-2022-国-B-搬砖" class="headerlink" title="[蓝桥杯 2022 国 B] 搬砖"></a>[蓝桥杯 2022 国 B] 搬砖</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>这天，小明在搬砖。</p>
<p>他一共有 $n$ 块砖，他发现第 $i$ 砖的重量为 $w_{i}$，价值为 $v_{i}$。他突然想从这些砖中选一些出来从下到上堆成一座塔，并且对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值。</p>
<p>他想知道这样堆成的塔的总价值（即塔中所有砖块的价值和）最大是多少。</p>
<h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入共 $n+1$ 行, 第一行为一个正整数 $n$, 表示砖块的数量。</p>
<p>后面 $n$ 行, 每行两个正整数 $w_{i}, v_{i}$ 分别表示每块砖的重量和价值。</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>一行，一个整数表示答案。</p>
<h5 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h5><h5 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4 4</span><br><span class="line">1 1</span><br><span class="line">5 2</span><br><span class="line">5 5</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>

<h5 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h5 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h5><p><strong>【样例说明】</strong></p>
<p>选择第 $1$、$2$、$4$ 块砖，从上到下按照 $2$、$1$、$4$ 的顺序堆成一座塔，总价值为 $4+1+5&#x3D;10$。</p>
<p><strong>【评测用例规模与约定】</strong></p>
<p>对于 $20 %$ 的数据，保证 $n \leq 10$;</p>
<p>对于 $100 %$ 的数据，保证 $n \leq 1000 ; w_{i} \leq 20 ; v_{i} \leq 20000$ 。</p>
<p>蓝桥杯 2022 国赛 B 组 J 题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6;</span><br><span class="line">int dp[N];//容量未i的背包最大价值为dp[i] </span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">	int w,v,size;</span><br><span class="line">&#125;item[N];</span><br><span class="line"></span><br><span class="line">bool mycmp(node x,node y)&#123;//按物品的重量＋价值排序</span><br><span class="line">	return x.size &lt;= y.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; item[i].w &gt;&gt; item[i].v;</span><br><span class="line">		item[i].size = item[i].w+ item[i].v;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(item+1,item+1+n,mycmp);</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;//正序遍历物品 </span><br><span class="line">		for(int j=item[i].size;j&gt;=item[i].w;j--)&#123;//逆序背包 </span><br><span class="line">			dp[j] = max(dp[j],dp[j-item[i].w]+item[i].v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	for(int i:dp) ans = max(ans,i);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="蓝桥杯-2022-国-B-2022"><a href="#蓝桥杯-2022-国-B-2022" class="headerlink" title="[蓝桥杯 2022 国 B]2022"></a>[蓝桥杯 2022 国 B]2022</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问取不同的十个正整数，有多少中和为2022的可能性</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 2023;// &gt;目标 </span><br><span class="line">const int CNT = 11; // &gt;拿取的个数</span><br><span class="line">ll dp[N][CNT]; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n=2022,nums=10;</span><br><span class="line">	dp[0][0] = 1;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;//  正序物品 </span><br><span class="line">		for(int k=nums;k&gt;=1;k--)&#123;//逆序拿取数量，最少得拿一个 </span><br><span class="line">			for(int j=i;j&lt;=n;j++)&#123;//正序背包 </span><br><span class="line">				dp[j][k] += dp[j-i][k-1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; dp[n][nums] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多数01背包"><a href="#多数01背包" class="headerlink" title="多数01背包"></a>多数01背包</h4><p>现在不止有一个背包了，有两个，要求两个背包的最大价值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int item[210];</span><br><span class="line">int f[1010][1010];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,wa,wb;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; wa &gt;&gt; wb;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin &gt;&gt; item[i];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=wa;j&gt;=0;j--)&#123;//因为有第二维度的可能性，所以他可以为0，第二个背包全装完就是了</span><br><span class="line">			for(int k=wb;k&gt;=0;k--)&#123;</span><br><span class="line">				if(j&gt;=item[i])&#123;</span><br><span class="line">					f[j][k] = max(f[j][k],f[j-item[i]][k]+item[i]);</span><br><span class="line">				&#125;</span><br><span class="line">				if(k&gt;=item[i])&#123;</span><br><span class="line">					f[j][k] = max(f[j][k],f[j][k-item[i]]+item[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; f[wa][wb] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="给定一个n，求有多少种素数之和等于他"><a href="#给定一个n，求有多少种素数之和等于他" class="headerlink" title="给定一个n，求有多少种素数之和等于他"></a>给定一个n，求有多少种素数之和等于他</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 1e4;</span><br><span class="line"></span><br><span class="line">ll dp[N];</span><br><span class="line">vector&lt;int&gt;Prime;</span><br><span class="line">vector&lt;bool&gt;isPrime(N,true);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i=2;i&lt;=N;i++)&#123;</span><br><span class="line">		if(isPrime[i])&#123;</span><br><span class="line">			Prime.push_back(i);</span><br><span class="line">			for(int j=i*i;j&lt;=N;j+=i)</span><br><span class="line">				isPrime[j] = false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	dp[0] = 1;</span><br><span class="line">	for(int i=0;i&lt;Prime.size();i++)&#123;//正序遍历物品 </span><br><span class="line">		for(int j=Prime[i];j&lt;=n;j++)&#123;//正序遍历背包 </span><br><span class="line">			dp[j] += dp[j-Prime[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>今有面值为 1、5、11 元的硬币各无限枚。</p>
<p>想要凑出 $n$ 元，问需要的最少硬币数量。</p>
<h5 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h5><p>仅一行，一个正整数 $n$。</p>
<h5 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h5><p>仅一行，一个正整数，表示需要的硬币个数。</p>
<h5 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h5><h5 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h5 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h5 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h5><h5 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>

<h5 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 1e6+10;</span><br><span class="line">ll dp[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	ll n ;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int nums[3] = &#123;1,5,11&#125;;</span><br><span class="line">	fill(dp,dp+N,n+1);//数组的开头(dp)到结尾(dp+N)填充 value(n+1)</span><br><span class="line">	dp[0] = 0;</span><br><span class="line">	for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">		for(int j=nums[i];j&lt;=n;j++)&#123;</span><br><span class="line">			dp[j] = min(dp[j],dp[j-nums[i]]+1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">const int N = 1e4+10;</span><br><span class="line">ll dp[N];//1~i中有dp[i]长度的递增子序列 </span><br><span class="line">ll nums[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	ll n ;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(int i=0;i&lt;n;i++) cin &gt;&gt; nums[i];</span><br><span class="line">	fill(dp,dp+N,1); </span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">			if(nums[j] &lt; nums[i])&#123;</span><br><span class="line">				dp[i] = max(dp[i],dp[j]+1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans =0;</span><br><span class="line">	for(int i=0;i&lt;n;i++) ans = max(ans,dp[i]);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子序列数量"><a href="#子序列数量" class="headerlink" title="子序列数量"></a>子序列数量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line"></span><br><span class="line">const int N = 1e4+5;</span><br><span class="line">ll dp[N][5];//s1的0~i中共有子序列0~j,dp[i][j]个 </span><br><span class="line"></span><br><span class="line">ll count (const string&amp; s1,const string&amp; s2)&#123;</span><br><span class="line">	int len1 = s1.size(),len2=s2.size();</span><br><span class="line">	dp[0][0];</span><br><span class="line">	for(int i=1;i&lt;=len1;i++)&#123;</span><br><span class="line">		dp[i][0] = 1;</span><br><span class="line">		for(int j=1;j&lt;=len2;j++)&#123;</span><br><span class="line">			if(s1[i-1] == s2[j-1])&#123;</span><br><span class="line">				dp[i][j] = dp[i-1][j-1]+dp[i-1][j];</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				dp[i][j] = dp[i-1][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return dp[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	string s1=&quot;&quot;,s2=&quot;2023&quot;;</span><br><span class="line">	for(int i=1;i&lt;=2023;i++) s1 += to_string(i);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; count(s1,s2) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e3+5;</span><br><span class="line"></span><br><span class="line">int dp [N][N];//s1(1~i)和s2(1~j)有长度为dp[i][j]的子序列,其中对于空字符串来说，没有和他匹配的</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s1,s2;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">			if(s1[i-1] == s2[j-1])&#123;</span><br><span class="line">				dp[i][j] = dp[i-1][j-1]+1;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				dp[i][j] = max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 11;</span><br><span class="line"></span><br><span class="line">int dp [N][N];//s1(1~i)变成s2(1~j)需要操作dp[i][j]次 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool canChange(const string&amp; s1,const string&amp; s2,int times)&#123;</span><br><span class="line">	int len1 = s1.size(),len2=s2.size();</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;=len1;i++) dp[i][0] = i;//初始化 </span><br><span class="line">	for(int j=0;j&lt;=len2;j++) dp[0][j] = j;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=len1;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=len2;j++)&#123;</span><br><span class="line">			if(s1[i-1] == s2[j-1])&#123;</span><br><span class="line">				dp[i][j] = dp[i-1][j-1];</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				dp[i][j] = min(dp[i-1][j]+1,min(dp[i-1][j-1]+1,dp[i][j-1]+1));//增删改中寻找操作次数最小的</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(dp[len1][len2] &lt;= times) return true;</span><br><span class="line">	else return false;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	int n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	vector&lt;string&gt;tmp;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		string s1;</span><br><span class="line">		cin &gt;&gt; s1;</span><br><span class="line">		tmp.push_back(s1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		int cnt = 0;</span><br><span class="line">		string s2;</span><br><span class="line">		int k;</span><br><span class="line">		cin &gt;&gt; s2 &gt;&gt; k;</span><br><span class="line">		for(string s:tmp)&#123;</span><br><span class="line">			if(canChange(s,s2,k)) ++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h4 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ural大学有N名职员，编号为1~N.</span><br><span class="line">他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上</span><br><span class="line">司。</span><br><span class="line">每个职员有一个快乐指数，用整数H:给出，其中1≤i≤N.</span><br><span class="line">现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参</span><br><span class="line">会。</span><br><span class="line">在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所</span><br><span class="line">有参会职员的快乐指数总和最大，求这个最大值。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 6e3+3;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;tree[N];</span><br><span class="line">int H[N];</span><br><span class="line">int dp[N][2];//左子树快乐值最大为dp[i][0],右子树为dp[i][1]</span><br><span class="line"></span><br><span class="line">void dfs(int u,int fa)&#123;</span><br><span class="line">	dp[u][1] = H[u];</span><br><span class="line">	</span><br><span class="line">	for(int v:tree[u])&#123;</span><br><span class="line">		if(v==fa) continue;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">		dp[u][1] += dp[v][0];</span><br><span class="line">		dp[u][0] += max(dp[v][0],dp[v][1]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin &gt;&gt; H[i];</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">		int x,y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		tree[x].push_back(y);</span><br><span class="line">		tree[y].push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dfs(1,0);</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; max(dp[1][0],dp[1][1]) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="期望值"><a href="#期望值" class="headerlink" title="期望值"></a>期望值</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在概率论和统计学中，是指随机变量在理论上可能出现的所有结果的加权平均值。期望值反映了随机变量在大量试验中的平均结果，是随机变量的一个重要特征</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">已有两个数组P，Q，元素数量都为len，P-Q的期望值为</span><br><span class="line"></span><br><span class="line">(sum(P)-sum(Q))/len</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" rel="tag"># 算法基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E7%AB%A0/" rel="prev" title="动态规划（ACwing）">
      <i class="fa fa-chevron-left"></i> 动态规划（ACwing）
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/09/13/2024-03-07-%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%88%E5%89%8D%E7%AF%87%EF%BC%89/" rel="next" title="网络是如何连接的（前篇）">
      网络是如何连接的（前篇） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8"><span class="nav-number">1.</span> <span class="nav-text">模板大全</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.</span> <span class="nav-text">二分模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E4%BA%8C%E5%88%86%EF%BC%88%E5%AF%BB%E6%89%BEx%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%95%B0%E5%88%97%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E-1%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">基础二分（寻找x在有序数列中的下标，不存在返回-1）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%88%86%EF%BC%88%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%80%BC%E7%9A%84%E5%B7%A6%E7%AB%AF%E7%82%B9%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">区间二分（寻找重复值的左端点）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%88%86%EF%BC%88%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%80%BC%E7%9A%84%E5%8F%B3%E7%AB%AF%E7%82%B9%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">区间二分（寻找重复值的右端点）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.</span> <span class="nav-text">前缀和模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.</span> <span class="nav-text">二维数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.</span> <span class="nav-text">差分模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-1"><span class="nav-number">4.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.</span> <span class="nav-text">二维矩阵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.</span> <span class="nav-text">快速幂模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AD%9B%E9%80%89%E7%B4%A0%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">6.</span> <span class="nav-text">筛选素数模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E6%A8%A1%E6%9D%BF"><span class="nav-number">7.</span> <span class="nav-text">字符串hash模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Floyd%E6%A8%A1%E6%9D%BF"><span class="nav-number">8.</span> <span class="nav-text">Floyd模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF"><span class="nav-number">9.</span> <span class="nav-text">拓扑排序模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.</span> <span class="nav-text">滑动窗口模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%A7%A3%E6%B3%95"><span class="nav-number">10.1.</span> <span class="nav-text">优先队列解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86"><span class="nav-number">11.</span> <span class="nav-text">裴蜀定理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="nav-number">11.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="nav-number">11.2.</span> <span class="nav-text">输入格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="nav-number">11.3.</span> <span class="nav-text">输出格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B-1"><span class="nav-number">11.4.</span> <span class="nav-text">样例 #1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1"><span class="nav-number">11.4.1.</span> <span class="nav-text">样例输入 #1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1"><span class="nav-number">11.4.2.</span> <span class="nav-text">样例输出 #1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA"><span class="nav-number">11.5.</span> <span class="nav-text">提示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF"><span class="nav-number">12.</span> <span class="nav-text">单调栈模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF"><span class="nav-number">13.</span> <span class="nav-text">并查集模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%8D%E5%A2%9E%E6%B3%95LCA%E6%A8%A1%E6%9D%BF"><span class="nav-number">14.</span> <span class="nav-text">倍增法LCA模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%B8%89%E5%88%86-%E5%87%BD%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">【模板】三分 | 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">15.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1"><span class="nav-number">15.2.</span> <span class="nav-text">输入格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1"><span class="nav-number">15.3.</span> <span class="nav-text">输出格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B-1-1"><span class="nav-number">15.4.</span> <span class="nav-text">样例 #1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1-1"><span class="nav-number">15.4.1.</span> <span class="nav-text">样例输入 #1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1-1"><span class="nav-number">15.4.2.</span> <span class="nav-text">样例输出 #1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-1"><span class="nav-number">15.5.</span> <span class="nav-text">提示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Trie%E6%A8%A1%E6%9D%BF"><span class="nav-number">16.</span> <span class="nav-text">Trie模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-%EF%BC%9A-AC%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">16.1.</span> <span class="nav-text">扩展 ： AC自动机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">17.</span> <span class="nav-text">树状数组模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">18.</span> <span class="nav-text">单源最短路径模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%A8%A1%E6%9D%BF"><span class="nav-number">19.</span> <span class="nav-text">最小生成树模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ST%E8%A1%A8%E6%A8%A1%E6%9D%BF"><span class="nav-number">20.</span> <span class="nav-text">ST表模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SPFA%E6%A8%A1%E6%9D%BF"><span class="nav-number">21.</span> <span class="nav-text">SPFA模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KMP%E6%A8%A1%E6%9D%BF"><span class="nav-number">22.</span> <span class="nav-text">KMP模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF"><span class="nav-number">23.</span> <span class="nav-text">线段树模板</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E7%8A%B6%E6%80%81%E7%BB%B4%E6%8A%A4"><span class="nav-number">23.0.0.0.0.1.</span> <span class="nav-text">多状态维护</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tarjan%E7%9B%B8%E5%85%B3"><span class="nav-number">24.</span> <span class="nav-text">Tarjan相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E7%BC%A9%E7%82%B9"><span class="nav-number">24.1.</span> <span class="nav-text">1、缩点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%89%B2%E7%82%B9"><span class="nav-number">24.2.</span> <span class="nav-text">2、割点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%A1%A5-%E6%9C%AA%E8%AF%95%E8%BF%87"><span class="nav-number">24.3.</span> <span class="nav-text">3、桥(未试过)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%EF%BC%88%E6%B1%82%E5%92%8C-%E6%B1%82%E4%B9%98%E7%A7%AF%EF%BC%89"><span class="nav-number">25.</span> <span class="nav-text">双指针模板（求和&#x2F;求乘积）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF-2023-%E5%9B%BD-B-%E5%8F%8C%E5%AD%90%E6%95%B0"><span class="nav-number">25.1.</span> <span class="nav-text">[蓝桥杯 2023 国 B]  双子数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">25.2.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS%E9%81%8D%E5%8E%86%E5%9B%BE"><span class="nav-number">26.</span> <span class="nav-text">BFS遍历图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF-2023-%E5%9B%BD-B-AB-%E8%B7%AF%E7%BA%BF"><span class="nav-number">26.1.</span> <span class="nav-text">[蓝桥杯 2023 国 B] AB 路线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="nav-number">26.2.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%84%E6%B5%8B%E7%94%A8%E4%BE%8B%E8%A7%84%E6%A8%A1%E4%B8%8E%E7%BA%A6%E5%AE%9A"><span class="nav-number">26.2.1.</span> <span class="nav-text">评测用例规模与约定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">26.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DFS%E9%81%8D%E5%8E%86"><span class="nav-number">27.</span> <span class="nav-text">DFS遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%88%97"><span class="nav-number">27.1.</span> <span class="nav-text">排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-number">27.2.</span> <span class="nav-text">组合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">28.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85"><span class="nav-number">28.1.</span> <span class="nav-text">背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85"><span class="nav-number">28.1.1.</span> <span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF-2022-%E5%9B%BD-B-%E6%90%AC%E7%A0%96"><span class="nav-number">28.1.1.1.</span> <span class="nav-text">[蓝桥杯 2022 国 B] 搬砖</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="nav-number">28.1.1.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2"><span class="nav-number">28.1.1.1.2.</span> <span class="nav-text">输入格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2"><span class="nav-number">28.1.1.1.3.</span> <span class="nav-text">输出格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B-1-2"><span class="nav-number">28.1.1.1.4.</span> <span class="nav-text">样例 #1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1-2"><span class="nav-number">28.1.1.1.5.</span> <span class="nav-text">样例输入 #1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1-2"><span class="nav-number">28.1.1.1.6.</span> <span class="nav-text">样例输出 #1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA-2"><span class="nav-number">28.1.1.1.7.</span> <span class="nav-text">提示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF-2022-%E5%9B%BD-B-2022"><span class="nav-number">28.1.1.2.</span> <span class="nav-text">[蓝桥杯 2022 国 B]2022</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%95%B001%E8%83%8C%E5%8C%85"><span class="nav-number">28.1.1.3.</span> <span class="nav-text">多数01背包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">28.1.2.</span> <span class="nav-text">完全背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AAn%EF%BC%8C%E6%B1%82%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E7%B4%A0%E6%95%B0%E4%B9%8B%E5%92%8C%E7%AD%89%E4%BA%8E%E4%BB%96"><span class="nav-number">28.1.2.1.</span> <span class="nav-text">给定一个n，求有多少种素数之和等于他</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98"><span class="nav-number">28.1.2.2.</span> <span class="nav-text">硬币问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="nav-number">28.1.2.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-3"><span class="nav-number">28.1.2.2.2.</span> <span class="nav-text">输入格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-3"><span class="nav-number">28.1.2.2.3.</span> <span class="nav-text">输出格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B-1-3"><span class="nav-number">28.1.2.2.4.</span> <span class="nav-text">样例 #1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1-3"><span class="nav-number">28.1.2.2.5.</span> <span class="nav-text">样例输入 #1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1-3"><span class="nav-number">28.1.2.2.6.</span> <span class="nav-text">样例输出 #1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B-2"><span class="nav-number">28.1.2.2.7.</span> <span class="nav-text">样例 #2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-2"><span class="nav-number">28.1.2.2.8.</span> <span class="nav-text">样例输入 #2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-2"><span class="nav-number">28.1.2.2.9.</span> <span class="nav-text">样例输出 #2</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">28.2.</span> <span class="nav-text">子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">28.2.1.</span> <span class="nav-text">最长递增子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E9%87%8F"><span class="nav-number">28.2.2.</span> <span class="nav-text">子序列数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">28.2.3.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">28.2.4.</span> <span class="nav-text">编辑距离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2dp"><span class="nav-number">28.3.</span> <span class="nav-text">树形dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A"><span class="nav-number">28.3.0.1.</span> <span class="nav-text">没有上司的舞会</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%9F%E6%9C%9B%E5%80%BC"><span class="nav-number">29.</span> <span class="nav-text">期望值</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AlexQFMM"
      src="/images/Avatar.jpg">
  <p class="site-author-name" itemprop="name">AlexQFMM</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://qexo-ten-roan.vercel.app/" title="控制中心 → https:&#x2F;&#x2F;qexo-ten-roan.vercel.app&#x2F;" rel="noopener" target="_blank">控制中心</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AlexQFMM</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'UaEUwcYLlkREnSn9jPNe0oRf-gzGzoHsz',
      appKey     : '5d7KwGdf31jiCBxBobH0wVk6',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/miku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
